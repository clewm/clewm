---
title: 25种设计模式代码示例

categories: 
- 技术
- 设计模式
- 开发常用

tags:
- Java
- 设计模式

description: 25种设计模式代码示例
---

# 设计模式

菜鸟设计模式：

https://www.runoob.com/design-pattern/design-pattern-tutorial.html



UML类图教程：

https://blog.csdn.net/weixin_57504000/article/details/124218420

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

# 一、创建型模式

## 1.工厂模式

获得**复杂对象**实例（简单对象只需要new即可），而无须关心其具体的实现细节。

**实现：**

定义一个接口

```java
public interface Phone {

    public String use();
}
```

定义实体，并继承该接口

```java
public class Oppo implements Phone {

    @Override
    public String use() {
        return "我是oppo  ";
    }
}
```

```java
public class Xiaomi implements Phone {

    @Override
    public String use() {
        return "我是小米";
    }
}
```

定义工厂类：

```java
public class PhoneFactory {

    public static class Type{
        public static final String TYPE_XIAOMI = "xiaomi";
        public static final String TYPE_OPPO = "oppo";
    }

    public Phone getPhoneByType(String type) {
        if(type.equalsIgnoreCase(Type.TYPE_XIAOMI)){
            return new Xiaomi();
        }else if(type.equalsIgnoreCase(Type.TYPE_OPPO)){
            return new Oppo();
        }
        return null;
    }
}
```

使用：

```java
public class Test {

    public static void main(String[] args) {
        PhoneFactory phoneFactory = new PhoneFactory();
        Phone xiaomi = phoneFactory.getPhoneByType(PhoneFactory.Type.TYPE_XIAOMI);
        System.out.println(xiaomi.use());
    }
}
```

**结果**

![image-20221214080627939](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214080627939.png)

## 2.抽象工厂模式

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。



定义一个抽象工厂类：

```java
public abstract class AbstractFactory {

    public abstract Phone getPhoneByType(String phoneType);

    public abstract Color getColorByType(String phoneType);
}
```

具体的工厂类继承该抽象工厂类：

手机工厂：

```java
public class PhoneFactory extends AbstractFactory {

    public static class Type{
        public static final String TYPE_XIAOMI = "xiaomi";
        public static final String TYPE_OPPO = "oppo";
    }

    public Phone getPhoneByType(String type) {
        if(type.equalsIgnoreCase(Type.TYPE_XIAOMI)){
            return new Xiaomi();
        }else if(type.equalsIgnoreCase(Type.TYPE_OPPO)){
            return new Oppo();
        }
        return null;
    }

    @Override
    public Color getColorByType(String phoneType) {
        return null;
    }
}
```

颜色工厂：

```java
public class ColorFactory extends AbstractFactory {

    public static class TYPE{
        public static final String TYPE_RED = "red";

        public static final String TYPE_YELLOW = "yellow";
    }

    @Override
    public Phone getPhoneByType(String phoneType) {

        return null;
    }

    @Override
    public Color getColorByType(String phoneType) {
        if (TYPE.TYPE_RED.equalsIgnoreCase(phoneType)) {
            return new Red();
        }else if (TYPE.TYPE_YELLOW.equalsIgnoreCase(phoneType)){
            return new Yellow();
        }
        return null;
    }
}
```

定义一个超级工厂类，用于获得具体的工厂：

```java
public class RootFactory {

    public static class TYPE{
        public static final String TYPE_PHONE = "phone";
        public static final String TYPE_COLOR = "color";
    }

    public static AbstractFactory getFactoryByType(String factoryType) {
        if (TYPE.TYPE_PHONE.equalsIgnoreCase(factoryType)){
            return new PhoneFactory();
        }else if(TYPE.TYPE_COLOR.equals(factoryType)){
            return new ColorFactory();
        }
        return null;
    }
}
```

使用：

```java
public static void main(String[] args) {
    //获得工厂
    AbstractFactory factoryByType = RootFactory.getFactoryByType(RootFactory.TYPE.TYPE_COLOR);
    //从工厂获得对象
    Color colorByType = factoryByType.getColorByType(ColorFactory.TYPE.TYPE_RED);
    System.out.println(colorByType.show());
}
```

**结果**

![image-20221214080715116](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214080715116.png)

## 3.构造器模式

参考：https://www.dandelioncloud.cn/article/details/1523275053169147905

传统的构造对象方式：

```java
Person person = new Person();
person.setId(1);
person.setName("张小毛");
person.setAge(22);
person.setSex("男");
person.setPhone("19999999999");
person.setAddress("beijing");
person.setDesc("JavaBeans模式");
```

- 优点：易于阅读，并且可以只对有用的成员变量赋值
- 缺点：成员变量不可以是 final 类型，失去了不可变对象的很多好处，对象状态不连续，你必须调用7次setter方法才能得到一个具备7个属性值得变量，在这期间用户可能拿到不完整状态的对象。如果有N个属性，岂不是要`person.setXXX`调用N次？此种方式不优雅

构造器模式演示：

```java
PrivateKeyDecryptParam param = new PrivateKeyDecryptParam.Builder()
                                              .uAppId(uAppId)
                                              .containerId(containerId)
                                              .cipher(cipher)
                                              .signFlag(signFlag)
                                              .build();
```

示例：

```java
@Data
@ToString
public class User {

    private String name;

    private Integer age;

    private Integer sex;

    private User(Builder builder){
        this.name = builder.name;
        this.age = builder.age;
        this.sex = builder.sex;
    }

    public static class Builder {

        //必要参数
        private final String name;

        //可选参数
        private Integer age;
        private Integer sex;

        public Builder(String name){
            this.name = name;
        }

        public Builder age(Integer age) {
            this.age = age;
            return this;
        }

        public Builder sex(Integer sex) {
            this.sex = sex;
            return this;
        }

        public User build() {
            return new User(this);
        }
    }
}
```

使用：

```java
        User cleWm = new User.Builder("CleWm")
                .age(21)
                .sex(0)
                .build();
```

要点：

- 外部类的构造函数私有，且参数为静态内部类；
- 静态内部类拥有外部类相同的属；
- 为每一个属性，写一个方法，返回的是Builer；
- 最后一个方法是build方法，用于构建一个外部类；

优点：降低复杂性，优雅

缺点：代码量提高了



## 4.单例模式

一个类确保只有单个对象被创建

**饿汉式：**

```java
public class HungrySingleton {

    private static HungrySingleton instance = new HungrySingleton();

    private HungrySingleton(){}

    public static HungrySingleton getInstance(){
        return instance;
    }
}
```

**懒汉式：**

双重检查锁：

```java
public class LazySingleton {

    private static LazySingleton instance;

    private LazySingleton() {}

    public static LazySingleton getInstance() {
        if(instance == null){
            synchronized (LazySingleton.class){
                if (instance == null){
                    instance = new LazySingleton();
                }
            }
        }
        return instance;
    }
}
```

静态内部类：

```java
public class LazySingleton2 {

    private LazySingleton2(){}

    /**
     * 静态内部类和非静态内部类都是在被调用的时候才会进行加载，和外部类没有关系，从而实现了延迟加载
     */
    private static class SingletonHolder{
        private static final LazySingleton2 instance = new LazySingleton2();
    }

    public static LazySingleton2 getInstance() {
        return SingletonHolder.instance;
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1() {
        LazySingleton instance1 = LazySingleton.getInstance();
        LazySingleton instance2 = LazySingleton.getInstance();
        System.out.println(instance1 == instance2);

        LazySingleton2 instance3 = LazySingleton2.getInstance();
        LazySingleton2 instance4 = LazySingleton2.getInstance();
        System.out.println(instance3 == instance4);
    }
}
```

**结果**

![image-20221214081317951](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214081317951.png)

## 5.原型模式

原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。一般会配合工厂模式一起使用。

与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。

定义一个抽象父类，并实现Cloneable接口：

```java
/**
 * Cloneable是一个标识接口，clone方法是Object提供的方法，
 * 只有实现了Cloneable接口，同时重写clone方法才不会报错
 */
@Getter
@ToString
public abstract class Book implements Cloneable{

    protected String name;

    protected Integer type;

    @Override
    protected Book clone(){
        Object clone = null;
        try{
            clone = super.clone();
        }catch (CloneNotSupportedException e){
            e.printStackTrace();
        }
        return (Book)clone;
    }
}
```

定义具体实现类：

```java
public class BookOne extends Book{

    BookOne() {
        name = "《第一本书》";
        type = 1;
    }
}
```

```java
public class BookTwo extends Book{

    BookTwo() {
        name = "《第二本书》";
        type = 2;
    }
}
```

定义一个Factory来获得克隆对象：

```java
public class BookFactory {

    /**
     * 用于存储我们的原始对象，克隆对象以此为基础进行复制
     */
    private static final Map<Integer,Book> cache;

    static {
        cache = new HashMap<>();
        cache.put(Type.TYPE_ONE,new BookOne());
        cache.put(Type.TYPE_TWO,new BookTwo());
    }

    public static class Type{
        public static final Integer TYPE_ONE = 1;
        public static final Integer TYPE_TWO = 2;
    }

    /**
     * 返回的是克隆对象
     * @param type
     * @return
     */
    public static Book getBookByType(Integer type) {
        return cache.get(type).clone();
    }
}
```

**测试**

```java
public class Test {
    @org.junit.Test
    public void test1() {
        Book book1 = BookFactory.getBookByType(BookFactory.Type.TYPE_ONE);
        Book book2 = BookFactory.getBookByType(BookFactory.Type.TYPE_ONE);
        System.out.println(book1 == book2);
        System.out.println(book1);
        System.out.println(book2);
    }
}
```

**结果**

![image-20221214081502987](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214081502987.png)

# 二、结构型模式

## 6.适配器模式

适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁

比如220V的电源，使用电源适配器给手机提供12V的电压充电。

**定义一个目标接口，该接口属于一般情况**

```java
public interface Target {

    public void get();
}
```

**定义一个不兼容的，需要被适配的实现**

```java
public class SpecialStatus {

    public void specialGet() {
        System.out.println("这是特殊情况的get实现");
    }
}
```

**定义适配器，实现Target接口**

```java
public class Adapter implements Target {

    private SpecialStatus specialStatus;

    public Adapter(SpecialStatus specialStatus){
        this.specialStatus = specialStatus;
    }

    @Override
    public void get() {
        specialStatus.specialGet();
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1() {
        SpecialStatus specialStatus = new SpecialStatus();
        Adapter adapter = new Adapter(specialStatus);
        adapter.get();
    }
}
```

**结果**

![image-20221217093732742](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217093732742.png)

## 7.桥接模式

Bridge，它的作用是将抽象部分和它的实现部分分离，从而可以让它们独立地变化。

就好比有一个武器槽，放不同的武器进去就是不同的功能。s

**先定义抽象部分，比如武器槽**

```java
public abstract class WeaponSlot {

    protected Weapon weapon;

    abstract void shoot();

    public void setWeapon(Weapon weapon){
        this.weapon = weapon;
    }

    public abstract void opreation();
}
```

**定义实现的接口**

```java
public interface Weapon {

    void shoot();
}
```

**定义抽象部分的实现**

```java
public class LeftSlot extends WeaponSlot{

    @Override
    void shoot() {
        weapon.shoot();
    }

    @Override
    public void opreation() {
        weapon.shoot();
    }
}
```

**定义实现接口的实现**

```java
public class AK47 implements Weapon {
    @Override
    public void shoot() {
        System.out.println("AK开枪了！");
    }
}
```

```java
public class M4 implements Weapon {
    @Override
    public void shoot() {
        System.out.println("m4开枪！");
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1() {

        M4 m4 = new M4();
        AK47 ak47 = new AK47();

        LeftSlot leftSlot = new LeftSlot();
        leftSlot.setWeapon(m4);
        leftSlot.opreation();

        leftSlot.setWeapon(ak47);
        leftSlot.opreation();
    }
}
```

**结果**

![image-20221217103542571](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103542571.png)

## 8.过滤器模式

Filter ，它的作用是过滤序列中的特定元素。

**定义一个过滤器的接口**

```java
public interface Filter <T>{

    List<T> doFilter(List<T> lists);
}
```

**定义要过滤的实体类**

```java
@Data
public class User {

    private String name;

    private Integer age;

    private Integer sex;
}
```

**定义过滤器的具体实现**

年龄过滤器：

```java
public class AgeFilter implements Filter<User> {

    @Override
    public List<User> doFilter(List<User> lists) {
        ArrayList<User> res = new ArrayList<>();
        for (User user : lists) {
            if(user.getAge() >= 18){
                res.add(user);
            }
        }
        return res;
    }
}
```

性别过滤器：

```java
public class SexFilter implements Filter<User> {
    @Override
    public List<User> doFilter(List<User> lists) {
        ArrayList<User> res = new ArrayList<>();
        for (User user : lists) {
            if (user.getSex() == 1){
                res.add(user);
            }
        }
        return res;
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1() {
        AgeFilter ageFilter = new AgeFilter();
        SexFilter sexFilter = new SexFilter();
        ArrayList<User> userArrayList = new ArrayList<>();
        for (int i = 1; i < 10; i++) {
            User user = new User();
            user.setAge(RandomUtil.randomInt(10,35));
            user.setName("张" + i);
            user.setSex(RandomUtil.randomEle(new Integer[]{0,1}));
            userArrayList.add(user);
        }
        List<User> users1 = ageFilter.doFilter(userArrayList);
        System.out.println("第一次过滤后的结果：" + users1);

        List<User> users2 = sexFilter.doFilter(users1);
        System.out.println("第二次过滤后的结果：" + users2);
    }
}
```

**结果**

![image-20221217103713100](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103713100.png)

## 9.组合模式

Composite，是用于把一组相似的对象当作一个单一的对象。组合模式依据**树形结构**来组合对象，用来表示部分以及整体层次。

例如：在可视化开发中，容器和按钮等组件之间的关系。又或者是公司、学校的组织架构等。

以学校为例：

**定义一个员工类：**

```java
@Data
@ToString(exclude = "subordinates")
public class Employee {

    private String name;

    private String dept;

    private Integer salary;

    private List<Employee> subordinates;

    public Employee(String name, String dept, Integer salary) {
        this.name = name;
        this.dept = dept;
        this.salary = salary;
        this.subordinates = new ArrayList<>();
    }

    public void addSubordinate(Employee subordinate) {
        subordinates.add(subordinate);
    }

    public void removeSubordinate(Employee subordinate) {
        subordinates.remove(subordinate);
    }
}
```

**测试：**

```java
public class Test {

    @org.junit.Test
    public void test1() {
        Employee 张昌平 = new Employee("张昌平", "校长", 30000);

        Employee 张雪迎 = new Employee("张雪迎", "7班班主任", 10000);
        Employee 刘静 = new Employee("刘静", "8班班主任", 9000);

        Employee 胡伟明 = new Employee("胡伟明", "7班学生", 0);
        Employee 李冠杰 = new Employee("李冠杰", "7班学生", 0);
        Employee 田继睿 = new Employee("田继睿", "7班学生", 0);
        Employee 冯毅力 = new Employee("冯毅力", "7班学生", 0);

        Employee 冯跟源 = new Employee("冯跟源", "8班学生", 0);
        Employee 施冰清 = new Employee("施冰清", "8班学生", 0);



        张昌平.addSubordinate(张雪迎);
        张昌平.addSubordinate(刘静);


        张雪迎.addSubordinate(胡伟明);
        张雪迎.addSubordinate(李冠杰);
        张雪迎.addSubordinate(田继睿);
        张雪迎.addSubordinate(冯毅力);

        刘静.addSubordinate(冯跟源);
        刘静.addSubordinate(施冰清);

        /**
         * 二叉树如下:
         *                      张昌平
         *                    /      \
         *                   /        \
         *                张雪迎        刘静
         *                / | | \      / \
         *               /  | |  \    /   \
         *             胡   李 冯 田   冯   施
         */
        System.out.println(张昌平);
        for (Employee sub1 : 张昌平.getSubordinates()){
            System.out.println(sub1);
            for (Employee sub2 : sub1.getSubordinates()){
                System.out.println(sub2);
            }
        }
    }
}
```

**结果**

![image-20221217103845510](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103845510.png)

## 10.装饰器模式

Decorator，允许向一个现有的对象添加新的功能，同时又不改变其结构。

**定义一个接口**

```java
public interface Person {

    void eat();
}
```

**定义一个接口的实现**

```java
public class CleWm implements Person {
    @Override
    public void eat() {
        System.out.println("吃了一碗饭...");
    }
}
```

**定义一个装饰器，实现接口**

```java
public class Decorator implements Person {

    private Person person;

    @Override
    public void eat() {
        person.eat();
        System.out.println("person又吃了一碗...");
    }

    public void setPerson(Person person) {
        this.person = person;
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1() {
        CleWm cleWm = new CleWm();
        Decorator decorator = new Decorator();
        decorator.setPerson(cleWm);
        decorator.eat();
    }
}
```

**结果**

![image-20221217103941837](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103941837.png)

## 11.外观模式

Facade，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。

```java
// 外观类
public class Facade {
   private Subsystem1 subsystem1;
   private Subsystem2 subsystem2;

   public Facade() {
      subsystem1 = new Subsystem1();
      subsystem2 = new Subsystem2();
   }

   // 提供一个简化的接口，用于客户端访问子系统
   public void operation() {
      subsystem1.operation1();
      subsystem2.operation1();
   }
}

// 子系统1
public class Subsystem1 {
   public void operation1() {
      // 实现子系统1的相关操作
   }
}

// 子系统2
public class Subsystem2 {
   public void operation1() {
      // 实现子系统2的相关操作
   }
}
```

## 12.享元模式

Flyweight，主要用于减少创建对象的数量，以减少内存占用和提高性能。

说白了就是在工厂模式的工厂类中，缓存一个Map，每次创建对象的时候就进行一个判断，若指定对象存在，则直接从map中取出并返回，若没有，则新建，然后缓存进入Map当中。

**创建一个颜色**

```java
public class Color {

    public String colorName;

    public Color(String colorName){
        this.colorName = colorName;
    }
}
```

**创建一个颜色工厂**

```java
public class ColorFactory {

    private Map<String, Color> map = new HashMap<>();

    public Color getColor(String colorName) {
        return Optional.ofNullable(map.get(colorName)).orElseGet(()->{
            Color color = new Color(colorName);
            map.put(colorName,color);
            return color;
        });
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1() {
        ColorFactory colorFactory = new ColorFactory();
        Color red1 = colorFactory.getColor("red");
        Color red2 = colorFactory.getColor("red");
        Color red3 = colorFactory.getColor("blue");
        System.out.println(red1 == red2);
    }
}
```

**结果**

![image-20221217104139185](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104139185.png)

## 13.代理模式

Proxy，它通过引入一个新的类来控制对另一个对象的访问。这有助于控制对原始对象的访问，并且可以在访问原始对象时执行其他附加操作。

**定义一个接口，包含被代理的方法**

```java
public interface Image {

    public void show();
}
```

**定义原始类**

```java
public class Realimage implements Image {

    private String path;

    public Realimage(String path) {
        this.path = path;
        loadFromDisk();
    }

    @Override
    public void show() {
        System.out.println("展示" + path + "的图片");
    }

    void loadFromDisk() {
        System.out.println("正在从磁盘中加载图片:" + path);
    }
}
```

**定义代理对象**

```java
public class ProxyImage implements Image {

    private String path;

    private Realimage realimage;

    public ProxyImage(String path) {
        this.path = path;
    }

    @Override
    public void show() {
        if(realimage == null){
            realimage = new Realimage(path);
        }
        realimage.show();
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1() {
        ProxyImage proxyImage = new ProxyImage("C:\\test.jpg");
        proxyImage.show();
    }
}
```

**结果**

![image-20221217104158303](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104158303.png)

# 三、行为型模式

## 14.责任链模式

Chain of Responsibility，为请求创建了一个接收者对象的链。

通常每个接收者都包含对另一个接收者的引用。**如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者**，依此类推。

**定义一个实体**

```java
@Data
@AllArgsConstructor
public class Package {

    private String loc;
}
```

**定义一个处理器的抽象父类**

```java
public abstract class PackageHandler {

    private PackageHandler next;

    public void next(PackageHandler next){
        this.next = next;
    }

    public void handler(Package p){
        if(next != null){
            next.handler(p);
        }else {
            System.out.println("接收到一个未知地点的包裹....");
        }
    }
}
```

**定义处理器的实现**

```java
public class KunmingPackageHandler extends PackageHandler{
    @Override
    public void handler(Package p) {
        if("昆明".equals(p.getLoc())){
            System.out.println("处理了一个昆明的包裹...[" + this + "]");
            return;
        }else {
            super.handler(p);
        }
    }
}
```

```java
public class TianJinPackageHandler extends PackageHandler{

    @Override
    public void handler(Package p) {
        if("天津".equals(p.getLoc())){
            System.out.println("处理了一个天津的包裹...[" + this + "]");
            return;
        }else {
            super.handler(p);
        }
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1() {
        KunmingPackageHandler kunmingPackageHandler = new KunmingPackageHandler();
        TianJinPackageHandler tianJinPackageHandler = new TianJinPackageHandler();

        // |kunmingPackageHandler| ------ |tianJinPackageHandler| ------ null
        kunmingPackageHandler.next(tianJinPackageHandler);


        Package package1 = new Package("天津");
        Package package2 = new Package("昆明");
        Package package3 = new Package("四川");

        List<Package> packageList = ListUtil.of(package1, package2, package3);
        for (Package aPackage : packageList) {
            kunmingPackageHandler.handler(aPackage);
        }
    }
}
```

**结果**

![image-20221217104231704](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104231704.png)

## 15.命令模式

Command，**命令模式允许请求的一方和接收的一方独立开来**，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。

![image-20221211094616223](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221211094616223.png)

简单理解就是，封装一条命令，为该命令设置一个接收者，然后将该命令set进一个调用者对象（Invoker）中，最后调用Invoker的runCommand方法来执行命令。

**创建命令接口**

```java
public interface Command {

    void run();
}
```

**创建接收者(可以理解为被隐藏的具体功能实现的部分)**

```java
public class Receiver {

    private Integer stock = 100;

    /**
     * 接收者的增加库存接口，命令调用者无须关心这些接口。
     */
    public void increase() {
        stock++;
        System.out.println("[库存剩余]:" + stock);
    }

    /**
     * 接收者的减少库存接口，命令调用者无须关心这些接口。
     */
    public void decrease() {
        stock--;
        System.out.println("[库存剩余]:" + stock);
    }
}
```

**创建命令实现**

```java
public class AddStockCommand implements Command {

    private Receiver receiver;

    public AddStockCommand(Receiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public void run() {
        receiver.increase();
        System.out.println("添加了1个库存...");
    }
}
```

```java
public class SubStockCommand implements Command {

    private Receiver receiver;

    public SubStockCommand(Receiver receiver){
        this.receiver = receiver;
    }

    @Override
    public void run() {
        receiver.decrease();
        System.out.println("减少了1个库存...");
    }
}
```

**创建调用者**

```java
public class Invoker{

    // 这里也可用一个List来存储命令，在调用时使用for循环命令依次执行。
    private Command command;

    public Invoker(Command command){
        this.command = command;
    }

    public void invokeCommand() {
        if(command != null){
            command.run();
            System.out.println("命令执行完毕...");
        }else {
            System.out.println("未设置命令！");
        }
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1() {
        // 创建一个接收者
        Receiver receiver = new Receiver();

        // 库存增加命令
        AddStockCommand addStockCommand = new AddStockCommand(receiver);
        // 库存减少命令
        SubStockCommand subStockCommand = new SubStockCommand(receiver);

        // 创建一个调用者
        Invoker invoker1 = new Invoker(addStockCommand);
        // 让调用者执行命令。
        invoker1.invokeCommand();

        // 创建一个调用者
        Invoker invoker2 = new Invoker(subStockCommand);
        // 让调用者执行命令。
        invoker2.invokeCommand();
    }
}
```

**结果**

![image-20221217104253518](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104253518.png)

## 16.解释器模式

Interpreter，它允许你定义一个语言的文法，并且基于该文法解释语言中的句子。

**定义表达式接口**

```java
public interface Expression {

    boolean interpret(String content);
}
```

**定义表达式**

**关键词表达式，若内容中包含指定data内容，则为true**

```java
public class KeyWordExpression implements Expression {

    private String data;

    public KeyWordExpression(String data){
        this.data = data;
    }


    @Override
    public boolean interpret(String content) {
        if (data != null){
            return content.contains(data);
        }
        else {
            throw new RuntimeException("未设置表达式data内容");
        }
    }
}
```

**或表达式**

```java
public class OrExpression implements Expression {

    private Expression exp1;
    private Expression exp2;

    public OrExpression(Expression exp1,Expression exp2) {
        this.exp1 = exp1;
        this.exp2 = exp2;
    }

    @Override
    public boolean interpret(String content) {
        return exp1.interpret(content) || exp2.interpret(content);
    }
}
```

**与表达式**

```java
public class AndExpression implements Expression {

    private Expression exp1;
    private Expression exp2;

    public AndExpression(Expression exp1, Expression exp2) {
        this.exp1 = exp1;
        this.exp2 = exp2;
    }

    @Override
    public boolean interpret(String content) {
        return exp1.interpret(content) && exp2.interpret(content);
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1() {
        KeyWordExpression exp1 = new KeyWordExpression("CleWm");
        boolean res1 = exp1.interpret("I am CleWm");

        KeyWordExpression exp2 = new KeyWordExpression("CleWm");
        KeyWordExpression exp3 = new KeyWordExpression("clewm");

        OrExpression exp4 = new OrExpression(exp2, exp3);
        boolean res2 = exp4.interpret("CleWm");
        AndExpression exp5 = new AndExpression(exp2, exp3);
        boolean res3 = exp5.interpret("CleWm");
        System.out.println(res1);
        System.out.println(res2);
        System.out.println(res3);
    }
}
```

**结果**

![image-20221217104357944](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104357944.png)

## 17.迭代器模式

Iterator，这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

**创建迭代器接口**

```java
public interface Container {

    MyIterator getIterator();
}
```

**创建容器接口，该接口用于使得容器能够返回一个迭代器**

```java
public interface Container {

    MyIterator getIterator();
}
```

**创建容器的实现**

```java
public class PersonRepository implements Container {

    private static final List<String> personList;
    private int index;

    static {
        personList = ListUtil.of("张三","李四","王五","赵六");
    }

    @Override
    public MyIterator getIterator() {
        index = 0;
        return new PersonIterator();
    }

    private class PersonIterator implements MyIterator<String>{

        @Override
        public boolean hasNext() {
            return personList.size() > 0 && index < personList.size();
        }

        @Override
        public String next() {
            return personList.get(index++);
        }
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1(){
        PersonRepository personRepository = new PersonRepository();
        MyIterator iterator = personRepository.getIterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
```

**结果**

![image-20221217104416848](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104416848.png)

## 18.中介者模式

Mediator，这种模式提供了一个中介类，该类通常处理不同类之间的通信。

聊天室为例

**定义用户**

```java
@Data
public class User {

    private String name;
    private ChatRoom chatRoom;

    public User(String name){
        this.name = name;
    }

    public void sendMessage(String content) {
        System.out.println(name + " 发送一条消息:" + content);
        Message message = new Message(name, content);
        if(chatRoom == null){
            throw new RuntimeException("未加入任何聊天室");
        }
        chatRoom.send(message);
    }

    public void receiveMessage(Message message) {
        System.out.println(name + " 收到一条消息: " + message);
    }
}
```

**定义消息**

```java
@Data
@AllArgsConstructor
public class Message {

    private String from;
    private String content;
}
```

**定义聊天室**

```java
public class ChatRoom {

    private List<User> userList = new ArrayList<>();

    public void send(Message message){
        for (User user : userList){
            if(message.getFrom().equals(user.getName())) continue;
            user.receiveMessage(message);
        }
    }

    public void register(User user) {
        user.setChatRoom(this);
        userList.add(user);
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1() {
        ChatRoom chatRoom = new ChatRoom();

        User 张三 = new User("张三");
        User 李四 = new User("李四");
        User 王五 = new User("王五");
        chatRoom.register(张三);
        chatRoom.register(李四);
        chatRoom.register(王五);

        张三.sendMessage("你好，我是张三");
    }
}
```

**结果**

![image-20221217104510201](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104510201.png)

## 19.备忘录模式

Memento，保存（备份）一个对象的某个状态，以便在适当的时候恢复对象。

**Memento ： 备忘录对象,负责 保存好记录，即Originator内部 状态**

```java
@Data
public class Memento {

    private String state;

    public Memento(String state){
        this.state = state;
    }
}
```

**originator : 对象(需要保存 状态的对象)**

```java
@Data
public class Originator {

    private String state;

    public Memento saveStateToMemento() {
        return new Memento(state);
    }

    public void restoreStateFromMemento(Memento memento) {
        this.state = memento.getState();
    }
}
```

**Caretaker: 备忘录管理者,负责保存多个备忘录对象， 使用集合管理，提高效率**

```java
public class MementoManager {

    private static List<Memento> mementoList;

    static {
        mementoList = new ArrayList<>();
    }

    public static boolean add(Memento memento){
        return mementoList.add(memento);
    }

    public static Memento remove(int index) {
        return mementoList.remove(index);
    }

    public static Memento get(int index){
        return mementoList.get(index);
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1() {
        Originator originator = new Originator();
        originator.setState("初始状态");
        boolean add = MementoManager.add(originator.saveStateToMemento());
        if(!add) throw new RuntimeException("保存状态失败！");
        originator.setState("第一状态");
        System.out.println("origin的状态为:" + originator.getState());
        originator.restoreStateFromMemento(MementoManager.get(0));
        System.out.println("origin的状态为:" + originator.getState());
    }
}
```

**结果**

**![image-20221217104545873](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104545873.png)**

## 20.观察者模式

Observer，当一个对象被修改时，则会自动通知依赖它的对象。

**创建一个被订阅的（Up主）**

```java
public class Up {

    private String latestVideo;

    private List<Follower> followers = new ArrayList<>();

    public void submitVideo(String video) {
        this.latestVideo = video;
        notifyAllFollowers();
    }

    public void addFollower(Follower follower) {
        followers.add(follower);
    }

    public void notifyAllFollowers() {
        for (Follower follower : followers) {
            follower.update(latestVideo);
        }
    }
}
```

**创建一个订阅者（粉丝）**

```java
public class Follower{

    private String name;
    private String video;
    private Up up;

    public Follower(String name,Up up) {
        this.name = name;
        this.up = up;
        this.up.addFollower(this);
    }

    public void update(String video) {
        this.video = video;
        System.out.println(name + " 收到up主 " + up + " 的最新视频 " + video);
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1() {
        Up up = new Up();
        Follower 张三 = new Follower("张三", up);
        Follower 李四 = new Follower("李四", up);

        up.submitVideo("第1个视频");
        System.out.println("-------------");
        up.submitVideo("第2个视频");
    }
}
```

**结果**

![image-20221217104623464](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104623464.png)

## 21.状态模式

State，类的行为是基于它的状态改变的。

**定义状态接口**

```java
public interface State {

    void doAction(Context context);
}
```

**定义一个随着状态改变而做出不同行为的Context上下文**

```java
@Data
public class Context {

    private State state;

}
```

**定义状态的实现**

```java
public class StartState implements State {

    @Override
    public void doAction(Context context) {
        System.out.println("当前是开始状态...");
        context.setState(this);
    }
}
```

```java
public class EndState implements State {
    @Override
    public void doAction(Context context) {
        System.out.println("当前是结束状态...");
        context.setState(this);
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1() {
        Context context = new Context();

        StartState startState = new StartState();
        startState.doAction(context);

        EndState endState = new EndState();
        endState.doAction(context);
    }
}
```

**结果**

![image-20221217104706915](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104706915.png)

## 22.空对象模式

Null Object，一个空对象取代 NULL 对象。

**定义实体类抽象父类**

```java
@Data
public abstract class AbstractUser {

    protected String name;

    public abstract boolean isNull();
}
```

**定义正常的存在的用户对象**

```java
public class User extends AbstractUser{
    public User(String name){
        this.name = name;
    }

    @Override
    public boolean isNull() {
        return false;
    }
}
```

**空对象**

```java
public class EmptyUser extends AbstractUser{

    public EmptyUser() {
        this.name = "空用户对象...";
    }

    @Override
    public boolean isNull() {
        return true;
    }
}
```

**创建一个测试用的工厂**

```java
public class UserFactory {

    private static List<String> nameList;

    static {
        nameList = ListUtil.of("张三","李四","王五");
    }

    public static AbstractUser getUser(String name) {
        for (String n : nameList) {
            if(n.equalsIgnoreCase(name)){
                return new User(name);
            }
        }
        return new EmptyUser();
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1() {
        AbstractUser 张三 = UserFactory.getUser("张三");
        AbstractUser 赵六 = UserFactory.getUser("赵六");

        System.out.println(张三);
        System.out.println(赵六);
    }
}
```

**结果**

![image-20221214080526276](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214080526276.png)

## 23.策略模式

Strategy，一个类的行为或其算法可以在运行时更改。

**定义策略的接口**

```java
public interface Strategy {

    public int doStrategy(int a,int b);
}
```

**定义策略实现**

```java
public class AddStrategy implements Strategy {

    @Override
    public int doStrategy(int a, int b) {
        return a + b;
    }
}
```

```java
public class SubStrategy implements Strategy {
    @Override
    public int doStrategy(int a, int b) {
        return a - b;
    }
}
```

**定义一个可更改策略的上下文**

```java
@Data
public class Context {

    private Strategy strategy;

    public int executeStrategy(int a,int b){
        if(strategy != null){
            return strategy.doStrategy(a,b);
        }else {
            throw new RuntimeException("尚未设置策略！");
        }
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1() {
        Context context = new Context();
        AddStrategy addStrategy = new AddStrategy();
        SubStrategy subStrategy = new SubStrategy();

        context.setStrategy(addStrategy);
        int i1 = context.executeStrategy(1, 2);
        System.out.println(i1);

        context.setStrategy(subStrategy);
        int i2 = context.executeStrategy(5, 2);
        System.out.println(i2);
    }
}
```

**结果**

两个3

## 24.模板模式

Template，在抽象类中提前定义了某个操作的一系列流程的模板，用户只需要实现具体细节即可。

**定义抽象模板父类**

```java
public abstract class MyGame {

    protected String name;

    abstract void downloadGame();
    abstract void installGame();
    abstract void openGame();

    public void playGame() {
        downloadGame();
        installGame();
        openGame();
        System.out.println("开始游戏:[" + name + "]");
    }
}
```

**创建抽象父类的实现**

```java
public class LOL extends MyGame{

    public LOL(){
        this.name = "LOL";
    }

    @Override
    void downloadGame() {
        System.out.println("正在下载游戏:" + name);
    }

    @Override
    void installGame() {
        System.out.println("正在安装游戏:" + name);
    }

    @Override
    void openGame() {
        System.out.println("正在打开游戏:" + name);
    }
}
```

```java
public class CSGO extends MyGame{

    public CSGO() {
        this.name = "CSGO";
    }

    @Override
    void downloadGame() {
        System.out.println("正在下载游戏:" + name);
    }

    @Override
    void installGame() {
        System.out.println("正在安装游戏:" + name);
    }

    @Override
    void openGame() {
        System.out.println("正在打开游戏:" + name);
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1() {
        LOL lol = new LOL();
        CSGO csgo = new CSGO();

        lol.playGame();
        csgo.playGame();
    }
}
```

**结果**

![image-20221215170923686](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221215170923686.png)

## 25.访问者模式

Visitor，封装一些作用于某些数据结构中的各元素的操作，它可以在不改变数据结构的前提下赋予这些元素新的操作。

**定义被访问者的统一接口**

```java
public interface Person{

    public void accept(Visitor visitor);
}
```

**定义被访问者实例**

```java
@Data
@AllArgsConstructor
public class Student implements Person {

    private String name;
    private Integer rank;

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}
```

```java
@Data
@AllArgsConstructor
public class Teacher implements Person {

    private String name;
    private Integer salary;

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}
```

**定义访问者接口**

```java
public interface Visitor {

    public void visit(Student student);

    public void visit(Teacher teacher);
}
```

**定义访问者实例**

```java
public class Headmaster implements Visitor {
    @Override
    public void visit(Student student) {
        System.out.println("访问学生:" + student.getName() + ",排名为:" + student.getRank());
    }

    @Override
    public void visit(Teacher teacher) {
        System.out.println("访问老师:" + teacher.getName() + ",月薪为:" + teacher.getSalary());
    }
}
```

**测试**

```java
public class Test {

    @org.junit.Test
    public void test1() {
        Student student = new Student("张三",21);
        Teacher teacher = new Teacher("张雪迎",8000);
        Headmaster headmaster = new Headmaster();

        student.accept(headmaster);
        teacher.accept(headmaster);
    }
}
```

**结果**

![image-20221216100457969](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221216100457969.png)
