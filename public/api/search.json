[{"id":"7b8b6ec466d1e9597a02dfeba735af86","title":"25种设计模式代码示例","content":"设计模式菜鸟设计模式：\nhttps://www.runoob.com/design-pattern/design-pattern-tutorial.html\nUML类图教程：\nhttps://blog.csdn.net/weixin_57504000/article/details/124218420\n创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。\n结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。\n行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n一、创建型模式1.工厂模式获得复杂对象实例（简单对象只需要new即可），而无须关心其具体的实现细节。\n实现：\n定义一个接口\npublic interface Phone &#123;\n\n    public String use();\n&#125;\n\n定义实体，并继承该接口\npublic class Oppo implements Phone &#123;\n\n    @Override\n    public String use() &#123;\n        return &quot;我是oppo  &quot;;\n    &#125;\n&#125;\n\npublic class Xiaomi implements Phone &#123;\n\n    @Override\n    public String use() &#123;\n        return &quot;我是小米&quot;;\n    &#125;\n&#125;\n\n定义工厂类：\npublic class PhoneFactory &#123;\n\n    public static class Type&#123;\n        public static final String TYPE_XIAOMI &#x3D; &quot;xiaomi&quot;;\n        public static final String TYPE_OPPO &#x3D; &quot;oppo&quot;;\n    &#125;\n\n    public Phone getPhoneByType(String type) &#123;\n        if(type.equalsIgnoreCase(Type.TYPE_XIAOMI))&#123;\n            return new Xiaomi();\n        &#125;else if(type.equalsIgnoreCase(Type.TYPE_OPPO))&#123;\n            return new Oppo();\n        &#125;\n        return null;\n    &#125;\n&#125;\n\n使用：\npublic class Test &#123;\n\n    public static void main(String[] args) &#123;\n        PhoneFactory phoneFactory &#x3D; new PhoneFactory();\n        Phone xiaomi &#x3D; phoneFactory.getPhoneByType(PhoneFactory.Type.TYPE_XIAOMI);\n        System.out.println(xiaomi.use());\n    &#125;\n&#125;\n\n结果\n\n2.抽象工厂模式抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。\n定义一个抽象工厂类：\npublic abstract class AbstractFactory &#123;\n\n    public abstract Phone getPhoneByType(String phoneType);\n\n    public abstract Color getColorByType(String phoneType);\n&#125;\n\n具体的工厂类继承该抽象工厂类：\n手机工厂：\npublic class PhoneFactory extends AbstractFactory &#123;\n\n    public static class Type&#123;\n        public static final String TYPE_XIAOMI &#x3D; &quot;xiaomi&quot;;\n        public static final String TYPE_OPPO &#x3D; &quot;oppo&quot;;\n    &#125;\n\n    public Phone getPhoneByType(String type) &#123;\n        if(type.equalsIgnoreCase(Type.TYPE_XIAOMI))&#123;\n            return new Xiaomi();\n        &#125;else if(type.equalsIgnoreCase(Type.TYPE_OPPO))&#123;\n            return new Oppo();\n        &#125;\n        return null;\n    &#125;\n\n    @Override\n    public Color getColorByType(String phoneType) &#123;\n        return null;\n    &#125;\n&#125;\n\n颜色工厂：\npublic class ColorFactory extends AbstractFactory &#123;\n\n    public static class TYPE&#123;\n        public static final String TYPE_RED &#x3D; &quot;red&quot;;\n\n        public static final String TYPE_YELLOW &#x3D; &quot;yellow&quot;;\n    &#125;\n\n    @Override\n    public Phone getPhoneByType(String phoneType) &#123;\n\n        return null;\n    &#125;\n\n    @Override\n    public Color getColorByType(String phoneType) &#123;\n        if (TYPE.TYPE_RED.equalsIgnoreCase(phoneType)) &#123;\n            return new Red();\n        &#125;else if (TYPE.TYPE_YELLOW.equalsIgnoreCase(phoneType))&#123;\n            return new Yellow();\n        &#125;\n        return null;\n    &#125;\n&#125;\n\n定义一个超级工厂类，用于获得具体的工厂：\npublic class RootFactory &#123;\n\n    public static class TYPE&#123;\n        public static final String TYPE_PHONE &#x3D; &quot;phone&quot;;\n        public static final String TYPE_COLOR &#x3D; &quot;color&quot;;\n    &#125;\n\n    public static AbstractFactory getFactoryByType(String factoryType) &#123;\n        if (TYPE.TYPE_PHONE.equalsIgnoreCase(factoryType))&#123;\n            return new PhoneFactory();\n        &#125;else if(TYPE.TYPE_COLOR.equals(factoryType))&#123;\n            return new ColorFactory();\n        &#125;\n        return null;\n    &#125;\n&#125;\n\n使用：\npublic static void main(String[] args) &#123;\n    &#x2F;&#x2F;获得工厂\n    AbstractFactory factoryByType &#x3D; RootFactory.getFactoryByType(RootFactory.TYPE.TYPE_COLOR);\n    &#x2F;&#x2F;从工厂获得对象\n    Color colorByType &#x3D; factoryByType.getColorByType(ColorFactory.TYPE.TYPE_RED);\n    System.out.println(colorByType.show());\n&#125;\n\n结果\n\n3.构造器模式参考：https://www.dandelioncloud.cn/article/details/1523275053169147905\n传统的构造对象方式：\nPerson person &#x3D; new Person();\nperson.setId(1);\nperson.setName(&quot;张小毛&quot;);\nperson.setAge(22);\nperson.setSex(&quot;男&quot;);\nperson.setPhone(&quot;19999999999&quot;);\nperson.setAddress(&quot;beijing&quot;);\nperson.setDesc(&quot;JavaBeans模式&quot;);\n\n\n优点：易于阅读，并且可以只对有用的成员变量赋值\n缺点：成员变量不可以是 final 类型，失去了不可变对象的很多好处，对象状态不连续，你必须调用7次setter方法才能得到一个具备7个属性值得变量，在这期间用户可能拿到不完整状态的对象。如果有N个属性，岂不是要person.setXXX调用N次？此种方式不优雅\n\n构造器模式演示：\nPrivateKeyDecryptParam param &#x3D; new PrivateKeyDecryptParam.Builder()\n                                              .uAppId(uAppId)\n                                              .containerId(containerId)\n                                              .cipher(cipher)\n                                              .signFlag(signFlag)\n                                              .build();\n\n示例：\n@Data\n@ToString\npublic class User &#123;\n\n    private String name;\n\n    private Integer age;\n\n    private Integer sex;\n\n    private User(Builder builder)&#123;\n        this.name &#x3D; builder.name;\n        this.age &#x3D; builder.age;\n        this.sex &#x3D; builder.sex;\n    &#125;\n\n    public static class Builder &#123;\n\n        &#x2F;&#x2F;必要参数\n        private final String name;\n\n        &#x2F;&#x2F;可选参数\n        private Integer age;\n        private Integer sex;\n\n        public Builder(String name)&#123;\n            this.name &#x3D; name;\n        &#125;\n\n        public Builder age(Integer age) &#123;\n            this.age &#x3D; age;\n            return this;\n        &#125;\n\n        public Builder sex(Integer sex) &#123;\n            this.sex &#x3D; sex;\n            return this;\n        &#125;\n\n        public User build() &#123;\n            return new User(this);\n        &#125;\n    &#125;\n&#125;\n\n使用：\nUser cleWm &#x3D; new User.Builder(&quot;CleWm&quot;)\n        .age(21)\n        .sex(0)\n        .build();\n\n要点：\n\n外部类的构造函数私有，且参数为静态内部类；\n静态内部类拥有外部类相同的属；\n为每一个属性，写一个方法，返回的是Builer；\n最后一个方法是build方法，用于构建一个外部类；\n\n优点：降低复杂性，优雅\n缺点：代码量提高了\n4.单例模式一个类确保只有单个对象被创建\n饿汉式：\npublic class HungrySingleton &#123;\n\n    private static HungrySingleton instance &#x3D; new HungrySingleton();\n\n    private HungrySingleton()&#123;&#125;\n\n    public static HungrySingleton getInstance()&#123;\n        return instance;\n    &#125;\n&#125;\n\n懒汉式：\n双重检查锁：\npublic class LazySingleton &#123;\n\n    private static LazySingleton instance;\n\n    private LazySingleton() &#123;&#125;\n\n    public static LazySingleton getInstance() &#123;\n        if(instance &#x3D;&#x3D; null)&#123;\n            synchronized (LazySingleton.class)&#123;\n                if (instance &#x3D;&#x3D; null)&#123;\n                    instance &#x3D; new LazySingleton();\n                &#125;\n            &#125;\n        &#125;\n        return instance;\n    &#125;\n&#125;\n\n静态内部类：\npublic class LazySingleton2 &#123;\n\n    private LazySingleton2()&#123;&#125;\n\n    &#x2F;**\n     * 静态内部类和非静态内部类都是在被调用的时候才会进行加载，和外部类没有关系，从而实现了延迟加载\n     *&#x2F;\n    private static class SingletonHolder&#123;\n        private static final LazySingleton2 instance &#x3D; new LazySingleton2();\n    &#125;\n\n    public static LazySingleton2 getInstance() &#123;\n        return SingletonHolder.instance;\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        LazySingleton instance1 &#x3D; LazySingleton.getInstance();\n        LazySingleton instance2 &#x3D; LazySingleton.getInstance();\n        System.out.println(instance1 &#x3D;&#x3D; instance2);\n\n        LazySingleton2 instance3 &#x3D; LazySingleton2.getInstance();\n        LazySingleton2 instance4 &#x3D; LazySingleton2.getInstance();\n        System.out.println(instance3 &#x3D;&#x3D; instance4);\n    &#125;\n&#125;\n\n结果\n\n5.原型模式原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。一般会配合工厂模式一起使用。\n与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。\n定义一个抽象父类，并实现Cloneable接口：\n&#x2F;**\n * Cloneable是一个标识接口，clone方法是Object提供的方法，\n * 只有实现了Cloneable接口，同时重写clone方法才不会报错\n *&#x2F;\n@Getter\n@ToString\npublic abstract class Book implements Cloneable&#123;\n\n    protected String name;\n\n    protected Integer type;\n\n    @Override\n    protected Book clone()&#123;\n        Object clone &#x3D; null;\n        try&#123;\n            clone &#x3D; super.clone();\n        &#125;catch (CloneNotSupportedException e)&#123;\n            e.printStackTrace();\n        &#125;\n        return (Book)clone;\n    &#125;\n&#125;\n\n定义具体实现类：\npublic class BookOne extends Book&#123;\n\n    BookOne() &#123;\n        name &#x3D; &quot;《第一本书》&quot;;\n        type &#x3D; 1;\n    &#125;\n&#125;\n\npublic class BookTwo extends Book&#123;\n\n    BookTwo() &#123;\n        name &#x3D; &quot;《第二本书》&quot;;\n        type &#x3D; 2;\n    &#125;\n&#125;\n\n定义一个Factory来获得克隆对象：\npublic class BookFactory &#123;\n\n    &#x2F;**\n     * 用于存储我们的原始对象，克隆对象以此为基础进行复制\n     *&#x2F;\n    private static final Map&lt;Integer,Book&gt; cache;\n\n    static &#123;\n        cache &#x3D; new HashMap&lt;&gt;();\n        cache.put(Type.TYPE_ONE,new BookOne());\n        cache.put(Type.TYPE_TWO,new BookTwo());\n    &#125;\n\n    public static class Type&#123;\n        public static final Integer TYPE_ONE &#x3D; 1;\n        public static final Integer TYPE_TWO &#x3D; 2;\n    &#125;\n\n    &#x2F;**\n     * 返回的是克隆对象\n     * @param type\n     * @return\n     *&#x2F;\n    public static Book getBookByType(Integer type) &#123;\n        return cache.get(type).clone();\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n    @org.junit.Test\n    public void test1() &#123;\n        Book book1 &#x3D; BookFactory.getBookByType(BookFactory.Type.TYPE_ONE);\n        Book book2 &#x3D; BookFactory.getBookByType(BookFactory.Type.TYPE_ONE);\n        System.out.println(book1 &#x3D;&#x3D; book2);\n        System.out.println(book1);\n        System.out.println(book2);\n    &#125;\n&#125;\n\n结果\n\n二、结构型模式6.适配器模式适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁\n比如220V的电源，使用电源适配器给手机提供12V的电压充电。\n定义一个目标接口，该接口属于一般情况\npublic interface Target &#123;\n\n    public void get();\n&#125;\n\n定义一个不兼容的，需要被适配的实现\npublic class SpecialStatus &#123;\n\n    public void specialGet() &#123;\n        System.out.println(&quot;这是特殊情况的get实现&quot;);\n    &#125;\n&#125;\n\n定义适配器，实现Target接口\npublic class Adapter implements Target &#123;\n\n    private SpecialStatus specialStatus;\n\n    public Adapter(SpecialStatus specialStatus)&#123;\n        this.specialStatus &#x3D; specialStatus;\n    &#125;\n\n    @Override\n    public void get() &#123;\n        specialStatus.specialGet();\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        SpecialStatus specialStatus &#x3D; new SpecialStatus();\n        Adapter adapter &#x3D; new Adapter(specialStatus);\n        adapter.get();\n    &#125;\n&#125;\n\n结果\n\n7.桥接模式Bridge，它的作用是将抽象部分和它的实现部分分离，从而可以让它们独立地变化。\n就好比有一个武器槽，放不同的武器进去就是不同的功能。s\n先定义抽象部分，比如武器槽\npublic abstract class WeaponSlot &#123;\n\n    protected Weapon weapon;\n\n    abstract void shoot();\n\n    public void setWeapon(Weapon weapon)&#123;\n        this.weapon &#x3D; weapon;\n    &#125;\n\n    public abstract void opreation();\n&#125;\n\n定义实现的接口\npublic interface Weapon &#123;\n\n    void shoot();\n&#125;\n\n定义抽象部分的实现\npublic class LeftSlot extends WeaponSlot&#123;\n\n    @Override\n    void shoot() &#123;\n        weapon.shoot();\n    &#125;\n\n    @Override\n    public void opreation() &#123;\n        weapon.shoot();\n    &#125;\n&#125;\n\n定义实现接口的实现\npublic class AK47 implements Weapon &#123;\n    @Override\n    public void shoot() &#123;\n        System.out.println(&quot;AK开枪了！&quot;);\n    &#125;\n&#125;\n\npublic class M4 implements Weapon &#123;\n    @Override\n    public void shoot() &#123;\n        System.out.println(&quot;m4开枪！&quot;);\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n\n        M4 m4 &#x3D; new M4();\n        AK47 ak47 &#x3D; new AK47();\n\n        LeftSlot leftSlot &#x3D; new LeftSlot();\n        leftSlot.setWeapon(m4);\n        leftSlot.opreation();\n\n        leftSlot.setWeapon(ak47);\n        leftSlot.opreation();\n    &#125;\n&#125;\n\n结果\n\n8.过滤器模式Filter ，它的作用是过滤序列中的特定元素。\n定义一个过滤器的接口\npublic interface Filter &lt;T&gt;&#123;\n\n    List&lt;T&gt; doFilter(List&lt;T&gt; lists);\n&#125;\n\n定义要过滤的实体类\n@Data\npublic class User &#123;\n\n    private String name;\n\n    private Integer age;\n\n    private Integer sex;\n&#125;\n\n定义过滤器的具体实现\n年龄过滤器：\npublic class AgeFilter implements Filter&lt;User&gt; &#123;\n\n    @Override\n    public List&lt;User&gt; doFilter(List&lt;User&gt; lists) &#123;\n        ArrayList&lt;User&gt; res &#x3D; new ArrayList&lt;&gt;();\n        for (User user : lists) &#123;\n            if(user.getAge() &gt;&#x3D; 18)&#123;\n                res.add(user);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;\n\n性别过滤器：\npublic class SexFilter implements Filter&lt;User&gt; &#123;\n    @Override\n    public List&lt;User&gt; doFilter(List&lt;User&gt; lists) &#123;\n        ArrayList&lt;User&gt; res &#x3D; new ArrayList&lt;&gt;();\n        for (User user : lists) &#123;\n            if (user.getSex() &#x3D;&#x3D; 1)&#123;\n                res.add(user);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        AgeFilter ageFilter &#x3D; new AgeFilter();\n        SexFilter sexFilter &#x3D; new SexFilter();\n        ArrayList&lt;User&gt; userArrayList &#x3D; new ArrayList&lt;&gt;();\n        for (int i &#x3D; 1; i &lt; 10; i++) &#123;\n            User user &#x3D; new User();\n            user.setAge(RandomUtil.randomInt(10,35));\n            user.setName(&quot;张&quot; + i);\n            user.setSex(RandomUtil.randomEle(new Integer[]&#123;0,1&#125;));\n            userArrayList.add(user);\n        &#125;\n        List&lt;User&gt; users1 &#x3D; ageFilter.doFilter(userArrayList);\n        System.out.println(&quot;第一次过滤后的结果：&quot; + users1);\n\n        List&lt;User&gt; users2 &#x3D; sexFilter.doFilter(users1);\n        System.out.println(&quot;第二次过滤后的结果：&quot; + users2);\n    &#125;\n&#125;\n\n结果\n\n9.组合模式Composite，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。\n例如：在可视化开发中，容器和按钮等组件之间的关系。又或者是公司、学校的组织架构等。\n以学校为例：\n定义一个员工类：\n@Data\n@ToString(exclude &#x3D; &quot;subordinates&quot;)\npublic class Employee &#123;\n\n    private String name;\n\n    private String dept;\n\n    private Integer salary;\n\n    private List&lt;Employee&gt; subordinates;\n\n    public Employee(String name, String dept, Integer salary) &#123;\n        this.name &#x3D; name;\n        this.dept &#x3D; dept;\n        this.salary &#x3D; salary;\n        this.subordinates &#x3D; new ArrayList&lt;&gt;();\n    &#125;\n\n    public void addSubordinate(Employee subordinate) &#123;\n        subordinates.add(subordinate);\n    &#125;\n\n    public void removeSubordinate(Employee subordinate) &#123;\n        subordinates.remove(subordinate);\n    &#125;\n&#125;\n\n测试：\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Employee 张昌平 &#x3D; new Employee(&quot;张昌平&quot;, &quot;校长&quot;, 30000);\n\n        Employee 张雪迎 &#x3D; new Employee(&quot;张雪迎&quot;, &quot;7班班主任&quot;, 10000);\n        Employee 刘静 &#x3D; new Employee(&quot;刘静&quot;, &quot;8班班主任&quot;, 9000);\n\n        Employee 胡伟明 &#x3D; new Employee(&quot;胡伟明&quot;, &quot;7班学生&quot;, 0);\n        Employee 李冠杰 &#x3D; new Employee(&quot;李冠杰&quot;, &quot;7班学生&quot;, 0);\n        Employee 田继睿 &#x3D; new Employee(&quot;田继睿&quot;, &quot;7班学生&quot;, 0);\n        Employee 冯毅力 &#x3D; new Employee(&quot;冯毅力&quot;, &quot;7班学生&quot;, 0);\n\n        Employee 冯跟源 &#x3D; new Employee(&quot;冯跟源&quot;, &quot;8班学生&quot;, 0);\n        Employee 施冰清 &#x3D; new Employee(&quot;施冰清&quot;, &quot;8班学生&quot;, 0);\n\n\n\n        张昌平.addSubordinate(张雪迎);\n        张昌平.addSubordinate(刘静);\n\n\n        张雪迎.addSubordinate(胡伟明);\n        张雪迎.addSubordinate(李冠杰);\n        张雪迎.addSubordinate(田继睿);\n        张雪迎.addSubordinate(冯毅力);\n\n        刘静.addSubordinate(冯跟源);\n        刘静.addSubordinate(施冰清);\n\n        &#x2F;**\n         * 二叉树如下:\n         *                      张昌平\n         *                    &#x2F;      \\\n         *                   &#x2F;        \\\n         *                张雪迎        刘静\n         *                &#x2F; | | \\      &#x2F; \\\n         *               &#x2F;  | |  \\    &#x2F;   \\\n         *             胡   李 冯 田   冯   施\n         *&#x2F;\n        System.out.println(张昌平);\n        for (Employee sub1 : 张昌平.getSubordinates())&#123;\n            System.out.println(sub1);\n            for (Employee sub2 : sub1.getSubordinates())&#123;\n                System.out.println(sub2);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n结果\n\n10.装饰器模式Decorator，允许向一个现有的对象添加新的功能，同时又不改变其结构。\n定义一个接口\npublic interface Person &#123;\n\n    void eat();\n&#125;\n\n定义一个接口的实现\npublic class CleWm implements Person &#123;\n    @Override\n    public void eat() &#123;\n        System.out.println(&quot;吃了一碗饭...&quot;);\n    &#125;\n&#125;\n\n定义一个装饰器，实现接口\npublic class Decorator implements Person &#123;\n\n    private Person person;\n\n    @Override\n    public void eat() &#123;\n        person.eat();\n        System.out.println(&quot;person又吃了一碗...&quot;);\n    &#125;\n\n    public void setPerson(Person person) &#123;\n        this.person &#x3D; person;\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        CleWm cleWm &#x3D; new CleWm();\n        Decorator decorator &#x3D; new Decorator();\n        decorator.setPerson(cleWm);\n        decorator.eat();\n    &#125;\n&#125;\n\n结果\n\n11.外观模式Facade，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。\n&#x2F;&#x2F; 外观类\npublic class Facade &#123;\n   private Subsystem1 subsystem1;\n   private Subsystem2 subsystem2;\n\n   public Facade() &#123;\n      subsystem1 &#x3D; new Subsystem1();\n      subsystem2 &#x3D; new Subsystem2();\n   &#125;\n\n   &#x2F;&#x2F; 提供一个简化的接口，用于客户端访问子系统\n   public void operation() &#123;\n      subsystem1.operation1();\n      subsystem2.operation1();\n   &#125;\n&#125;\n\n&#x2F;&#x2F; 子系统1\npublic class Subsystem1 &#123;\n   public void operation1() &#123;\n      &#x2F;&#x2F; 实现子系统1的相关操作\n   &#125;\n&#125;\n\n&#x2F;&#x2F; 子系统2\npublic class Subsystem2 &#123;\n   public void operation1() &#123;\n      &#x2F;&#x2F; 实现子系统2的相关操作\n   &#125;\n&#125;\n\n12.享元模式Flyweight，主要用于减少创建对象的数量，以减少内存占用和提高性能。\n说白了就是在工厂模式的工厂类中，缓存一个Map，每次创建对象的时候就进行一个判断，若指定对象存在，则直接从map中取出并返回，若没有，则新建，然后缓存进入Map当中。\n创建一个颜色\npublic class Color &#123;\n\n    public String colorName;\n\n    public Color(String colorName)&#123;\n        this.colorName &#x3D; colorName;\n    &#125;\n&#125;\n\n创建一个颜色工厂\npublic class ColorFactory &#123;\n\n    private Map&lt;String, Color&gt; map &#x3D; new HashMap&lt;&gt;();\n\n    public Color getColor(String colorName) &#123;\n        return Optional.ofNullable(map.get(colorName)).orElseGet(()-&gt;&#123;\n            Color color &#x3D; new Color(colorName);\n            map.put(colorName,color);\n            return color;\n        &#125;);\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        ColorFactory colorFactory &#x3D; new ColorFactory();\n        Color red1 &#x3D; colorFactory.getColor(&quot;red&quot;);\n        Color red2 &#x3D; colorFactory.getColor(&quot;red&quot;);\n        Color red3 &#x3D; colorFactory.getColor(&quot;blue&quot;);\n        System.out.println(red1 &#x3D;&#x3D; red2);\n    &#125;\n&#125;\n\n结果\n\n13.代理模式Proxy，它通过引入一个新的类来控制对另一个对象的访问。这有助于控制对原始对象的访问，并且可以在访问原始对象时执行其他附加操作。\n定义一个接口，包含被代理的方法\npublic interface Image &#123;\n\n    public void show();\n&#125;\n\n定义原始类\npublic class Realimage implements Image &#123;\n\n    private String path;\n\n    public Realimage(String path) &#123;\n        this.path &#x3D; path;\n        loadFromDisk();\n    &#125;\n\n    @Override\n    public void show() &#123;\n        System.out.println(&quot;展示&quot; + path + &quot;的图片&quot;);\n    &#125;\n\n    void loadFromDisk() &#123;\n        System.out.println(&quot;正在从磁盘中加载图片:&quot; + path);\n    &#125;\n&#125;\n\n定义代理对象\npublic class ProxyImage implements Image &#123;\n\n    private String path;\n\n    private Realimage realimage;\n\n    public ProxyImage(String path) &#123;\n        this.path &#x3D; path;\n    &#125;\n\n    @Override\n    public void show() &#123;\n        if(realimage &#x3D;&#x3D; null)&#123;\n            realimage &#x3D; new Realimage(path);\n        &#125;\n        realimage.show();\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        ProxyImage proxyImage &#x3D; new ProxyImage(&quot;C:\\\\test.jpg&quot;);\n        proxyImage.show();\n    &#125;\n&#125;\n\n结果\n\n三、行为型模式14.责任链模式Chain of Responsibility，为请求创建了一个接收者对象的链。\n通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。\n定义一个实体\n@Data\n@AllArgsConstructor\npublic class Package &#123;\n\n    private String loc;\n&#125;\n\n定义一个处理器的抽象父类\npublic abstract class PackageHandler &#123;\n\n    private PackageHandler next;\n\n    public void next(PackageHandler next)&#123;\n        this.next &#x3D; next;\n    &#125;\n\n    public void handler(Package p)&#123;\n        if(next !&#x3D; null)&#123;\n            next.handler(p);\n        &#125;else &#123;\n            System.out.println(&quot;接收到一个未知地点的包裹....&quot;);\n        &#125;\n    &#125;\n&#125;\n\n定义处理器的实现\npublic class KunmingPackageHandler extends PackageHandler&#123;\n    @Override\n    public void handler(Package p) &#123;\n        if(&quot;昆明&quot;.equals(p.getLoc()))&#123;\n            System.out.println(&quot;处理了一个昆明的包裹...[&quot; + this + &quot;]&quot;);\n            return;\n        &#125;else &#123;\n            super.handler(p);\n        &#125;\n    &#125;\n&#125;\n\npublic class TianJinPackageHandler extends PackageHandler&#123;\n\n    @Override\n    public void handler(Package p) &#123;\n        if(&quot;天津&quot;.equals(p.getLoc()))&#123;\n            System.out.println(&quot;处理了一个天津的包裹...[&quot; + this + &quot;]&quot;);\n            return;\n        &#125;else &#123;\n            super.handler(p);\n        &#125;\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        KunmingPackageHandler kunmingPackageHandler &#x3D; new KunmingPackageHandler();\n        TianJinPackageHandler tianJinPackageHandler &#x3D; new TianJinPackageHandler();\n\n        &#x2F;&#x2F; |kunmingPackageHandler| ------ |tianJinPackageHandler| ------ null\n        kunmingPackageHandler.next(tianJinPackageHandler);\n\n\n        Package package1 &#x3D; new Package(&quot;天津&quot;);\n        Package package2 &#x3D; new Package(&quot;昆明&quot;);\n        Package package3 &#x3D; new Package(&quot;四川&quot;);\n\n        List&lt;Package&gt; packageList &#x3D; ListUtil.of(package1, package2, package3);\n        for (Package aPackage : packageList) &#123;\n            kunmingPackageHandler.handler(aPackage);\n        &#125;\n    &#125;\n&#125;\n\n结果\n\n15.命令模式Command，命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。\n\n简单理解就是，封装一条命令，为该命令设置一个接收者，然后将该命令set进一个调用者对象（Invoker）中，最后调用Invoker的runCommand方法来执行命令。\n创建命令接口\npublic interface Command &#123;\n\n    void run();\n&#125;\n\n创建接收者(可以理解为被隐藏的具体功能实现的部分)\npublic class Receiver &#123;\n\n    private Integer stock &#x3D; 100;\n\n    &#x2F;**\n     * 接收者的增加库存接口，命令调用者无须关心这些接口。\n     *&#x2F;\n    public void increase() &#123;\n        stock++;\n        System.out.println(&quot;[库存剩余]:&quot; + stock);\n    &#125;\n\n    &#x2F;**\n     * 接收者的减少库存接口，命令调用者无须关心这些接口。\n     *&#x2F;\n    public void decrease() &#123;\n        stock--;\n        System.out.println(&quot;[库存剩余]:&quot; + stock);\n    &#125;\n&#125;\n\n创建命令实现\npublic class AddStockCommand implements Command &#123;\n\n    private Receiver receiver;\n\n    public AddStockCommand(Receiver receiver) &#123;\n        this.receiver &#x3D; receiver;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        receiver.increase();\n        System.out.println(&quot;添加了1个库存...&quot;);\n    &#125;\n&#125;\n\npublic class SubStockCommand implements Command &#123;\n\n    private Receiver receiver;\n\n    public SubStockCommand(Receiver receiver)&#123;\n        this.receiver &#x3D; receiver;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        receiver.decrease();\n        System.out.println(&quot;减少了1个库存...&quot;);\n    &#125;\n&#125;\n\n创建调用者\npublic class Invoker&#123;\n\n    &#x2F;&#x2F; 这里也可用一个List来存储命令，在调用时使用for循环命令依次执行。\n    private Command command;\n\n    public Invoker(Command command)&#123;\n        this.command &#x3D; command;\n    &#125;\n\n    public void invokeCommand() &#123;\n        if(command !&#x3D; null)&#123;\n            command.run();\n            System.out.println(&quot;命令执行完毕...&quot;);\n        &#125;else &#123;\n            System.out.println(&quot;未设置命令！&quot;);\n        &#125;\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        &#x2F;&#x2F; 创建一个接收者\n        Receiver receiver &#x3D; new Receiver();\n\n        &#x2F;&#x2F; 库存增加命令\n        AddStockCommand addStockCommand &#x3D; new AddStockCommand(receiver);\n        &#x2F;&#x2F; 库存减少命令\n        SubStockCommand subStockCommand &#x3D; new SubStockCommand(receiver);\n\n        &#x2F;&#x2F; 创建一个调用者\n        Invoker invoker1 &#x3D; new Invoker(addStockCommand);\n        &#x2F;&#x2F; 让调用者执行命令。\n        invoker1.invokeCommand();\n\n        &#x2F;&#x2F; 创建一个调用者\n        Invoker invoker2 &#x3D; new Invoker(subStockCommand);\n        &#x2F;&#x2F; 让调用者执行命令。\n        invoker2.invokeCommand();\n    &#125;\n&#125;\n\n结果\n\n16.解释器模式Interpreter，它允许你定义一个语言的文法，并且基于该文法解释语言中的句子。\n定义表达式接口\npublic interface Expression &#123;\n\n    boolean interpret(String content);\n&#125;\n\n定义表达式\n关键词表达式，若内容中包含指定data内容，则为true\npublic class KeyWordExpression implements Expression &#123;\n\n    private String data;\n\n    public KeyWordExpression(String data)&#123;\n        this.data &#x3D; data;\n    &#125;\n\n\n    @Override\n    public boolean interpret(String content) &#123;\n        if (data !&#x3D; null)&#123;\n            return content.contains(data);\n        &#125;\n        else &#123;\n            throw new RuntimeException(&quot;未设置表达式data内容&quot;);\n        &#125;\n    &#125;\n&#125;\n\n或表达式\npublic class OrExpression implements Expression &#123;\n\n    private Expression exp1;\n    private Expression exp2;\n\n    public OrExpression(Expression exp1,Expression exp2) &#123;\n        this.exp1 &#x3D; exp1;\n        this.exp2 &#x3D; exp2;\n    &#125;\n\n    @Override\n    public boolean interpret(String content) &#123;\n        return exp1.interpret(content) || exp2.interpret(content);\n    &#125;\n&#125;\n\n与表达式\npublic class AndExpression implements Expression &#123;\n\n    private Expression exp1;\n    private Expression exp2;\n\n    public AndExpression(Expression exp1, Expression exp2) &#123;\n        this.exp1 &#x3D; exp1;\n        this.exp2 &#x3D; exp2;\n    &#125;\n\n    @Override\n    public boolean interpret(String content) &#123;\n        return exp1.interpret(content) &amp;&amp; exp2.interpret(content);\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        KeyWordExpression exp1 &#x3D; new KeyWordExpression(&quot;CleWm&quot;);\n        boolean res1 &#x3D; exp1.interpret(&quot;I am CleWm&quot;);\n\n        KeyWordExpression exp2 &#x3D; new KeyWordExpression(&quot;CleWm&quot;);\n        KeyWordExpression exp3 &#x3D; new KeyWordExpression(&quot;clewm&quot;);\n\n        OrExpression exp4 &#x3D; new OrExpression(exp2, exp3);\n        boolean res2 &#x3D; exp4.interpret(&quot;CleWm&quot;);\n        AndExpression exp5 &#x3D; new AndExpression(exp2, exp3);\n        boolean res3 &#x3D; exp5.interpret(&quot;CleWm&quot;);\n        System.out.println(res1);\n        System.out.println(res2);\n        System.out.println(res3);\n    &#125;\n&#125;\n\n结果\n\n17.迭代器模式Iterator，这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。\n创建迭代器接口\npublic interface Container &#123;\n\n    MyIterator getIterator();\n&#125;\n\n创建容器接口，该接口用于使得容器能够返回一个迭代器\npublic interface Container &#123;\n\n    MyIterator getIterator();\n&#125;\n\n创建容器的实现\npublic class PersonRepository implements Container &#123;\n\n    private static final List&lt;String&gt; personList;\n    private int index;\n\n    static &#123;\n        personList &#x3D; ListUtil.of(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;赵六&quot;);\n    &#125;\n\n    @Override\n    public MyIterator getIterator() &#123;\n        index &#x3D; 0;\n        return new PersonIterator();\n    &#125;\n\n    private class PersonIterator implements MyIterator&lt;String&gt;&#123;\n\n        @Override\n        public boolean hasNext() &#123;\n            return personList.size() &gt; 0 &amp;&amp; index &lt; personList.size();\n        &#125;\n\n        @Override\n        public String next() &#123;\n            return personList.get(index++);\n        &#125;\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1()&#123;\n        PersonRepository personRepository &#x3D; new PersonRepository();\n        MyIterator iterator &#x3D; personRepository.getIterator();\n        while (iterator.hasNext())&#123;\n            System.out.println(iterator.next());\n        &#125;\n    &#125;\n&#125;\n\n结果\n\n18.中介者模式Mediator，这种模式提供了一个中介类，该类通常处理不同类之间的通信。\n聊天室为例\n定义用户\n@Data\npublic class User &#123;\n\n    private String name;\n    private ChatRoom chatRoom;\n\n    public User(String name)&#123;\n        this.name &#x3D; name;\n    &#125;\n\n    public void sendMessage(String content) &#123;\n        System.out.println(name + &quot; 发送一条消息:&quot; + content);\n        Message message &#x3D; new Message(name, content);\n        if(chatRoom &#x3D;&#x3D; null)&#123;\n            throw new RuntimeException(&quot;未加入任何聊天室&quot;);\n        &#125;\n        chatRoom.send(message);\n    &#125;\n\n    public void receiveMessage(Message message) &#123;\n        System.out.println(name + &quot; 收到一条消息: &quot; + message);\n    &#125;\n&#125;\n\n定义消息\n@Data\n@AllArgsConstructor\npublic class Message &#123;\n\n    private String from;\n    private String content;\n&#125;\n\n定义聊天室\npublic class ChatRoom &#123;\n\n    private List&lt;User&gt; userList &#x3D; new ArrayList&lt;&gt;();\n\n    public void send(Message message)&#123;\n        for (User user : userList)&#123;\n            if(message.getFrom().equals(user.getName())) continue;\n            user.receiveMessage(message);\n        &#125;\n    &#125;\n\n    public void register(User user) &#123;\n        user.setChatRoom(this);\n        userList.add(user);\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        ChatRoom chatRoom &#x3D; new ChatRoom();\n\n        User 张三 &#x3D; new User(&quot;张三&quot;);\n        User 李四 &#x3D; new User(&quot;李四&quot;);\n        User 王五 &#x3D; new User(&quot;王五&quot;);\n        chatRoom.register(张三);\n        chatRoom.register(李四);\n        chatRoom.register(王五);\n\n        张三.sendMessage(&quot;你好，我是张三&quot;);\n    &#125;\n&#125;\n\n结果\n\n19.备忘录模式Memento，保存（备份）一个对象的某个状态，以便在适当的时候恢复对象。\nMemento ： 备忘录对象,负责 保存好记录，即Originator内部 状态\n@Data\npublic class Memento &#123;\n\n    private String state;\n\n    public Memento(String state)&#123;\n        this.state &#x3D; state;\n    &#125;\n&#125;\n\noriginator : 对象(需要保存 状态的对象)\n@Data\npublic class Originator &#123;\n\n    private String state;\n\n    public Memento saveStateToMemento() &#123;\n        return new Memento(state);\n    &#125;\n\n    public void restoreStateFromMemento(Memento memento) &#123;\n        this.state &#x3D; memento.getState();\n    &#125;\n&#125;\n\nCaretaker: 备忘录管理者,负责保存多个备忘录对象， 使用集合管理，提高效率\npublic class MementoManager &#123;\n\n    private static List&lt;Memento&gt; mementoList;\n\n    static &#123;\n        mementoList &#x3D; new ArrayList&lt;&gt;();\n    &#125;\n\n    public static boolean add(Memento memento)&#123;\n        return mementoList.add(memento);\n    &#125;\n\n    public static Memento remove(int index) &#123;\n        return mementoList.remove(index);\n    &#125;\n\n    public static Memento get(int index)&#123;\n        return mementoList.get(index);\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Originator originator &#x3D; new Originator();\n        originator.setState(&quot;初始状态&quot;);\n        boolean add &#x3D; MementoManager.add(originator.saveStateToMemento());\n        if(!add) throw new RuntimeException(&quot;保存状态失败！&quot;);\n        originator.setState(&quot;第一状态&quot;);\n        System.out.println(&quot;origin的状态为:&quot; + originator.getState());\n        originator.restoreStateFromMemento(MementoManager.get(0));\n        System.out.println(&quot;origin的状态为:&quot; + originator.getState());\n    &#125;\n&#125;\n\n结果\n\n20.观察者模式Observer，当一个对象被修改时，则会自动通知依赖它的对象。\n创建一个被订阅的（Up主）\npublic class Up &#123;\n\n    private String latestVideo;\n\n    private List&lt;Follower&gt; followers &#x3D; new ArrayList&lt;&gt;();\n\n    public void submitVideo(String video) &#123;\n        this.latestVideo &#x3D; video;\n        notifyAllFollowers();\n    &#125;\n\n    public void addFollower(Follower follower) &#123;\n        followers.add(follower);\n    &#125;\n\n    public void notifyAllFollowers() &#123;\n        for (Follower follower : followers) &#123;\n            follower.update(latestVideo);\n        &#125;\n    &#125;\n&#125;\n\n创建一个订阅者（粉丝）\npublic class Follower&#123;\n\n    private String name;\n    private String video;\n    private Up up;\n\n    public Follower(String name,Up up) &#123;\n        this.name &#x3D; name;\n        this.up &#x3D; up;\n        this.up.addFollower(this);\n    &#125;\n\n    public void update(String video) &#123;\n        this.video &#x3D; video;\n        System.out.println(name + &quot; 收到up主 &quot; + up + &quot; 的最新视频 &quot; + video);\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Up up &#x3D; new Up();\n        Follower 张三 &#x3D; new Follower(&quot;张三&quot;, up);\n        Follower 李四 &#x3D; new Follower(&quot;李四&quot;, up);\n\n        up.submitVideo(&quot;第1个视频&quot;);\n        System.out.println(&quot;-------------&quot;);\n        up.submitVideo(&quot;第2个视频&quot;);\n    &#125;\n&#125;\n\n结果\n\n21.状态模式State，类的行为是基于它的状态改变的。\n定义状态接口\npublic interface State &#123;\n\n    void doAction(Context context);\n&#125;\n\n定义一个随着状态改变而做出不同行为的Context上下文\n@Data\npublic class Context &#123;\n\n    private State state;\n\n&#125;\n\n定义状态的实现\npublic class StartState implements State &#123;\n\n    @Override\n    public void doAction(Context context) &#123;\n        System.out.println(&quot;当前是开始状态...&quot;);\n        context.setState(this);\n    &#125;\n&#125;\n\npublic class EndState implements State &#123;\n    @Override\n    public void doAction(Context context) &#123;\n        System.out.println(&quot;当前是结束状态...&quot;);\n        context.setState(this);\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Context context &#x3D; new Context();\n\n        StartState startState &#x3D; new StartState();\n        startState.doAction(context);\n\n        EndState endState &#x3D; new EndState();\n        endState.doAction(context);\n    &#125;\n&#125;\n\n结果\n\n22.空对象模式Null Object，一个空对象取代 NULL 对象。\n定义实体类抽象父类\n@Data\npublic abstract class AbstractUser &#123;\n\n    protected String name;\n\n    public abstract boolean isNull();\n&#125;\n\n定义正常的存在的用户对象\npublic class User extends AbstractUser&#123;\n    public User(String name)&#123;\n        this.name &#x3D; name;\n    &#125;\n\n    @Override\n    public boolean isNull() &#123;\n        return false;\n    &#125;\n&#125;\n\n空对象\npublic class EmptyUser extends AbstractUser&#123;\n\n    public EmptyUser() &#123;\n        this.name &#x3D; &quot;空用户对象...&quot;;\n    &#125;\n\n    @Override\n    public boolean isNull() &#123;\n        return true;\n    &#125;\n&#125;\n\n创建一个测试用的工厂\npublic class UserFactory &#123;\n\n    private static List&lt;String&gt; nameList;\n\n    static &#123;\n        nameList &#x3D; ListUtil.of(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;);\n    &#125;\n\n    public static AbstractUser getUser(String name) &#123;\n        for (String n : nameList) &#123;\n            if(n.equalsIgnoreCase(name))&#123;\n                return new User(name);\n            &#125;\n        &#125;\n        return new EmptyUser();\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        AbstractUser 张三 &#x3D; UserFactory.getUser(&quot;张三&quot;);\n        AbstractUser 赵六 &#x3D; UserFactory.getUser(&quot;赵六&quot;);\n\n        System.out.println(张三);\n        System.out.println(赵六);\n    &#125;\n&#125;\n\n结果\n\n23.策略模式Strategy，一个类的行为或其算法可以在运行时更改。\n定义策略的接口\npublic interface Strategy &#123;\n\n    public int doStrategy(int a,int b);\n&#125;\n\n定义策略实现\npublic class AddStrategy implements Strategy &#123;\n\n    @Override\n    public int doStrategy(int a, int b) &#123;\n        return a + b;\n    &#125;\n&#125;\n\npublic class SubStrategy implements Strategy &#123;\n    @Override\n    public int doStrategy(int a, int b) &#123;\n        return a - b;\n    &#125;\n&#125;\n\n定义一个可更改策略的上下文\n@Data\npublic class Context &#123;\n\n    private Strategy strategy;\n\n    public int executeStrategy(int a,int b)&#123;\n        if(strategy !&#x3D; null)&#123;\n            return strategy.doStrategy(a,b);\n        &#125;else &#123;\n            throw new RuntimeException(&quot;尚未设置策略！&quot;);\n        &#125;\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Context context &#x3D; new Context();\n        AddStrategy addStrategy &#x3D; new AddStrategy();\n        SubStrategy subStrategy &#x3D; new SubStrategy();\n\n        context.setStrategy(addStrategy);\n        int i1 &#x3D; context.executeStrategy(1, 2);\n        System.out.println(i1);\n\n        context.setStrategy(subStrategy);\n        int i2 &#x3D; context.executeStrategy(5, 2);\n        System.out.println(i2);\n    &#125;\n&#125;\n\n结果\n两个3\n24.模板模式Template，在抽象类中提前定义了某个操作的一系列流程的模板，用户只需要实现具体细节即可。\n定义抽象模板父类\npublic abstract class MyGame &#123;\n\n    protected String name;\n\n    abstract void downloadGame();\n    abstract void installGame();\n    abstract void openGame();\n\n    public void playGame() &#123;\n        downloadGame();\n        installGame();\n        openGame();\n        System.out.println(&quot;开始游戏:[&quot; + name + &quot;]&quot;);\n    &#125;\n&#125;\n\n创建抽象父类的实现\npublic class LOL extends MyGame&#123;\n\n    public LOL()&#123;\n        this.name &#x3D; &quot;LOL&quot;;\n    &#125;\n\n    @Override\n    void downloadGame() &#123;\n        System.out.println(&quot;正在下载游戏:&quot; + name);\n    &#125;\n\n    @Override\n    void installGame() &#123;\n        System.out.println(&quot;正在安装游戏:&quot; + name);\n    &#125;\n\n    @Override\n    void openGame() &#123;\n        System.out.println(&quot;正在打开游戏:&quot; + name);\n    &#125;\n&#125;\n\npublic class CSGO extends MyGame&#123;\n\n    public CSGO() &#123;\n        this.name &#x3D; &quot;CSGO&quot;;\n    &#125;\n\n    @Override\n    void downloadGame() &#123;\n        System.out.println(&quot;正在下载游戏:&quot; + name);\n    &#125;\n\n    @Override\n    void installGame() &#123;\n        System.out.println(&quot;正在安装游戏:&quot; + name);\n    &#125;\n\n    @Override\n    void openGame() &#123;\n        System.out.println(&quot;正在打开游戏:&quot; + name);\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        LOL lol &#x3D; new LOL();\n        CSGO csgo &#x3D; new CSGO();\n\n        lol.playGame();\n        csgo.playGame();\n    &#125;\n&#125;\n\n结果\n\n25.访问者模式Visitor，封装一些作用于某些数据结构中的各元素的操作，它可以在不改变数据结构的前提下赋予这些元素新的操作。\n定义被访问者的统一接口\npublic interface Person&#123;\n\n    public void accept(Visitor visitor);\n&#125;\n\n定义被访问者实例\n@Data\n@AllArgsConstructor\npublic class Student implements Person &#123;\n\n    private String name;\n    private Integer rank;\n\n    @Override\n    public void accept(Visitor visitor) &#123;\n        visitor.visit(this);\n    &#125;\n&#125;\n\n@Data\n@AllArgsConstructor\npublic class Teacher implements Person &#123;\n\n    private String name;\n    private Integer salary;\n\n    @Override\n    public void accept(Visitor visitor) &#123;\n        visitor.visit(this);\n    &#125;\n&#125;\n\n定义访问者接口\npublic interface Visitor &#123;\n\n    public void visit(Student student);\n\n    public void visit(Teacher teacher);\n&#125;\n\n定义访问者实例\npublic class Headmaster implements Visitor &#123;\n    @Override\n    public void visit(Student student) &#123;\n        System.out.println(&quot;访问学生:&quot; + student.getName() + &quot;,排名为:&quot; + student.getRank());\n    &#125;\n\n    @Override\n    public void visit(Teacher teacher) &#123;\n        System.out.println(&quot;访问老师:&quot; + teacher.getName() + &quot;,月薪为:&quot; + teacher.getSalary());\n    &#125;\n&#125;\n\n测试\npublic class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Student student &#x3D; new Student(&quot;张三&quot;,21);\n        Teacher teacher &#x3D; new Teacher(&quot;张雪迎&quot;,8000);\n        Headmaster headmaster &#x3D; new Headmaster();\n\n        student.accept(headmaster);\n        teacher.accept(headmaster);\n    &#125;\n&#125;\n\n结果\n\n","slug":"Java/设计模式","date":"2022-12-17T02:49:17.450Z","categories_index":"技术,设计模式,开发常用","tags_index":"Java,设计模式","author_index":"CleWm"},{"id":"2ee2f111cfbae00cef07edd04fd1c972","title":"分布式Session","content":"\n分布式Session\n\nSession本质：session技术就是一种基于后端有别于数据库的临时存储数据的技术\n存活时间：可以通过如下来设置一次Session的存活时间，在这个时间内若再次发送请求，则Session的存活时间将会刷新，若超过时间无请求发送，再次发送的时候会再次创建一次新的Session会话。\nHttpSession session &#x3D; request.getSession();\nsession.setMaxInactiveInterval(2); &#x2F;&#x2F;单位是秒\n\nsession.getId(); &#x2F;&#x2F;查看session的唯一标识\n\n实现添加redis官方的实现依赖即可，可以在配置类上添加如下注解，配置相关参数\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.session&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-session-data-redis&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.7.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n可以在配置类上添加如下注解，配置相关参数\n@EnableRedisHttpSession(maxInactiveIntervalInSeconds &#x3D; 3600 #Session的存活时间,redisNamespace &#x3D; &quot;session_info存储在redis中的命名空间&quot;,flushMode &#x3D; FlushMode.IMMEDIATE #刷新策略,saveMode &#x3D; SaveMode.ON_SET_ATTRIBUTE #刷新策略)\n\n刷新策略\nON_SAVE: 只有当SessionRepository.save(Session)方法被调用时,才会将session中的数据同步到redis中. 在web 应用中, 当请求完成响应后, 才开始同步. 也就是说在执行response之前session数据都是缓存在本地的.\nIMMEDIATE: 实时同步session 数据到redis. 当执行SessionRepository.createSession()时, 会将session数据同步到redis中;当对session的attribute进行set/remove 等操作时, 也会同步session中的数据到redis中.\n\n保存策略保存Session属性更改的时机，是调用Set属性方法时保存还是Get属性方法调用的时候保存，还是总是保存，一般默认即可。\n","slug":"Java/分布式Session","date":"2022-11-03T23:45:40.713Z","categories_index":"技术,分布式","tags_index":"Java,分布式","author_index":"CleWm"},{"id":"a790fe72b285743baec96ab6632ed42e","title":"可复用代码","content":"记录了一些可复用的代码，避免重复编写浪费精力。\n\n\n\n\n\n可复用代码结果类：package com.clewm.lcss.res;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class R implements Serializable&#123;\n\n    public String info;\n\n    public Object data;\n\n    public Integer code;\n\n    public Boolean flag;\n\n\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n    &#x2F;&#x2F; TODO 成功\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n    public static R ok()&#123;\n        return new R(ResCode.SUCCESS.getMsg(),null,ResCode.SUCCESS.getCode(),true);\n    &#125;\n\n    public static R ok(String info)&#123;\n        return new R(info,null,ResCode.SUCCESS.getCode(),true);\n    &#125;\n\n    public static R ok(Object data)&#123;\n        return new R(ResCode.SUCCESS.getMsg(),data,ResCode.SUCCESS.getCode(),true);\n    &#125;\n\n    public static R ok(String info,Object data)&#123;\n        return new R(info,data,ResCode.SUCCESS.getCode(),true);\n    &#125;\n\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n    &#x2F;&#x2F; TODO 失败\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n\n    public static R fail()&#123;\n        return new R(ResCode.FAIL.getMsg(),null,ResCode.FAIL.getCode(),false);\n    &#125;\n\n    public static R fail(String info)&#123;\n        return new R(info,null,ResCode.FAIL.getCode(),false);\n    &#125;\n\n    public static R fail(Object data)&#123;\n        return new R(ResCode.FAIL.getMsg(),data,ResCode.FAIL.getCode(),false);\n    &#125;\n\n    public static R fail(ResCode code) &#123;\n        return new R(code.getMsg(),null,code.getCode(),false);\n    &#125;\n\n    public static R fail(String info,Object data)&#123;\n        return new R(info,data,ResCode.FAIL.getCode(),false);\n    &#125;\n\n    public static R fail(Object data,ResCode code) &#123;\n        return new R(code.getMsg(),data,code.getCode(),false);\n    &#125;\n\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n    &#x2F;&#x2F; TODO 异常\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n\n    public static R error() &#123;\n        return new R(ResCode.ERROR.getMsg(),null,ResCode.ERROR.getCode(),false);\n    &#125;\n\n    public static R error(String info) &#123;\n        return new R(info,null,ResCode.ERROR.getCode(),false);\n    &#125;\n\n    public static R error(ResCode code) &#123;\n        return new R(code.getMsg(),null,code.getCode(),false);\n    &#125;\n\n    public static R error(Object data,ResCode code) &#123;\n        return new R(code.getMsg(),data,code.getCode(),false);\n    &#125;\n&#125;\n\n\n状态码：package com.clewm.lcss.res;\n\n\npublic enum ResCode &#123;\n    &#x2F;&#x2F;基础类型\n    SUCCESS(200,&quot;成功！&quot;),\n    FAIL(500,&quot;失败！&quot;),\n    ERROR(400,&quot;出现异常！&quot;),\n\n    &#x2F;&#x2F;自定义类型\n    NOT_LOGIN(435,&quot;用户未登录！&quot;);\n\n    private Integer code;\n    private String msg;\n\n    ResCode(Integer code,String msg)&#123;\n        this.code &#x3D; code;\n        this.msg &#x3D; msg;\n    &#125;\n\n    public Integer getCode() &#123;\n        return code;\n    &#125;\n\n    public String getMsg() &#123;\n        return msg;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return code + &quot;-&quot; + msg;\n    &#125;\n&#125;\n\n控制层的基本增删改查代码：@Resource\nprivate DetailService detailService;\n\n@GetMapping(&quot;&#x2F;test&quot;)\npublic R test() &#123;\n    return R.error(ResCode.NOT_LOGIN);\n&#125;\n\n@GetMapping(&quot;&#x2F;&#123;detailId&#125;&quot;)\n@Cacheable(value &#x3D; &quot;detailInfo&quot;,key &#x3D; &quot;#detailId&quot;)\npublic R getDetailInfo(@PathVariable String detailId) &#123;\n    Detail detail &#x3D; detailService.getById(detailId);\n    DetailVO detailVO &#x3D; DetailConvert.INSTANCE.po2vo(detail);\n    return R.ok(detailVO);\n&#125;\n\n@GetMapping(&quot;&#x2F;del&#x2F;&#123;detailId&#125;&quot;)\n@CacheEvict(value &#x3D; &quot;detailInfo&quot;,key &#x3D; &quot;#detailId&quot;)\npublic R delDetail(@PathVariable String detailId) &#123;\n    boolean res &#x3D; detailService.removeById(detailId);\n    return res ? R.ok(&quot;删除成功！&quot;) : R.fail(&quot;删除失败！&quot;);\n&#125;\n\n@PostMapping(&quot;&#x2F;update&#x2F;&quot;)\n@CachePut(value &#x3D; &quot;detailInfo&quot;,key &#x3D; &quot;#detailDTO.getId()&quot;)\npublic R updateDetail(@RequestBody @Validated DetailDTO detailDTO) &#123;\n    Detail detail &#x3D; DetailConvert.INSTANCE.dto2po(detailDTO);\n    boolean res &#x3D; detailService.update(detail, null);\n    return res ? R.ok(&quot;更新成功！&quot;,detail) : R.fail(&quot;更新失败！&quot;);\n&#125;\n\n@PostMapping\npublic R add(@RequestBody @Validated DetailDTO detailDTO) &#123;\n    Detail detail &#x3D; detailService.add(detailDTO);\n    log.info(detail.toString());\n    DetailVO detailVO &#x3D; DetailConvert.INSTANCE.po2vo(detail);\n    return ObjectUtils.isEmpty(detailVO.getId()) ? R.fail() : R.ok(detailVO);\n&#125;\n\n只需把detail换成业务实体名即可\n业务层的基本增删改查代码：\n@Autowired\nprivate DetailMapper detailMapper;\n\n@Override\npublic Detail add(DetailDTO detailDTO) &#123;\n    return Optional.ofNullable(detailDTO).map(d -&gt; &#123;\n        Detail detail &#x3D; DetailConvert.INSTANCE.dto2po(d);\n        detailMapper.insert(detail);\n        return detail;\n    &#125;).orElse(null);\n&#125;\n\n转换类：import com.clewm.lcss.dto.DetailDTO;\nimport com.clewm.lcss.pojo.Detail;\nimport com.clewm.lcss.vo.DetailVO;\nimport org.mapstruct.Mapper;\nimport org.mapstruct.factory.Mappers;\n\n@Mapper\npublic interface DetailConvert&#123;\n\n    DetailConvert INSTANCE &#x3D; Mappers.getMapper(DetailConvert.class);\n\n    Detail dto2po(DetailDTO detailDTO);\n\n    DetailVO po2vo(Detail detail);\n&#125;\n\nMyBatis分页插件：&#x2F;**\n * @author clewm\n *&#x2F;\n@Configuration\npublic class MyBatisPlusPaginationInnerConfig &#123;\n\n    &#x2F;**\n     * 分页插件\n     *&#x2F;\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;\n        MybatisPlusInterceptor interceptor &#x3D; new MybatisPlusInterceptor();\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));\n        return interceptor;\n    &#125;\n\n&#125;\n\n\n\nDruid数据源配置：spring:\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;lcss_person?characterEncoding&#x3D;UTF-8&amp;zeroDateTimeBehavior&#x3D;convertToNull&amp;useSSL&#x3D;false&amp;useJDBCCompliantTimezoneShift&#x3D;true&amp;useLegacyDatetimeCode&#x3D;false&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai\n    username: root\n    password: 123567\n    druid:\n      min-idle: 10\n      max-active: 100\n      test-while-idle: true\n      test-on-borrow: true\n      time-between-eviction-runs-millis: 3000000 #设置创建的连接等待时长，单位毫秒\n\nMinio配置类：@Configuration\npublic class MinioConfig &#123;\n\n    @Resource\n    private MinioProperties minioProperties;\n\n    @Bean\n    public MinioClient minioClient() &#123;\n        return MinioClient.builder()\n                .endpoint(minioProperties.getIp(),minioProperties.getPort(),false)\n                .credentials(minioProperties.getAccessKey(), minioProperties.getSecretKey())\n                .build();\n    &#125;\n&#125;\n\n\n@Data\n@Component\n@ConfigurationProperties(prefix &#x3D; &quot;minio&quot;)\npublic class MinioProperties &#123;\n\n    &#x2F;**\n     * minio服务器地址\n     *&#x2F;\n    private String ip;\n\n    &#x2F;**\n     * minio端口\n     *&#x2F;\n    private Integer port;\n\n    &#x2F;**\n     * 用户名\n     *&#x2F;\n    private String accessKey;\n\n    &#x2F;**\n     * 密码\n     *&#x2F;\n    private String secretKey;\n&#125;\n","slug":"Java/可复用代码","date":"2022-11-02T01:20:37.454Z","categories_index":"技术,开发常用","tags_index":"Java","author_index":"CleWm"},{"id":"61002d5c25b8c7e1297b605504df9169","title":"SkyWalking","content":"SkyWalking下载地址：http://skywalking.apache.org/downloads/概念：可实现基于Open Tracing规范的分布式链路追踪功能的APM应用性能管理平台\n\nUI界面的jar包和配置文件（可修改端  口）\n修改skywalking服务端数据存储方式：\n默认是使用H2进行存储，如果服务端重启的话，数据就会丢失，推荐使用es存储，可以在如下位置处进行修改：\n\nselector处修改为elasticsearch，然后修改es的一些默认配置即可\n\n端口说明\n服务接入比如我需要在window系统上启动一个需要被监控的服务，就需要在这个系统上提前准备一个和skywalking服务端对应版本的skywalking-agent.jar\n下载地址：https://archive.apache.org/dist/skywalking/，解压后在根目录即可找到，170多MB的那个\n\n如果是通过idea启动的话，在启动配置的VM参数处填入以下：\n\n-javaagent:C:\\_Code\\lcss\\lcss-gateway\\agent\\skywalking-agent.jar #jar包具体位置\n-Dskywalking.agent.service_name&#x3D;lcss-gateway #服务名，最好与nacos中的名字对应\n-Dskywalking.collector.backend_service&#x3D;192.168.1.104:11800 #skywalking服务端暴露的收集数据的端口\n\n\n如果是在docker中的话：\n\n同样需要提前准备agent（包含有jar包）\n原本项目的启动方式：\njava -jar spring-boot-demo-0.0.1-SNAPSHOT.jar\n\n现在变为：\njava -javaagent:&#x2F;opt&#x2F;apache-skywalking-apm-bin&#x2F;agent&#x2F;skywalking-agent.jar -Dskywalking.agent.service_name&#x3D;服务名 -Dskywalking.collector.backend_service&#x3D;127.0.0.1:11800 -jar &#x2F;opt&#x2F;spring-boot-demo-0.0.1-SNAPSHOT.jar\n\n\n\n操作如下：与Src目录平级下建一个agent文件夹，放agent文件夹（从如下路径拷贝来的）\n\n\n文件：\nFROM openjdk:8-jdk-alpine\n\nRUN mkdir -p &#x2F;lcss-gateway\n\nWORKDIR &#x2F;lcss-gateway\n\nARG JAR_FILE&#x3D;target&#x2F;lcss-gateway.jar\n\nCOPY $&#123;JAR_FILE&#125; app.jar\nCOPY agent &#x2F;lcss-gateway&#x2F;agent &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;&gt;关键,把agent的jar包复制到容器中\n\nEXPOSE 20010\n\nENTRYPOINT [&quot;java&quot;, &quot;-javaagent:&#x2F;lcss-gateway&#x2F;agent&#x2F;skywalking-agent.jar&quot;, &quot;-Dskywalking.agent.service_name&#x3D;lcss-gateway&quot;,&quot;-Dskywalking.collector.backend_service&#x3D;192.168.1.104:11800&quot;, &quot;-jar&quot;,&quot;app.jar&quot;]\n\nps:docker部署启动的时候提示config没找到的踩坑项目的agent不能只拷贝一个jar包，需要把整个agent文件夹都拷贝进去，因为里面还有配置文件！！\n日志收集（版本8.4及以上！）ps：SpringBoot默认的日志框架是logback，这里介绍的也是基于logback的日志收集方法，可以配合Lombok的@Slf4j正常使用****\n依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.skywalking&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;apm-toolkit-trace&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;8.5.0&lt;&#x2F;version&gt; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;该版本最好和skyWalking的版本对应\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.skywalking&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;apm-toolkit-logback-1.x&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;8.5.0&lt;&#x2F;version&gt; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;该版本最好和skyWalking的版本对应\n&lt;&#x2F;dependency&gt;\n\n\n\n在resource下创建logback-spring.xml文件\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;configuration scan&#x3D;&quot;true&quot; scanPeriod&#x3D;&quot;10 seconds&quot;&gt;\n\n    &lt;appender name&#x3D;&quot;stdout&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;用来格式化日志输出的\n        &lt;encoder class&#x3D;&quot;ch.qos.logback.core.encoder.LayoutWrappingEncoder&quot;&gt;\n            &lt;layout class&#x3D;&quot;org.apache.skywalking.apm.toolkit.log.logback.v1.x.TraceIdPatternLogbackLayout&quot;&gt;\n                &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%tid] [%thread] %-5level %logger&#123;36&#125; -%msg%n&lt;&#x2F;Pattern&gt;\n            &lt;&#x2F;layout&gt;\n        &lt;&#x2F;encoder&gt;\n    &lt;&#x2F;appender&gt;\n\n    &lt;appender name&#x3D;&quot;grpc&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;用来上报日志的class&#x3D;&quot;org.apache.skywalking.apm.toolkit.log.logback.v1.x.log.GRPCLogClientAppender&quot;&gt;\n        &lt;encoder class&#x3D;&quot;ch.qos.logback.core.encoder.LayoutWrappingEncoder&quot;&gt;\n            &lt;layout class&#x3D;&quot;org.apache.skywalking.apm.toolkit.log.logback.v1.x.mdc.TraceIdMDCPatternLogbackLayout&quot;&gt;\n                &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;tid&#125;] [%thread] %-5level %logger&#123;36&#125; -%msg%n&lt;&#x2F;Pattern&gt;\n            &lt;&#x2F;layout&gt;\n        &lt;&#x2F;encoder&gt;\n    &lt;&#x2F;appender&gt;\n\n    &lt;root level&#x3D;&quot;INFO&quot;&gt;\n        &lt;appender-ref ref&#x3D;&quot;stdout&quot;&#x2F;&gt; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;用来格式化日志输出的\n        &lt;appender-ref ref&#x3D;&quot;grpc&quot;&#x2F;&gt; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;用来上报日志的\n    &lt;&#x2F;root&gt;\n&lt;&#x2F;configuration&gt;\n\n如果服务和skyWalking不在同一个服务器上，还需要在agent文件夹下的config的agent.config中添加如下配置：\nplugin.toolkit.log.grpc.reporter.server_host&#x3D;$&#123;SW_GRPC_LOG_SERVER_HOST:172.28.231.100&#125;  &#x3D;&#x3D;&#x3D;地址\nplugin.toolkit.log.grpc.reporter.server_port&#x3D;$&#123;SW_GRPC_LOG_SERVER_PORT:11800&#125; &#x3D;&#x3D;&#x3D;端口\nplugin.toolkit.log.grpc.reporter.max_message_size&#x3D;$&#123;SW_GRPC_LOG_MAX_MESSAGE_SIZE:10485760&#125; &#x3D;&#x3D;&#x3D;最大日志大小\nplugin.toolkit.log.grpc.reporter.upstream_timeout&#x3D;$&#123;SW_GRPC_LOG_GRPC_UPSTREAM_TIMEOUT:30&#125; \n\n如何定位某条日志对应的调用链路？\n\n通过该TID在skyWalking中进行搜索，不支持模糊查询\n\n","slug":"Java/SkyWalking分布式链路追踪","date":"2022-08-19T22:55:50.542Z","categories_index":"技术,分布式,中间件,分布式链路追踪","tags_index":"Java,分布式","author_index":"CleWm"},{"id":"cebe9414641c5085bfbfba73b0875917","title":"分布式ID","content":"\n分布式ID雪花算法\n共64位，这三个部分是保证唯一性的重要条件，缺一不可，但是可以根据业务需要调整他们占用的位数，添加其他的信息，比如业务代码。\n工作流程\n还需要配合Redis一起使用\n雪花算法生成ID配合Redis使用实现集群唯一ID(长度为18位)&#x2F;**\n * @author sungm\n * @since 2021-11-06 21:16\n *&#x2F;\n@Slf4j\n@Service\npublic class SnowflakeManager &#123;\n\n    &#x2F;** 开始时间戳: 2020-01-01 00:00:00 *&#x2F;\n    private static final Long START_TIMESTAMP &#x3D; 1577808000000L;\n    &#x2F;** 12位最大序号: 2^12 - 1 *&#x2F;\n    private static final Long MAX_SEQ &#x3D; ~(-1L &lt;&lt; 12);\n    &#x2F;** 10位最大机器码： 2^10 -1 *&#x2F;\n    private static final Long MAX_MACHINE &#x3D; ~(-1L &lt;&lt; 10);\n\n    &#x2F;** 当前机器码 *&#x2F;\n    private Long machine;\n    &#x2F;** 最后生成的序号 *&#x2F;\n    private Long lastSeq &#x3D; 0L;\n    &#x2F;** 最后一个序号生成的时间 *&#x2F;\n    private Long lastSqlTimestamp &#x3D; 0L;\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    &#x2F;** 定义雪花算法的 Key，把机器码存到Redis中 *&#x2F;\n    private static final String RECORD_SNOWFLAKE_MACHINE_SEQ_REDIS_KEY &#x3D; &quot;RECORD_SNOWFLAKE_MACHINE_SEQ&quot;;\n    private static final String RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY &#x3D; &quot;RECORD_SNOWFLAKE_MACHINE_MAP&quot;;\n\n    @PostConstruct\n    public void init() throws UnknownHostException &#123;\n        &#x2F;&#x2F;获取当前机器的IP地址\n        final String hostAddress &#x3D; InetAddress.getLocalHost().getHostAddress();\n        &#x2F;&#x2F;初始化Redis缓存\n        stringRedisTemplate.opsForValue().setIfAbsent(RECORD_SNOWFLAKE_MACHINE_SEQ_REDIS_KEY, &quot;0&quot;);\n        stringRedisTemplate.opsForHash().putIfAbsent(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY, &quot;default&quot;, &quot;0&quot;);\n        &#x2F;&#x2F;不包含当前主机IP地址时，设置递增的值\n        if (!stringRedisTemplate.opsForHash().keys(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY).contains(hostAddress)) &#123;\n            stringRedisTemplate.opsForHash().put(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY, hostAddress\n                    , stringRedisTemplate.opsForValue().increment(RECORD_SNOWFLAKE_MACHINE_SEQ_REDIS_KEY, 1L).toString());\n        &#125;\n        &#x2F;&#x2F;获取当前主机对应的编码\n        machine &#x3D; Long.parseLong((String) stringRedisTemplate.opsForHash().get(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY, hostAddress));\n        log.info(&quot;主机：&#123;&#125;，机器码：&#123;&#125;&quot;, hostAddress, machine);\n        &#x2F;&#x2F;做个校验\n        if (machine &gt; MAX_MACHINE) &#123;\n            throw new RuntimeException(&quot;机器码已达到最大值&quot; + MAX_MACHINE + &quot;, 请排查无效数据！&quot;);\n        &#125;\n    &#125;\n\n    public synchronized Long nextId() &#123;\n        &#x2F;&#x2F;获取当前时间\n        Long now &#x3D; System.currentTimeMillis();\n        if (lastSqlTimestamp.equals(now) &amp;&amp; ++lastSeq &gt; MAX_SEQ) &#123;\n            throw new RuntimeException(&quot;同一毫秒内生成的序号达到&quot; + MAX_SEQ + &quot;, 请注意并发量！&quot;);\n        &#125;\n        if (!lastSqlTimestamp.equals(now)) &#123;\n            lastSeq &#x3D; 0L;\n        &#125;\n        lastSqlTimestamp &#x3D; now;\n        &#x2F;* 0 - 41位时间戳 - 10位机器码 - 12位序列*&#x2F;\n        return ((now - START_TIMESTAMP) &lt;&lt; 22) | machine &lt;&lt; 12 | lastSeq;\n    &#125;\n\n&#125;\n\n","slug":"Java/分布式ID","date":"2022-07-20T01:57:56.986Z","categories_index":"技术,分布式","tags_index":"Java,分布式","author_index":"CleWm"},{"id":"bf5af07f5bcdc26d4909303b36fb356e","title":"MongoDB","content":"MongoDB概念一种非关系型数据库(NoSQL)\n应用场景：高并发的、需要低延时的，对事务要求、安全性不是很高的场景。\n和Reids的区别？Redis主要把数据存储在内存中，其“缓存”的性质远大于其“数据存储“的性质，其中数据的增删改查也只是像变量操作一样简单；\nMongoDB却是一个“存储数据”的系统，增删改查可以添加很多条件，就像SQL数据库一样灵活，这一点在面试的时候很受用。\n术语对比\nWindows安装/启动下载zip格式的mongoDB包\nhttps:&#x2F;&#x2F;www.mongodb.com&#x2F;try&#x2F;download&#x2F;community\n\n下载之后解压，在根目录下创建文件夹data/db\n\n进入bin目录下进入cmd\n执行如下\nmongod --dbpath&#x3D;..&#x2F;data&#x2F;db  #指定数据库存放位置\n\n重新进入bin下的cmd，执行如下：\nmongo 或者 mongo --host&#x3D;127.0.0.1 --port&#x3D;27017 #27017是默认端口号\n\nLinux安装/启动\n\n配置内容如下：\nsystemLog:\n\t#MongoDB发送所有日志输出的目标指定为文件\n\t# #The path of the 1log file to which mongod or mongos should send all diagnostic 1ogging information\n\tdestination: file\n    #mongod或mongos应向其发送所有诊断日志记录信息的日志文件的路径\n    path: &quot;&#x2F;mongodb&#x2F;sing1e&#x2F;1og&#x2F;mongod. log&quot;\n    #当mongos或mongod实例重新启动时，mongos或mongod会将新条目附加到现有日志文件的末尾。\n    logAppend: true\nstorage:\n    #mongod实例存储其数据的目录。storage . dbpath设置仅适用于mongod.\n    ##The directory where the mongod instance stores its data. Default value is &quot;&#x2F;data&#x2F;db&quot;.\n    dbpath: &quot;&#x2F;mongodb&#x2F;sing1e&#x2F;data&#x2F;db&quot;\n    journal:\n        #启用或禁用持久性日志以确保数据文件保持有效和可恢复。\n        enabled: true\nprocessManagement:\n    #启用在后台运行mongos或mongod进程的守护进程模式。\n    fork: true\nnet:\n    #服务实例绑定的IP，默认是localhost\n    bindIp: 1oca1host,192.168.0.2\n    #绑定的端口，默认是27017\n    port: 27017\n\n启动：\n&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;bin&#x2F;mongod -f &#x2F;mongodb&#x2F;single&#x2F;mongod.conf\n\n结果应该是Successfully\n然后就可以使用可视化工具或者Shell命令行进行连接，如果连接不上，尝试关闭防火墙\n#查看防火墙状态 systemctl status firewalld \n#临时关闭防火墙 systemctl stop firewalld \n#开机禁止启动防火墙 systemctl disable firewalld\n\n关闭数据库：\n&#x2F;&#x2F;客户端登录服务，注意，这里通过localhost登录，如果需要远程登录，必须先登录认证才行。 \nmongo --port 27017 &#x2F;&#x2F;#切换到admin库 \nuse admin &#x2F;&#x2F;关闭服务 \ndb.shutdownServer()\n\n图形化界面到官网下载Compass，直接运行即可\n使用数据库use 数据库名称 #选择&#x2F;创建\n\nshow dbs #查看数据库(磁盘里的)\n\ndb #查看正在使用的数据库\n\ndb.dropDatabase() #删除数据库 db指的是数据库对象，操作的是当前使用的数据库\n\n集合db.createCollection(&quot;My&quot;) #创建一个叫My的集合\n\nshow collections #查看所有集合\n\ndb.集合名.drop() #删除某个集合\n\n文档文档的id值必须为字符串!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!不是数字查询/插入普通查询db.集合名.insert(&#123;&quot;name&quot;:&quot;value&quot;&#125;) #单条数据的插入，若此时集合未被创建，会隐式地创建好集合\n\ndb.集合名.insertMany([\n    &#123;\n        xxx:xxx\n    &#125;,\n    &#123;\n        xxx:xxx\n    &#125;,\n])  #插入多条数据\n\ndb.集合名.find() #查看集合内容\n\ndb.集合名.find(&#123;&quot;name&quot;:&quot;张三&quot;&#125;) #查询名字为张三的内容\n\ndb.集合名.findOne() &#x2F; db.集合名.findOne(&#123;xxx:xxx&#125;)#查询一条数据，类似于limit\n\ndb.集合名.find(&#123;查询的条件&#125;,&#123;字段1:1,字段2:0&#125;)#只显示部分字段,显示字段1，不显示字段2，以逗号分割\n\n统计查询 countdb.comment.count() #查询所有数据数量\n\ndb.comment.count(&#123;条件&#125;)\n\n分页查询 limt/skipdb.comment.find().limit(3) #限制查询数量\n\ndb.comment.find().limit(2).skip(2)\n\n排序 sortdb.comment.find().sort(&#123;xxx:1&#x2F;0&#125;) #1为升序，-1为降序\n\n正则查询 / /db.comment.find(&#123;字段:&#x2F;正则表达式&#x2F;&#125;)\n\n比较查询 gt/ltdb.comment.find(&#123;xxx:&#123;$gt:value&#125;&#125;)\n\ngt：大于\ngte：大于等于\n\nlt：小于\nlte：小于等于\n\n包含查询 in/nindb.comment.find(&#123;xxx:&#123;$in:[&quot;value1&quot;,&quot;value2&quot;]&#125;&#125;) #包含\n\ndb.comment.find(&#123;xxx:&#123;$nin:[&quot;value1&quot;,&quot;value2&quot;]&#125;&#125;) #不包含\n\n多条件查询 and/ordb.comment.find(&#123;$and:[&#123;&quot;xxx&quot;:&quot;value&quot;&#125;,&#123;&quot;xxx2&quot;:&#123;$gt:NumberInt(233)&#125;&#125;]&#125;)\n\n\ndb.comment.find(&#123;$or:[&#123;&quot;xxx&quot;:&quot;value&quot;&#125;,&#123;&quot;xxx2&quot;:&#123;$gt:NumberInt(233)&#125;&#125;]&#125;)\n\n\n\nTry catch包裹插入语句\n可以知道哪条数据插入失败\n更新如下是覆盖更新\ndb.comment.update(&#123;更新的条件&#125;,&#123;更新的内容&#125;)\n\n如下才是局部更新\ndb.comment.update(&#123;更新的条件&#125;,&#123;$set:&#123;更新的内容&#125;&#125;)\n\n默认是只修改找到的第一条数据，若想修改全部\ndb.comment.update(&#123;更新的条件&#125;,&#123;$set:&#123;更新的内容&#125;&#125;,&#123;multi:true&#125;)\n\n使某个字段自增1\ndb.comment.update(&#123;更新的条件&#125;,&#123;$inc:&#123;XXX:NumberInt(1)&#125;&#125;)\n\n删除db.comment.remove(&#123;删除的条件&#125;)\n\ndb.comment.remove(&#123;&#125;) #删除全部\n\n#以上是过时的方法，下面是新的\nuse 数据库名\ndb.文档名.deleteOne(&#123;&quot;uid&quot;:&quot;123&quot;&#125;)\n\ndb.文档名.deleteMany(&#123;&quot;sex&quot;:&quot;男&quot;&#125;) #删多个满足条件的\n\ndb.文档名.deleteMany(&#123;&#125;) #删所有\n\n索引db.comment.getIndexs() #查看索引\n\ndb.comment.createIndex(keys,options) #查看索引 options里常用的是name：指定索引名称和unique指定是否是唯一索引\n\n单字段索引db.comment.createIndex(&#123;&quot;userId&quot;:1&#125;) #给userId字段添加一个升序的单字段索引\n\n复合索引db.comment.createIndex(&#123;&quot;userId&quot;:1,&quot;age&quot;:-1&#125;) #给userId字段添加一个升序的索引,age为降序的索引\n\n其他索引\n\n删除索引db.comment.dropIndex(&#123;&quot;userId&quot;:1&#125;) #删除userId字段的升序的索引\n\ndb.comment.dropIndexes() #删除所有索引\n\n性能检查db.comment.find(xxx).explain()\n\n覆盖查询类似于MySQL中的覆盖索引\n就是查询的字段正是索引的字段\n整合到SpringBoot依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n编写配置：\n# 应用名称\nspring:\n  application:\n    name: mongotest\n  data:\n    mongodb:\n      database: mytest\n      host: 127.0.0.1\n      port: 27017\n#      username: 如果有\n#      password: 如果有\nserver:\n  port: 8990\n\n创建实体类，并指定文档名\n@Document(collection &#x3D; &quot;user&quot;) &#x2F;&#x2F;可以省略，省略的话默认文档名为实体类的小写名\n@Data\npublic class User &#123;\n\n    &#x2F;&#x2F;mongoDB里自带的id为字符串！！！！！！！！！！！！\n    public String id;\n\n    @Field(&quot;name&quot;)\n    public String name;\n\n    public Integer sex;\n\n&#x2F;&#x2F;    @Indexed 添加单字段索引\n    public Long compId;\n\n    public String phone;\n&#125;\n\n注入模板类：\n@Autowired\nprivate MongoTemplate mongoTemplate;\n\n基本增添：@GetMapping(&quot;&#x2F;save&quot;)\npublic String save() &#123;\n    User user &#x3D; new User();\n    user.setName(&quot;CleWM&quot;);\n    user.setSex(1);\n    user.setCompId(10001L);\n    user.setPhone(&quot;18083822909&quot;);\n    &#x2F;&#x2F;insert和save的区别？\n    &#x2F;&#x2F;insert: 若新增数据的主键已经存在，则会抛 org.springframework.dao.DuplicateKeyException 异常提示主键重复，不保存当前数据。\n    &#x2F;&#x2F;save: 若新增数据的主键已经存在，则会对当前已经存在的数据进行修改操作\n    User insert &#x3D; mongoTemplate.insert(user);\n    return insert.getId().toString();\n&#125;\n\n基本查询：@GetMapping(&quot;&#x2F;get&quot;)\npublic String get() &#123;\n    Query query &#x3D; new Query();\n    query.addCriteria(Criteria.where(&quot;name&quot;).is(&quot;CleWM&quot;));\n    List&lt;User&gt; res &#x3D; mongoTemplate.find(query, User.class);\n    return res.get(0).toString();\n&#125;\n\n基本删除：mongoTemplate.remove(obj)\n    \n&#x2F;&#x2F;根据条件删除\nQuery query &#x3D; new Query();\nquery.addCriteria(Criteria.where(&quot;id&quot;).is(commentId));\nComment res &#x3D; mongoTemplate.findAndRemove(query, Comment.class);\n\n基本修改：Query query &#x3D; new Query();\nquery.addCriteria(Criteria.where(&quot;id&quot;).is(commentId));\nComment res &#x3D; mongoTemplate.findAndRemove(query, Comment.class);\n\nUpdate update &#x3D; new Update();\nupdate.set(&quot;key&quot;,&quot;value&quot;);\nmongoTemplate.updateFirst(query,update,Comment.class);\n\n排序&#x2F;&#x2F;实体类的字段需要实现Comparable接口，并重写方法，如下，注意，o和this的位置不能颠倒，否则升序和降序也会反过来。\n    @Override\n    public int compareTo(@NotNull Comment o) &#123;\n        return o.getLikes().compareTo(this.getLikes());\n    &#125;\n\n@Override\npublic List getList(CommentFuzzySearchDTO commentFuzzySearchDTO) &#123;\n    Query query &#x3D; new Query().with(Sort.by(&quot;likes&quot;).descending()); &#x2F;&#x2F;降序排序\n    query.addCriteria(Criteria.where(&quot;item_id&quot;).is(commentFuzzySearchDTO.getItemId()));\n    Integer curr &#x3D; commentFuzzySearchDTO.getCurr();\n    Integer pageSize &#x3D; commentFuzzySearchDTO.getPageSize();\n    List&lt;Comment&gt; commentList &#x3D; mongoTemplate.find(query, Comment.class)\n            .stream().skip((curr - 1) * pageSize).limit(pageSize).sorted().collect(Collectors.toList());\n    return commentList;\n&#125;\n\n自增public Boolean likeInc(String commentId) &#123;\n    Query query &#x3D; new Query();\n    query.addCriteria(Criteria.where(&quot;_id&quot;).is(commentId));\n    Update update &#x3D; new Update();\n    update.inc(&quot;likes&quot;);\n    UpdateResult updateResult &#x3D; mongoTemplate.updateFirst(query, update, Comment.class);\n    long modifiedCount &#x3D; updateResult.getModifiedCount();\n    return modifiedCount &gt; 0;\n&#125;\n\n更多使用参考https://blog.csdn.net/qq_36331657/article/details/116431191\nhttps://blog.csdn.net/weixin_40392053/article/details/120265736\n副本集三个节点：\n\n主节点，Primary\n从节点，Slave \n选举节点，A也属于Slave，无法成为主节点\n\n触发选举条件：\n","slug":"Java/MongDB","date":"2022-07-14T02:40:19.176Z","categories_index":"技术,分布式,中间件,数据库","tags_index":"Java,分布式存储引擎,高并发","author_index":"CleWm"}]