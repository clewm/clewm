{"title":"分布式ID","uid":"cebe9414641c5085bfbfba73b0875917","slug":"Java/分布式ID","date":"2022-07-20T01:57:56.986Z","updated":"2022-11-03T23:44:08.464Z","comments":true,"path":"api/articles/Java/分布式ID.json","keywords":null,"cover":"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/4k%20%E7%BE%8E%E5%A5%B3%20%E7%99%BD%E8%89%B2%E5%8F%A4%E8%A3%85%20%E5%8F%A4%E9%A3%8E%20%D0%A1%CF%AA%20%E7%80%91%E5%B8%83%20%E5%B2%A9%E7%9F%B3%20%E9%AB%98%E6%B8%85%20%E5%A3%81%E7%BA%B8_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg","content":"<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/4k%20%E7%BE%8E%E5%A5%B3%20%E7%99%BD%E8%89%B2%E5%8F%A4%E8%A3%85%20%E5%8F%A4%E9%A3%8E%20%D0%A1%CF%AA%20%E7%80%91%E5%B8%83%20%E5%B2%A9%E7%9F%B3%20%E9%AB%98%E6%B8%85%20%E5%A3%81%E7%BA%B8_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg\" alt=\"4k 美女 白色古装 古风 СϪ 瀑布 岩石 高清 壁纸_彼岸图网\"></p>\n<h1 id=\"分布式ID\"><a href=\"#分布式ID\" class=\"headerlink\" title=\"分布式ID\"></a>分布式ID</h1><h2 id=\"雪花算法\"><a href=\"#雪花算法\" class=\"headerlink\" title=\"雪花算法\"></a>雪花算法</h2><p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220720144035556.png\" alt=\"image-20220720144035556\"></p>\n<p>共64位，这三个部分是保证唯一性的重要条件，缺一不可，但是可以根据业务需要调整他们占用的位数，添加其他的信息，比如业务代码。</p>\n<h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/1734261-20220210191137958-980879319.png\" alt=\"img\"></p>\n<p>还需要配合Redis一起使用</p>\n<h2 id=\"雪花算法生成ID配合Redis使用实现集群唯一ID-长度为18位\"><a href=\"#雪花算法生成ID配合Redis使用实现集群唯一ID-长度为18位\" class=\"headerlink\" title=\"雪花算法生成ID配合Redis使用实现集群唯一ID(长度为18位)\"></a>雪花算法生成ID配合Redis使用实现集群唯一ID(长度为18位)</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * @author sungm\n * @since 2021-11-06 21:16\n *&#x2F;\n@Slf4j\n@Service\npublic class SnowflakeManager &#123;\n\n    &#x2F;** 开始时间戳: 2020-01-01 00:00:00 *&#x2F;\n    private static final Long START_TIMESTAMP &#x3D; 1577808000000L;\n    &#x2F;** 12位最大序号: 2^12 - 1 *&#x2F;\n    private static final Long MAX_SEQ &#x3D; ~(-1L &lt;&lt; 12);\n    &#x2F;** 10位最大机器码： 2^10 -1 *&#x2F;\n    private static final Long MAX_MACHINE &#x3D; ~(-1L &lt;&lt; 10);\n\n    &#x2F;** 当前机器码 *&#x2F;\n    private Long machine;\n    &#x2F;** 最后生成的序号 *&#x2F;\n    private Long lastSeq &#x3D; 0L;\n    &#x2F;** 最后一个序号生成的时间 *&#x2F;\n    private Long lastSqlTimestamp &#x3D; 0L;\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    &#x2F;** 定义雪花算法的 Key，把机器码存到Redis中 *&#x2F;\n    private static final String RECORD_SNOWFLAKE_MACHINE_SEQ_REDIS_KEY &#x3D; &quot;RECORD_SNOWFLAKE_MACHINE_SEQ&quot;;\n    private static final String RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY &#x3D; &quot;RECORD_SNOWFLAKE_MACHINE_MAP&quot;;\n\n    @PostConstruct\n    public void init() throws UnknownHostException &#123;\n        &#x2F;&#x2F;获取当前机器的IP地址\n        final String hostAddress &#x3D; InetAddress.getLocalHost().getHostAddress();\n        &#x2F;&#x2F;初始化Redis缓存\n        stringRedisTemplate.opsForValue().setIfAbsent(RECORD_SNOWFLAKE_MACHINE_SEQ_REDIS_KEY, &quot;0&quot;);\n        stringRedisTemplate.opsForHash().putIfAbsent(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY, &quot;default&quot;, &quot;0&quot;);\n        &#x2F;&#x2F;不包含当前主机IP地址时，设置递增的值\n        if (!stringRedisTemplate.opsForHash().keys(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY).contains(hostAddress)) &#123;\n            stringRedisTemplate.opsForHash().put(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY, hostAddress\n                    , stringRedisTemplate.opsForValue().increment(RECORD_SNOWFLAKE_MACHINE_SEQ_REDIS_KEY, 1L).toString());\n        &#125;\n        &#x2F;&#x2F;获取当前主机对应的编码\n        machine &#x3D; Long.parseLong((String) stringRedisTemplate.opsForHash().get(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY, hostAddress));\n        log.info(&quot;主机：&#123;&#125;，机器码：&#123;&#125;&quot;, hostAddress, machine);\n        &#x2F;&#x2F;做个校验\n        if (machine &gt; MAX_MACHINE) &#123;\n            throw new RuntimeException(&quot;机器码已达到最大值&quot; + MAX_MACHINE + &quot;, 请排查无效数据！&quot;);\n        &#125;\n    &#125;\n\n    public synchronized Long nextId() &#123;\n        &#x2F;&#x2F;获取当前时间\n        Long now &#x3D; System.currentTimeMillis();\n        if (lastSqlTimestamp.equals(now) &amp;&amp; ++lastSeq &gt; MAX_SEQ) &#123;\n            throw new RuntimeException(&quot;同一毫秒内生成的序号达到&quot; + MAX_SEQ + &quot;, 请注意并发量！&quot;);\n        &#125;\n        if (!lastSqlTimestamp.equals(now)) &#123;\n            lastSeq &#x3D; 0L;\n        &#125;\n        lastSqlTimestamp &#x3D; now;\n        &#x2F;* 0 - 41位时间戳 - 10位机器码 - 12位序列*&#x2F;\n        return ((now - START_TIMESTAMP) &lt;&lt; 22) | machine &lt;&lt; 12 | lastSeq;\n    &#125;\n\n&#125;</code></pre>\n\n","text":" 分布式ID雪花算法 共64位，这三个部分是保证唯一性的重要条件，缺一不可，但是可以根据业务需要调整他们占用的位数，添加其他的信息，比如业务代码。 工作流程 还需要配合Redis一起使用 雪花算法生成ID配合Redis使用实现集群唯一ID(长度为18位)&#x2F;** * @a...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"技术","slug":"技术","count":6,"path":"api/categories/技术.json"},{"name":"分布式","slug":"技术/分布式","count":4,"path":"api/categories/技术/分布式.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"分布式","slug":"分布式","count":3,"path":"api/tags/分布式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%B8%83%E5%BC%8FID\"><span class=\"toc-text\">分布式ID</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">雪花算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">工作流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E7%94%9F%E6%88%90ID%E9%85%8D%E5%90%88Redis%E4%BD%BF%E7%94%A8%E5%AE%9E%E7%8E%B0%E9%9B%86%E7%BE%A4%E5%94%AF%E4%B8%80ID-%E9%95%BF%E5%BA%A6%E4%B8%BA18%E4%BD%8D\"><span class=\"toc-text\">雪花算法生成ID配合Redis使用实现集群唯一ID(长度为18位)</span></a></li></ol></li></ol>","author":{"name":"CleWm","slug":"blog-author","avatar":"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/467a8fb87ff3c96961397cd53bcc2c0.jpg","link":"/","description":"记录学习 & 生活的碎片，欢迎参观！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"SkyWalking","uid":"61002d5c25b8c7e1297b605504df9169","slug":"Java/SkyWalking分布式链路追踪","date":"2022-08-19T22:55:50.542Z","updated":"2022-11-22T02:45:52.605Z","comments":true,"path":"api/articles/Java/SkyWalking分布式链路追踪.json","keywords":null,"cover":[],"text":"SkyWalking下载地址：http://skywalking.apache.org/downloads/概念：可实现基于Open Tracing规范的分布式链路追踪功能的APM应用性能管理平台 UI界面的jar包和配置文件（可修改端 口） 修改skywalking服务端数据存...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"技术","slug":"技术","count":6,"path":"api/categories/技术.json"},{"name":"分布式","slug":"技术/分布式","count":4,"path":"api/categories/技术/分布式.json"},{"name":"中间件","slug":"技术/分布式/中间件","count":2,"path":"api/categories/技术/分布式/中间件.json"},{"name":"分布式链路追踪","slug":"技术/分布式/中间件/分布式链路追踪","count":1,"path":"api/categories/技术/分布式/中间件/分布式链路追踪.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"分布式","slug":"分布式","count":3,"path":"api/tags/分布式.json"}],"author":{"name":"CleWm","slug":"blog-author","avatar":"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/467a8fb87ff3c96961397cd53bcc2c0.jpg","link":"/","description":"记录学习 & 生活的碎片，欢迎参观！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}