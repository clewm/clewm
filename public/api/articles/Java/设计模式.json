{"title":"25种设计模式代码示例","uid":"7b8b6ec466d1e9597a02dfeba735af86","slug":"Java/设计模式","date":"2022-12-17T02:49:17.450Z","updated":"2022-12-17T02:49:14.440Z","comments":true,"path":"api/articles/Java/设计模式.json","keywords":null,"cover":[],"content":"<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><p>菜鸟设计模式：</p>\n<p><a href=\"https://www.runoob.com/design-pattern/design-pattern-tutorial.html\">https://www.runoob.com/design-pattern/design-pattern-tutorial.html</a></p>\n<p>UML类图教程：</p>\n<p><a href=\"https://blog.csdn.net/weixin_57504000/article/details/124218420\">https://blog.csdn.net/weixin_57504000/article/details/124218420</a></p>\n<p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>\n<p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>\n<p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>\n<h1 id=\"一、创建型模式\"><a href=\"#一、创建型模式\" class=\"headerlink\" title=\"一、创建型模式\"></a>一、创建型模式</h1><h2 id=\"1-工厂模式\"><a href=\"#1-工厂模式\" class=\"headerlink\" title=\"1.工厂模式\"></a>1.工厂模式</h2><p>获得<strong>复杂对象</strong>实例（简单对象只需要new即可），而无须关心其具体的实现细节。</p>\n<p><strong>实现：</strong></p>\n<p>定义一个接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Phone &#123;\n\n    public String use();\n&#125;</code></pre>\n\n<p>定义实体，并继承该接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Oppo implements Phone &#123;\n\n    @Override\n    public String use() &#123;\n        return &quot;我是oppo  &quot;;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Xiaomi implements Phone &#123;\n\n    @Override\n    public String use() &#123;\n        return &quot;我是小米&quot;;\n    &#125;\n&#125;</code></pre>\n\n<p>定义工厂类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class PhoneFactory &#123;\n\n    public static class Type&#123;\n        public static final String TYPE_XIAOMI &#x3D; &quot;xiaomi&quot;;\n        public static final String TYPE_OPPO &#x3D; &quot;oppo&quot;;\n    &#125;\n\n    public Phone getPhoneByType(String type) &#123;\n        if(type.equalsIgnoreCase(Type.TYPE_XIAOMI))&#123;\n            return new Xiaomi();\n        &#125;else if(type.equalsIgnoreCase(Type.TYPE_OPPO))&#123;\n            return new Oppo();\n        &#125;\n        return null;\n    &#125;\n&#125;</code></pre>\n\n<p>使用：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    public static void main(String[] args) &#123;\n        PhoneFactory phoneFactory &#x3D; new PhoneFactory();\n        Phone xiaomi &#x3D; phoneFactory.getPhoneByType(PhoneFactory.Type.TYPE_XIAOMI);\n        System.out.println(xiaomi.use());\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214080627939.png\" alt=\"image-20221214080627939\"></p>\n<h2 id=\"2-抽象工厂模式\"><a href=\"#2-抽象工厂模式\" class=\"headerlink\" title=\"2.抽象工厂模式\"></a>2.抽象工厂模式</h2><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。</p>\n<p>定义一个抽象工厂类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class AbstractFactory &#123;\n\n    public abstract Phone getPhoneByType(String phoneType);\n\n    public abstract Color getColorByType(String phoneType);\n&#125;</code></pre>\n\n<p>具体的工厂类继承该抽象工厂类：</p>\n<p>手机工厂：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class PhoneFactory extends AbstractFactory &#123;\n\n    public static class Type&#123;\n        public static final String TYPE_XIAOMI &#x3D; &quot;xiaomi&quot;;\n        public static final String TYPE_OPPO &#x3D; &quot;oppo&quot;;\n    &#125;\n\n    public Phone getPhoneByType(String type) &#123;\n        if(type.equalsIgnoreCase(Type.TYPE_XIAOMI))&#123;\n            return new Xiaomi();\n        &#125;else if(type.equalsIgnoreCase(Type.TYPE_OPPO))&#123;\n            return new Oppo();\n        &#125;\n        return null;\n    &#125;\n\n    @Override\n    public Color getColorByType(String phoneType) &#123;\n        return null;\n    &#125;\n&#125;</code></pre>\n\n<p>颜色工厂：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ColorFactory extends AbstractFactory &#123;\n\n    public static class TYPE&#123;\n        public static final String TYPE_RED &#x3D; &quot;red&quot;;\n\n        public static final String TYPE_YELLOW &#x3D; &quot;yellow&quot;;\n    &#125;\n\n    @Override\n    public Phone getPhoneByType(String phoneType) &#123;\n\n        return null;\n    &#125;\n\n    @Override\n    public Color getColorByType(String phoneType) &#123;\n        if (TYPE.TYPE_RED.equalsIgnoreCase(phoneType)) &#123;\n            return new Red();\n        &#125;else if (TYPE.TYPE_YELLOW.equalsIgnoreCase(phoneType))&#123;\n            return new Yellow();\n        &#125;\n        return null;\n    &#125;\n&#125;</code></pre>\n\n<p>定义一个超级工厂类，用于获得具体的工厂：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RootFactory &#123;\n\n    public static class TYPE&#123;\n        public static final String TYPE_PHONE &#x3D; &quot;phone&quot;;\n        public static final String TYPE_COLOR &#x3D; &quot;color&quot;;\n    &#125;\n\n    public static AbstractFactory getFactoryByType(String factoryType) &#123;\n        if (TYPE.TYPE_PHONE.equalsIgnoreCase(factoryType))&#123;\n            return new PhoneFactory();\n        &#125;else if(TYPE.TYPE_COLOR.equals(factoryType))&#123;\n            return new ColorFactory();\n        &#125;\n        return null;\n    &#125;\n&#125;</code></pre>\n\n<p>使用：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    &#x2F;&#x2F;获得工厂\n    AbstractFactory factoryByType &#x3D; RootFactory.getFactoryByType(RootFactory.TYPE.TYPE_COLOR);\n    &#x2F;&#x2F;从工厂获得对象\n    Color colorByType &#x3D; factoryByType.getColorByType(ColorFactory.TYPE.TYPE_RED);\n    System.out.println(colorByType.show());\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214080715116.png\" alt=\"image-20221214080715116\"></p>\n<h2 id=\"3-构造器模式\"><a href=\"#3-构造器模式\" class=\"headerlink\" title=\"3.构造器模式\"></a>3.构造器模式</h2><p>参考：<a href=\"https://www.dandelioncloud.cn/article/details/1523275053169147905\">https://www.dandelioncloud.cn/article/details/1523275053169147905</a></p>\n<p>传统的构造对象方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Person person &#x3D; new Person();\nperson.setId(1);\nperson.setName(&quot;张小毛&quot;);\nperson.setAge(22);\nperson.setSex(&quot;男&quot;);\nperson.setPhone(&quot;19999999999&quot;);\nperson.setAddress(&quot;beijing&quot;);\nperson.setDesc(&quot;JavaBeans模式&quot;);</code></pre>\n\n<ul>\n<li>优点：易于阅读，并且可以只对有用的成员变量赋值</li>\n<li>缺点：成员变量不可以是 final 类型，失去了不可变对象的很多好处，对象状态不连续，你必须调用7次setter方法才能得到一个具备7个属性值得变量，在这期间用户可能拿到不完整状态的对象。如果有N个属性，岂不是要<code>person.setXXX</code>调用N次？此种方式不优雅</li>\n</ul>\n<p>构造器模式演示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">PrivateKeyDecryptParam param &#x3D; new PrivateKeyDecryptParam.Builder()\n                                              .uAppId(uAppId)\n                                              .containerId(containerId)\n                                              .cipher(cipher)\n                                              .signFlag(signFlag)\n                                              .build();</code></pre>\n\n<p>示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@ToString\npublic class User &#123;\n\n    private String name;\n\n    private Integer age;\n\n    private Integer sex;\n\n    private User(Builder builder)&#123;\n        this.name &#x3D; builder.name;\n        this.age &#x3D; builder.age;\n        this.sex &#x3D; builder.sex;\n    &#125;\n\n    public static class Builder &#123;\n\n        &#x2F;&#x2F;必要参数\n        private final String name;\n\n        &#x2F;&#x2F;可选参数\n        private Integer age;\n        private Integer sex;\n\n        public Builder(String name)&#123;\n            this.name &#x3D; name;\n        &#125;\n\n        public Builder age(Integer age) &#123;\n            this.age &#x3D; age;\n            return this;\n        &#125;\n\n        public Builder sex(Integer sex) &#123;\n            this.sex &#x3D; sex;\n            return this;\n        &#125;\n\n        public User build() &#123;\n            return new User(this);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>使用：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">User cleWm &#x3D; new User.Builder(&quot;CleWm&quot;)\n        .age(21)\n        .sex(0)\n        .build();</code></pre>\n\n<p>要点：</p>\n<ul>\n<li>外部类的构造函数私有，且参数为静态内部类；</li>\n<li>静态内部类拥有外部类相同的属；</li>\n<li>为每一个属性，写一个方法，返回的是Builer；</li>\n<li>最后一个方法是build方法，用于构建一个外部类；</li>\n</ul>\n<p>优点：降低复杂性，优雅</p>\n<p>缺点：代码量提高了</p>\n<h2 id=\"4-单例模式\"><a href=\"#4-单例模式\" class=\"headerlink\" title=\"4.单例模式\"></a>4.单例模式</h2><p>一个类确保只有单个对象被创建</p>\n<p><strong>饿汉式：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HungrySingleton &#123;\n\n    private static HungrySingleton instance &#x3D; new HungrySingleton();\n\n    private HungrySingleton()&#123;&#125;\n\n    public static HungrySingleton getInstance()&#123;\n        return instance;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>懒汉式：</strong></p>\n<p>双重检查锁：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LazySingleton &#123;\n\n    private static LazySingleton instance;\n\n    private LazySingleton() &#123;&#125;\n\n    public static LazySingleton getInstance() &#123;\n        if(instance &#x3D;&#x3D; null)&#123;\n            synchronized (LazySingleton.class)&#123;\n                if (instance &#x3D;&#x3D; null)&#123;\n                    instance &#x3D; new LazySingleton();\n                &#125;\n            &#125;\n        &#125;\n        return instance;\n    &#125;\n&#125;</code></pre>\n\n<p>静态内部类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LazySingleton2 &#123;\n\n    private LazySingleton2()&#123;&#125;\n\n    &#x2F;**\n     * 静态内部类和非静态内部类都是在被调用的时候才会进行加载，和外部类没有关系，从而实现了延迟加载\n     *&#x2F;\n    private static class SingletonHolder&#123;\n        private static final LazySingleton2 instance &#x3D; new LazySingleton2();\n    &#125;\n\n    public static LazySingleton2 getInstance() &#123;\n        return SingletonHolder.instance;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        LazySingleton instance1 &#x3D; LazySingleton.getInstance();\n        LazySingleton instance2 &#x3D; LazySingleton.getInstance();\n        System.out.println(instance1 &#x3D;&#x3D; instance2);\n\n        LazySingleton2 instance3 &#x3D; LazySingleton2.getInstance();\n        LazySingleton2 instance4 &#x3D; LazySingleton2.getInstance();\n        System.out.println(instance3 &#x3D;&#x3D; instance4);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214081317951.png\" alt=\"image-20221214081317951\"></p>\n<h2 id=\"5-原型模式\"><a href=\"#5-原型模式\" class=\"headerlink\" title=\"5.原型模式\"></a>5.原型模式</h2><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。一般会配合工厂模式一起使用。</p>\n<p>与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p>\n<p>定义一个抽象父类，并实现Cloneable接口：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Cloneable是一个标识接口，clone方法是Object提供的方法，\n * 只有实现了Cloneable接口，同时重写clone方法才不会报错\n *&#x2F;\n@Getter\n@ToString\npublic abstract class Book implements Cloneable&#123;\n\n    protected String name;\n\n    protected Integer type;\n\n    @Override\n    protected Book clone()&#123;\n        Object clone &#x3D; null;\n        try&#123;\n            clone &#x3D; super.clone();\n        &#125;catch (CloneNotSupportedException e)&#123;\n            e.printStackTrace();\n        &#125;\n        return (Book)clone;\n    &#125;\n&#125;</code></pre>\n\n<p>定义具体实现类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BookOne extends Book&#123;\n\n    BookOne() &#123;\n        name &#x3D; &quot;《第一本书》&quot;;\n        type &#x3D; 1;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BookTwo extends Book&#123;\n\n    BookTwo() &#123;\n        name &#x3D; &quot;《第二本书》&quot;;\n        type &#x3D; 2;\n    &#125;\n&#125;</code></pre>\n\n<p>定义一个Factory来获得克隆对象：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BookFactory &#123;\n\n    &#x2F;**\n     * 用于存储我们的原始对象，克隆对象以此为基础进行复制\n     *&#x2F;\n    private static final Map&lt;Integer,Book&gt; cache;\n\n    static &#123;\n        cache &#x3D; new HashMap&lt;&gt;();\n        cache.put(Type.TYPE_ONE,new BookOne());\n        cache.put(Type.TYPE_TWO,new BookTwo());\n    &#125;\n\n    public static class Type&#123;\n        public static final Integer TYPE_ONE &#x3D; 1;\n        public static final Integer TYPE_TWO &#x3D; 2;\n    &#125;\n\n    &#x2F;**\n     * 返回的是克隆对象\n     * @param type\n     * @return\n     *&#x2F;\n    public static Book getBookByType(Integer type) &#123;\n        return cache.get(type).clone();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n    @org.junit.Test\n    public void test1() &#123;\n        Book book1 &#x3D; BookFactory.getBookByType(BookFactory.Type.TYPE_ONE);\n        Book book2 &#x3D; BookFactory.getBookByType(BookFactory.Type.TYPE_ONE);\n        System.out.println(book1 &#x3D;&#x3D; book2);\n        System.out.println(book1);\n        System.out.println(book2);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214081502987.png\" alt=\"image-20221214081502987\"></p>\n<h1 id=\"二、结构型模式\"><a href=\"#二、结构型模式\" class=\"headerlink\" title=\"二、结构型模式\"></a>二、结构型模式</h1><h2 id=\"6-适配器模式\"><a href=\"#6-适配器模式\" class=\"headerlink\" title=\"6.适配器模式\"></a>6.适配器模式</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁</p>\n<p>比如220V的电源，使用电源适配器给手机提供12V的电压充电。</p>\n<p><strong>定义一个目标接口，该接口属于一般情况</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Target &#123;\n\n    public void get();\n&#125;</code></pre>\n\n<p><strong>定义一个不兼容的，需要被适配的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SpecialStatus &#123;\n\n    public void specialGet() &#123;\n        System.out.println(&quot;这是特殊情况的get实现&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义适配器，实现Target接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Adapter implements Target &#123;\n\n    private SpecialStatus specialStatus;\n\n    public Adapter(SpecialStatus specialStatus)&#123;\n        this.specialStatus &#x3D; specialStatus;\n    &#125;\n\n    @Override\n    public void get() &#123;\n        specialStatus.specialGet();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        SpecialStatus specialStatus &#x3D; new SpecialStatus();\n        Adapter adapter &#x3D; new Adapter(specialStatus);\n        adapter.get();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217093732742.png\" alt=\"image-20221217093732742\"></p>\n<h2 id=\"7-桥接模式\"><a href=\"#7-桥接模式\" class=\"headerlink\" title=\"7.桥接模式\"></a>7.桥接模式</h2><p>Bridge，它的作用是将抽象部分和它的实现部分分离，从而可以让它们独立地变化。</p>\n<p>就好比有一个武器槽，放不同的武器进去就是不同的功能。s</p>\n<p><strong>先定义抽象部分，比如武器槽</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class WeaponSlot &#123;\n\n    protected Weapon weapon;\n\n    abstract void shoot();\n\n    public void setWeapon(Weapon weapon)&#123;\n        this.weapon &#x3D; weapon;\n    &#125;\n\n    public abstract void opreation();\n&#125;</code></pre>\n\n<p><strong>定义实现的接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Weapon &#123;\n\n    void shoot();\n&#125;</code></pre>\n\n<p><strong>定义抽象部分的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LeftSlot extends WeaponSlot&#123;\n\n    @Override\n    void shoot() &#123;\n        weapon.shoot();\n    &#125;\n\n    @Override\n    public void opreation() &#123;\n        weapon.shoot();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义实现接口的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AK47 implements Weapon &#123;\n    @Override\n    public void shoot() &#123;\n        System.out.println(&quot;AK开枪了！&quot;);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class M4 implements Weapon &#123;\n    @Override\n    public void shoot() &#123;\n        System.out.println(&quot;m4开枪！&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n\n        M4 m4 &#x3D; new M4();\n        AK47 ak47 &#x3D; new AK47();\n\n        LeftSlot leftSlot &#x3D; new LeftSlot();\n        leftSlot.setWeapon(m4);\n        leftSlot.opreation();\n\n        leftSlot.setWeapon(ak47);\n        leftSlot.opreation();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103542571.png\" alt=\"image-20221217103542571\"></p>\n<h2 id=\"8-过滤器模式\"><a href=\"#8-过滤器模式\" class=\"headerlink\" title=\"8.过滤器模式\"></a>8.过滤器模式</h2><p>Filter ，它的作用是过滤序列中的特定元素。</p>\n<p><strong>定义一个过滤器的接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Filter &lt;T&gt;&#123;\n\n    List&lt;T&gt; doFilter(List&lt;T&gt; lists);\n&#125;</code></pre>\n\n<p><strong>定义要过滤的实体类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class User &#123;\n\n    private String name;\n\n    private Integer age;\n\n    private Integer sex;\n&#125;</code></pre>\n\n<p><strong>定义过滤器的具体实现</strong></p>\n<p>年龄过滤器：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AgeFilter implements Filter&lt;User&gt; &#123;\n\n    @Override\n    public List&lt;User&gt; doFilter(List&lt;User&gt; lists) &#123;\n        ArrayList&lt;User&gt; res &#x3D; new ArrayList&lt;&gt;();\n        for (User user : lists) &#123;\n            if(user.getAge() &gt;&#x3D; 18)&#123;\n                res.add(user);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;</code></pre>\n\n<p>性别过滤器：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SexFilter implements Filter&lt;User&gt; &#123;\n    @Override\n    public List&lt;User&gt; doFilter(List&lt;User&gt; lists) &#123;\n        ArrayList&lt;User&gt; res &#x3D; new ArrayList&lt;&gt;();\n        for (User user : lists) &#123;\n            if (user.getSex() &#x3D;&#x3D; 1)&#123;\n                res.add(user);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        AgeFilter ageFilter &#x3D; new AgeFilter();\n        SexFilter sexFilter &#x3D; new SexFilter();\n        ArrayList&lt;User&gt; userArrayList &#x3D; new ArrayList&lt;&gt;();\n        for (int i &#x3D; 1; i &lt; 10; i++) &#123;\n            User user &#x3D; new User();\n            user.setAge(RandomUtil.randomInt(10,35));\n            user.setName(&quot;张&quot; + i);\n            user.setSex(RandomUtil.randomEle(new Integer[]&#123;0,1&#125;));\n            userArrayList.add(user);\n        &#125;\n        List&lt;User&gt; users1 &#x3D; ageFilter.doFilter(userArrayList);\n        System.out.println(&quot;第一次过滤后的结果：&quot; + users1);\n\n        List&lt;User&gt; users2 &#x3D; sexFilter.doFilter(users1);\n        System.out.println(&quot;第二次过滤后的结果：&quot; + users2);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103713100.png\" alt=\"image-20221217103713100\"></p>\n<h2 id=\"9-组合模式\"><a href=\"#9-组合模式\" class=\"headerlink\" title=\"9.组合模式\"></a>9.组合模式</h2><p>Composite，是用于把一组相似的对象当作一个单一的对象。组合模式依据<strong>树形结构</strong>来组合对象，用来表示部分以及整体层次。</p>\n<p>例如：在可视化开发中，容器和按钮等组件之间的关系。又或者是公司、学校的组织架构等。</p>\n<p>以学校为例：</p>\n<p><strong>定义一个员工类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@ToString(exclude &#x3D; &quot;subordinates&quot;)\npublic class Employee &#123;\n\n    private String name;\n\n    private String dept;\n\n    private Integer salary;\n\n    private List&lt;Employee&gt; subordinates;\n\n    public Employee(String name, String dept, Integer salary) &#123;\n        this.name &#x3D; name;\n        this.dept &#x3D; dept;\n        this.salary &#x3D; salary;\n        this.subordinates &#x3D; new ArrayList&lt;&gt;();\n    &#125;\n\n    public void addSubordinate(Employee subordinate) &#123;\n        subordinates.add(subordinate);\n    &#125;\n\n    public void removeSubordinate(Employee subordinate) &#123;\n        subordinates.remove(subordinate);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Employee 张昌平 &#x3D; new Employee(&quot;张昌平&quot;, &quot;校长&quot;, 30000);\n\n        Employee 张雪迎 &#x3D; new Employee(&quot;张雪迎&quot;, &quot;7班班主任&quot;, 10000);\n        Employee 刘静 &#x3D; new Employee(&quot;刘静&quot;, &quot;8班班主任&quot;, 9000);\n\n        Employee 胡伟明 &#x3D; new Employee(&quot;胡伟明&quot;, &quot;7班学生&quot;, 0);\n        Employee 李冠杰 &#x3D; new Employee(&quot;李冠杰&quot;, &quot;7班学生&quot;, 0);\n        Employee 田继睿 &#x3D; new Employee(&quot;田继睿&quot;, &quot;7班学生&quot;, 0);\n        Employee 冯毅力 &#x3D; new Employee(&quot;冯毅力&quot;, &quot;7班学生&quot;, 0);\n\n        Employee 冯跟源 &#x3D; new Employee(&quot;冯跟源&quot;, &quot;8班学生&quot;, 0);\n        Employee 施冰清 &#x3D; new Employee(&quot;施冰清&quot;, &quot;8班学生&quot;, 0);\n\n\n\n        张昌平.addSubordinate(张雪迎);\n        张昌平.addSubordinate(刘静);\n\n\n        张雪迎.addSubordinate(胡伟明);\n        张雪迎.addSubordinate(李冠杰);\n        张雪迎.addSubordinate(田继睿);\n        张雪迎.addSubordinate(冯毅力);\n\n        刘静.addSubordinate(冯跟源);\n        刘静.addSubordinate(施冰清);\n\n        &#x2F;**\n         * 二叉树如下:\n         *                      张昌平\n         *                    &#x2F;      \\\n         *                   &#x2F;        \\\n         *                张雪迎        刘静\n         *                &#x2F; | | \\      &#x2F; \\\n         *               &#x2F;  | |  \\    &#x2F;   \\\n         *             胡   李 冯 田   冯   施\n         *&#x2F;\n        System.out.println(张昌平);\n        for (Employee sub1 : 张昌平.getSubordinates())&#123;\n            System.out.println(sub1);\n            for (Employee sub2 : sub1.getSubordinates())&#123;\n                System.out.println(sub2);\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103845510.png\" alt=\"image-20221217103845510\"></p>\n<h2 id=\"10-装饰器模式\"><a href=\"#10-装饰器模式\" class=\"headerlink\" title=\"10.装饰器模式\"></a>10.装饰器模式</h2><p>Decorator，允许向一个现有的对象添加新的功能，同时又不改变其结构。</p>\n<p><strong>定义一个接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Person &#123;\n\n    void eat();\n&#125;</code></pre>\n\n<p><strong>定义一个接口的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CleWm implements Person &#123;\n    @Override\n    public void eat() &#123;\n        System.out.println(&quot;吃了一碗饭...&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义一个装饰器，实现接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Decorator implements Person &#123;\n\n    private Person person;\n\n    @Override\n    public void eat() &#123;\n        person.eat();\n        System.out.println(&quot;person又吃了一碗...&quot;);\n    &#125;\n\n    public void setPerson(Person person) &#123;\n        this.person &#x3D; person;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        CleWm cleWm &#x3D; new CleWm();\n        Decorator decorator &#x3D; new Decorator();\n        decorator.setPerson(cleWm);\n        decorator.eat();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103941837.png\" alt=\"image-20221217103941837\"></p>\n<h2 id=\"11-外观模式\"><a href=\"#11-外观模式\" class=\"headerlink\" title=\"11.外观模式\"></a>11.外观模式</h2><p>Facade，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 外观类\npublic class Facade &#123;\n   private Subsystem1 subsystem1;\n   private Subsystem2 subsystem2;\n\n   public Facade() &#123;\n      subsystem1 &#x3D; new Subsystem1();\n      subsystem2 &#x3D; new Subsystem2();\n   &#125;\n\n   &#x2F;&#x2F; 提供一个简化的接口，用于客户端访问子系统\n   public void operation() &#123;\n      subsystem1.operation1();\n      subsystem2.operation1();\n   &#125;\n&#125;\n\n&#x2F;&#x2F; 子系统1\npublic class Subsystem1 &#123;\n   public void operation1() &#123;\n      &#x2F;&#x2F; 实现子系统1的相关操作\n   &#125;\n&#125;\n\n&#x2F;&#x2F; 子系统2\npublic class Subsystem2 &#123;\n   public void operation1() &#123;\n      &#x2F;&#x2F; 实现子系统2的相关操作\n   &#125;\n&#125;</code></pre>\n\n<h2 id=\"12-享元模式\"><a href=\"#12-享元模式\" class=\"headerlink\" title=\"12.享元模式\"></a>12.享元模式</h2><p>Flyweight，主要用于减少创建对象的数量，以减少内存占用和提高性能。</p>\n<p>说白了就是在工厂模式的工厂类中，缓存一个Map，每次创建对象的时候就进行一个判断，若指定对象存在，则直接从map中取出并返回，若没有，则新建，然后缓存进入Map当中。</p>\n<p><strong>创建一个颜色</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Color &#123;\n\n    public String colorName;\n\n    public Color(String colorName)&#123;\n        this.colorName &#x3D; colorName;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>创建一个颜色工厂</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ColorFactory &#123;\n\n    private Map&lt;String, Color&gt; map &#x3D; new HashMap&lt;&gt;();\n\n    public Color getColor(String colorName) &#123;\n        return Optional.ofNullable(map.get(colorName)).orElseGet(()-&gt;&#123;\n            Color color &#x3D; new Color(colorName);\n            map.put(colorName,color);\n            return color;\n        &#125;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        ColorFactory colorFactory &#x3D; new ColorFactory();\n        Color red1 &#x3D; colorFactory.getColor(&quot;red&quot;);\n        Color red2 &#x3D; colorFactory.getColor(&quot;red&quot;);\n        Color red3 &#x3D; colorFactory.getColor(&quot;blue&quot;);\n        System.out.println(red1 &#x3D;&#x3D; red2);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104139185.png\" alt=\"image-20221217104139185\"></p>\n<h2 id=\"13-代理模式\"><a href=\"#13-代理模式\" class=\"headerlink\" title=\"13.代理模式\"></a>13.代理模式</h2><p>Proxy，它通过引入一个新的类来控制对另一个对象的访问。这有助于控制对原始对象的访问，并且可以在访问原始对象时执行其他附加操作。</p>\n<p><strong>定义一个接口，包含被代理的方法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Image &#123;\n\n    public void show();\n&#125;</code></pre>\n\n<p><strong>定义原始类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Realimage implements Image &#123;\n\n    private String path;\n\n    public Realimage(String path) &#123;\n        this.path &#x3D; path;\n        loadFromDisk();\n    &#125;\n\n    @Override\n    public void show() &#123;\n        System.out.println(&quot;展示&quot; + path + &quot;的图片&quot;);\n    &#125;\n\n    void loadFromDisk() &#123;\n        System.out.println(&quot;正在从磁盘中加载图片:&quot; + path);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义代理对象</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ProxyImage implements Image &#123;\n\n    private String path;\n\n    private Realimage realimage;\n\n    public ProxyImage(String path) &#123;\n        this.path &#x3D; path;\n    &#125;\n\n    @Override\n    public void show() &#123;\n        if(realimage &#x3D;&#x3D; null)&#123;\n            realimage &#x3D; new Realimage(path);\n        &#125;\n        realimage.show();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        ProxyImage proxyImage &#x3D; new ProxyImage(&quot;C:\\\\test.jpg&quot;);\n        proxyImage.show();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104158303.png\" alt=\"image-20221217104158303\"></p>\n<h1 id=\"三、行为型模式\"><a href=\"#三、行为型模式\" class=\"headerlink\" title=\"三、行为型模式\"></a>三、行为型模式</h1><h2 id=\"14-责任链模式\"><a href=\"#14-责任链模式\" class=\"headerlink\" title=\"14.责任链模式\"></a>14.责任链模式</h2><p>Chain of Responsibility，为请求创建了一个接收者对象的链。</p>\n<p>通常每个接收者都包含对另一个接收者的引用。<strong>如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者</strong>，依此类推。</p>\n<p><strong>定义一个实体</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@AllArgsConstructor\npublic class Package &#123;\n\n    private String loc;\n&#125;</code></pre>\n\n<p><strong>定义一个处理器的抽象父类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class PackageHandler &#123;\n\n    private PackageHandler next;\n\n    public void next(PackageHandler next)&#123;\n        this.next &#x3D; next;\n    &#125;\n\n    public void handler(Package p)&#123;\n        if(next !&#x3D; null)&#123;\n            next.handler(p);\n        &#125;else &#123;\n            System.out.println(&quot;接收到一个未知地点的包裹....&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义处理器的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class KunmingPackageHandler extends PackageHandler&#123;\n    @Override\n    public void handler(Package p) &#123;\n        if(&quot;昆明&quot;.equals(p.getLoc()))&#123;\n            System.out.println(&quot;处理了一个昆明的包裹...[&quot; + this + &quot;]&quot;);\n            return;\n        &#125;else &#123;\n            super.handler(p);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TianJinPackageHandler extends PackageHandler&#123;\n\n    @Override\n    public void handler(Package p) &#123;\n        if(&quot;天津&quot;.equals(p.getLoc()))&#123;\n            System.out.println(&quot;处理了一个天津的包裹...[&quot; + this + &quot;]&quot;);\n            return;\n        &#125;else &#123;\n            super.handler(p);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        KunmingPackageHandler kunmingPackageHandler &#x3D; new KunmingPackageHandler();\n        TianJinPackageHandler tianJinPackageHandler &#x3D; new TianJinPackageHandler();\n\n        &#x2F;&#x2F; |kunmingPackageHandler| ------ |tianJinPackageHandler| ------ null\n        kunmingPackageHandler.next(tianJinPackageHandler);\n\n\n        Package package1 &#x3D; new Package(&quot;天津&quot;);\n        Package package2 &#x3D; new Package(&quot;昆明&quot;);\n        Package package3 &#x3D; new Package(&quot;四川&quot;);\n\n        List&lt;Package&gt; packageList &#x3D; ListUtil.of(package1, package2, package3);\n        for (Package aPackage : packageList) &#123;\n            kunmingPackageHandler.handler(aPackage);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104231704.png\" alt=\"image-20221217104231704\"></p>\n<h2 id=\"15-命令模式\"><a href=\"#15-命令模式\" class=\"headerlink\" title=\"15.命令模式\"></a>15.命令模式</h2><p>Command，<strong>命令模式允许请求的一方和接收的一方独立开来</strong>，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221211094616223.png\" alt=\"image-20221211094616223\"></p>\n<p>简单理解就是，封装一条命令，为该命令设置一个接收者，然后将该命令set进一个调用者对象（Invoker）中，最后调用Invoker的runCommand方法来执行命令。</p>\n<p><strong>创建命令接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Command &#123;\n\n    void run();\n&#125;</code></pre>\n\n<p><strong>创建接收者(可以理解为被隐藏的具体功能实现的部分)</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Receiver &#123;\n\n    private Integer stock &#x3D; 100;\n\n    &#x2F;**\n     * 接收者的增加库存接口，命令调用者无须关心这些接口。\n     *&#x2F;\n    public void increase() &#123;\n        stock++;\n        System.out.println(&quot;[库存剩余]:&quot; + stock);\n    &#125;\n\n    &#x2F;**\n     * 接收者的减少库存接口，命令调用者无须关心这些接口。\n     *&#x2F;\n    public void decrease() &#123;\n        stock--;\n        System.out.println(&quot;[库存剩余]:&quot; + stock);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>创建命令实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AddStockCommand implements Command &#123;\n\n    private Receiver receiver;\n\n    public AddStockCommand(Receiver receiver) &#123;\n        this.receiver &#x3D; receiver;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        receiver.increase();\n        System.out.println(&quot;添加了1个库存...&quot;);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SubStockCommand implements Command &#123;\n\n    private Receiver receiver;\n\n    public SubStockCommand(Receiver receiver)&#123;\n        this.receiver &#x3D; receiver;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        receiver.decrease();\n        System.out.println(&quot;减少了1个库存...&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>创建调用者</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Invoker&#123;\n\n    &#x2F;&#x2F; 这里也可用一个List来存储命令，在调用时使用for循环命令依次执行。\n    private Command command;\n\n    public Invoker(Command command)&#123;\n        this.command &#x3D; command;\n    &#125;\n\n    public void invokeCommand() &#123;\n        if(command !&#x3D; null)&#123;\n            command.run();\n            System.out.println(&quot;命令执行完毕...&quot;);\n        &#125;else &#123;\n            System.out.println(&quot;未设置命令！&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        &#x2F;&#x2F; 创建一个接收者\n        Receiver receiver &#x3D; new Receiver();\n\n        &#x2F;&#x2F; 库存增加命令\n        AddStockCommand addStockCommand &#x3D; new AddStockCommand(receiver);\n        &#x2F;&#x2F; 库存减少命令\n        SubStockCommand subStockCommand &#x3D; new SubStockCommand(receiver);\n\n        &#x2F;&#x2F; 创建一个调用者\n        Invoker invoker1 &#x3D; new Invoker(addStockCommand);\n        &#x2F;&#x2F; 让调用者执行命令。\n        invoker1.invokeCommand();\n\n        &#x2F;&#x2F; 创建一个调用者\n        Invoker invoker2 &#x3D; new Invoker(subStockCommand);\n        &#x2F;&#x2F; 让调用者执行命令。\n        invoker2.invokeCommand();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104253518.png\" alt=\"image-20221217104253518\"></p>\n<h2 id=\"16-解释器模式\"><a href=\"#16-解释器模式\" class=\"headerlink\" title=\"16.解释器模式\"></a>16.解释器模式</h2><p>Interpreter，它允许你定义一个语言的文法，并且基于该文法解释语言中的句子。</p>\n<p><strong>定义表达式接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Expression &#123;\n\n    boolean interpret(String content);\n&#125;</code></pre>\n\n<p><strong>定义表达式</strong></p>\n<p><strong>关键词表达式，若内容中包含指定data内容，则为true</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class KeyWordExpression implements Expression &#123;\n\n    private String data;\n\n    public KeyWordExpression(String data)&#123;\n        this.data &#x3D; data;\n    &#125;\n\n\n    @Override\n    public boolean interpret(String content) &#123;\n        if (data !&#x3D; null)&#123;\n            return content.contains(data);\n        &#125;\n        else &#123;\n            throw new RuntimeException(&quot;未设置表达式data内容&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>或表达式</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class OrExpression implements Expression &#123;\n\n    private Expression exp1;\n    private Expression exp2;\n\n    public OrExpression(Expression exp1,Expression exp2) &#123;\n        this.exp1 &#x3D; exp1;\n        this.exp2 &#x3D; exp2;\n    &#125;\n\n    @Override\n    public boolean interpret(String content) &#123;\n        return exp1.interpret(content) || exp2.interpret(content);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>与表达式</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AndExpression implements Expression &#123;\n\n    private Expression exp1;\n    private Expression exp2;\n\n    public AndExpression(Expression exp1, Expression exp2) &#123;\n        this.exp1 &#x3D; exp1;\n        this.exp2 &#x3D; exp2;\n    &#125;\n\n    @Override\n    public boolean interpret(String content) &#123;\n        return exp1.interpret(content) &amp;&amp; exp2.interpret(content);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        KeyWordExpression exp1 &#x3D; new KeyWordExpression(&quot;CleWm&quot;);\n        boolean res1 &#x3D; exp1.interpret(&quot;I am CleWm&quot;);\n\n        KeyWordExpression exp2 &#x3D; new KeyWordExpression(&quot;CleWm&quot;);\n        KeyWordExpression exp3 &#x3D; new KeyWordExpression(&quot;clewm&quot;);\n\n        OrExpression exp4 &#x3D; new OrExpression(exp2, exp3);\n        boolean res2 &#x3D; exp4.interpret(&quot;CleWm&quot;);\n        AndExpression exp5 &#x3D; new AndExpression(exp2, exp3);\n        boolean res3 &#x3D; exp5.interpret(&quot;CleWm&quot;);\n        System.out.println(res1);\n        System.out.println(res2);\n        System.out.println(res3);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104357944.png\" alt=\"image-20221217104357944\"></p>\n<h2 id=\"17-迭代器模式\"><a href=\"#17-迭代器模式\" class=\"headerlink\" title=\"17.迭代器模式\"></a>17.迭代器模式</h2><p>Iterator，这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p>\n<p><strong>创建迭代器接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Container &#123;\n\n    MyIterator getIterator();\n&#125;</code></pre>\n\n<p><strong>创建容器接口，该接口用于使得容器能够返回一个迭代器</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Container &#123;\n\n    MyIterator getIterator();\n&#125;</code></pre>\n\n<p><strong>创建容器的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class PersonRepository implements Container &#123;\n\n    private static final List&lt;String&gt; personList;\n    private int index;\n\n    static &#123;\n        personList &#x3D; ListUtil.of(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;赵六&quot;);\n    &#125;\n\n    @Override\n    public MyIterator getIterator() &#123;\n        index &#x3D; 0;\n        return new PersonIterator();\n    &#125;\n\n    private class PersonIterator implements MyIterator&lt;String&gt;&#123;\n\n        @Override\n        public boolean hasNext() &#123;\n            return personList.size() &gt; 0 &amp;&amp; index &lt; personList.size();\n        &#125;\n\n        @Override\n        public String next() &#123;\n            return personList.get(index++);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1()&#123;\n        PersonRepository personRepository &#x3D; new PersonRepository();\n        MyIterator iterator &#x3D; personRepository.getIterator();\n        while (iterator.hasNext())&#123;\n            System.out.println(iterator.next());\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104416848.png\" alt=\"image-20221217104416848\"></p>\n<h2 id=\"18-中介者模式\"><a href=\"#18-中介者模式\" class=\"headerlink\" title=\"18.中介者模式\"></a>18.中介者模式</h2><p>Mediator，这种模式提供了一个中介类，该类通常处理不同类之间的通信。</p>\n<p>聊天室为例</p>\n<p><strong>定义用户</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class User &#123;\n\n    private String name;\n    private ChatRoom chatRoom;\n\n    public User(String name)&#123;\n        this.name &#x3D; name;\n    &#125;\n\n    public void sendMessage(String content) &#123;\n        System.out.println(name + &quot; 发送一条消息:&quot; + content);\n        Message message &#x3D; new Message(name, content);\n        if(chatRoom &#x3D;&#x3D; null)&#123;\n            throw new RuntimeException(&quot;未加入任何聊天室&quot;);\n        &#125;\n        chatRoom.send(message);\n    &#125;\n\n    public void receiveMessage(Message message) &#123;\n        System.out.println(name + &quot; 收到一条消息: &quot; + message);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义消息</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@AllArgsConstructor\npublic class Message &#123;\n\n    private String from;\n    private String content;\n&#125;</code></pre>\n\n<p><strong>定义聊天室</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ChatRoom &#123;\n\n    private List&lt;User&gt; userList &#x3D; new ArrayList&lt;&gt;();\n\n    public void send(Message message)&#123;\n        for (User user : userList)&#123;\n            if(message.getFrom().equals(user.getName())) continue;\n            user.receiveMessage(message);\n        &#125;\n    &#125;\n\n    public void register(User user) &#123;\n        user.setChatRoom(this);\n        userList.add(user);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        ChatRoom chatRoom &#x3D; new ChatRoom();\n\n        User 张三 &#x3D; new User(&quot;张三&quot;);\n        User 李四 &#x3D; new User(&quot;李四&quot;);\n        User 王五 &#x3D; new User(&quot;王五&quot;);\n        chatRoom.register(张三);\n        chatRoom.register(李四);\n        chatRoom.register(王五);\n\n        张三.sendMessage(&quot;你好，我是张三&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104510201.png\" alt=\"image-20221217104510201\"></p>\n<h2 id=\"19-备忘录模式\"><a href=\"#19-备忘录模式\" class=\"headerlink\" title=\"19.备忘录模式\"></a>19.备忘录模式</h2><p>Memento，保存（备份）一个对象的某个状态，以便在适当的时候恢复对象。</p>\n<p><strong>Memento ： 备忘录对象,负责 保存好记录，即Originator内部 状态</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class Memento &#123;\n\n    private String state;\n\n    public Memento(String state)&#123;\n        this.state &#x3D; state;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>originator : 对象(需要保存 状态的对象)</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class Originator &#123;\n\n    private String state;\n\n    public Memento saveStateToMemento() &#123;\n        return new Memento(state);\n    &#125;\n\n    public void restoreStateFromMemento(Memento memento) &#123;\n        this.state &#x3D; memento.getState();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>Caretaker: 备忘录管理者,负责保存多个备忘录对象， 使用集合管理，提高效率</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MementoManager &#123;\n\n    private static List&lt;Memento&gt; mementoList;\n\n    static &#123;\n        mementoList &#x3D; new ArrayList&lt;&gt;();\n    &#125;\n\n    public static boolean add(Memento memento)&#123;\n        return mementoList.add(memento);\n    &#125;\n\n    public static Memento remove(int index) &#123;\n        return mementoList.remove(index);\n    &#125;\n\n    public static Memento get(int index)&#123;\n        return mementoList.get(index);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Originator originator &#x3D; new Originator();\n        originator.setState(&quot;初始状态&quot;);\n        boolean add &#x3D; MementoManager.add(originator.saveStateToMemento());\n        if(!add) throw new RuntimeException(&quot;保存状态失败！&quot;);\n        originator.setState(&quot;第一状态&quot;);\n        System.out.println(&quot;origin的状态为:&quot; + originator.getState());\n        originator.restoreStateFromMemento(MementoManager.get(0));\n        System.out.println(&quot;origin的状态为:&quot; + originator.getState());\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><strong><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104545873.png\" alt=\"image-20221217104545873\"></strong></p>\n<h2 id=\"20-观察者模式\"><a href=\"#20-观察者模式\" class=\"headerlink\" title=\"20.观察者模式\"></a>20.观察者模式</h2><p>Observer，当一个对象被修改时，则会自动通知依赖它的对象。</p>\n<p><strong>创建一个被订阅的（Up主）</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Up &#123;\n\n    private String latestVideo;\n\n    private List&lt;Follower&gt; followers &#x3D; new ArrayList&lt;&gt;();\n\n    public void submitVideo(String video) &#123;\n        this.latestVideo &#x3D; video;\n        notifyAllFollowers();\n    &#125;\n\n    public void addFollower(Follower follower) &#123;\n        followers.add(follower);\n    &#125;\n\n    public void notifyAllFollowers() &#123;\n        for (Follower follower : followers) &#123;\n            follower.update(latestVideo);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>创建一个订阅者（粉丝）</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Follower&#123;\n\n    private String name;\n    private String video;\n    private Up up;\n\n    public Follower(String name,Up up) &#123;\n        this.name &#x3D; name;\n        this.up &#x3D; up;\n        this.up.addFollower(this);\n    &#125;\n\n    public void update(String video) &#123;\n        this.video &#x3D; video;\n        System.out.println(name + &quot; 收到up主 &quot; + up + &quot; 的最新视频 &quot; + video);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Up up &#x3D; new Up();\n        Follower 张三 &#x3D; new Follower(&quot;张三&quot;, up);\n        Follower 李四 &#x3D; new Follower(&quot;李四&quot;, up);\n\n        up.submitVideo(&quot;第1个视频&quot;);\n        System.out.println(&quot;-------------&quot;);\n        up.submitVideo(&quot;第2个视频&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104623464.png\" alt=\"image-20221217104623464\"></p>\n<h2 id=\"21-状态模式\"><a href=\"#21-状态模式\" class=\"headerlink\" title=\"21.状态模式\"></a>21.状态模式</h2><p>State，类的行为是基于它的状态改变的。</p>\n<p><strong>定义状态接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface State &#123;\n\n    void doAction(Context context);\n&#125;</code></pre>\n\n<p><strong>定义一个随着状态改变而做出不同行为的Context上下文</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class Context &#123;\n\n    private State state;\n\n&#125;</code></pre>\n\n<p><strong>定义状态的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class StartState implements State &#123;\n\n    @Override\n    public void doAction(Context context) &#123;\n        System.out.println(&quot;当前是开始状态...&quot;);\n        context.setState(this);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class EndState implements State &#123;\n    @Override\n    public void doAction(Context context) &#123;\n        System.out.println(&quot;当前是结束状态...&quot;);\n        context.setState(this);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Context context &#x3D; new Context();\n\n        StartState startState &#x3D; new StartState();\n        startState.doAction(context);\n\n        EndState endState &#x3D; new EndState();\n        endState.doAction(context);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104706915.png\" alt=\"image-20221217104706915\"></p>\n<h2 id=\"22-空对象模式\"><a href=\"#22-空对象模式\" class=\"headerlink\" title=\"22.空对象模式\"></a>22.空对象模式</h2><p>Null Object，一个空对象取代 NULL 对象。</p>\n<p><strong>定义实体类抽象父类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic abstract class AbstractUser &#123;\n\n    protected String name;\n\n    public abstract boolean isNull();\n&#125;</code></pre>\n\n<p><strong>定义正常的存在的用户对象</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class User extends AbstractUser&#123;\n    public User(String name)&#123;\n        this.name &#x3D; name;\n    &#125;\n\n    @Override\n    public boolean isNull() &#123;\n        return false;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>空对象</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class EmptyUser extends AbstractUser&#123;\n\n    public EmptyUser() &#123;\n        this.name &#x3D; &quot;空用户对象...&quot;;\n    &#125;\n\n    @Override\n    public boolean isNull() &#123;\n        return true;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>创建一个测试用的工厂</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserFactory &#123;\n\n    private static List&lt;String&gt; nameList;\n\n    static &#123;\n        nameList &#x3D; ListUtil.of(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;);\n    &#125;\n\n    public static AbstractUser getUser(String name) &#123;\n        for (String n : nameList) &#123;\n            if(n.equalsIgnoreCase(name))&#123;\n                return new User(name);\n            &#125;\n        &#125;\n        return new EmptyUser();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        AbstractUser 张三 &#x3D; UserFactory.getUser(&quot;张三&quot;);\n        AbstractUser 赵六 &#x3D; UserFactory.getUser(&quot;赵六&quot;);\n\n        System.out.println(张三);\n        System.out.println(赵六);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214080526276.png\" alt=\"image-20221214080526276\"></p>\n<h2 id=\"23-策略模式\"><a href=\"#23-策略模式\" class=\"headerlink\" title=\"23.策略模式\"></a>23.策略模式</h2><p>Strategy，一个类的行为或其算法可以在运行时更改。</p>\n<p><strong>定义策略的接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Strategy &#123;\n\n    public int doStrategy(int a,int b);\n&#125;</code></pre>\n\n<p><strong>定义策略实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AddStrategy implements Strategy &#123;\n\n    @Override\n    public int doStrategy(int a, int b) &#123;\n        return a + b;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SubStrategy implements Strategy &#123;\n    @Override\n    public int doStrategy(int a, int b) &#123;\n        return a - b;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义一个可更改策略的上下文</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class Context &#123;\n\n    private Strategy strategy;\n\n    public int executeStrategy(int a,int b)&#123;\n        if(strategy !&#x3D; null)&#123;\n            return strategy.doStrategy(a,b);\n        &#125;else &#123;\n            throw new RuntimeException(&quot;尚未设置策略！&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Context context &#x3D; new Context();\n        AddStrategy addStrategy &#x3D; new AddStrategy();\n        SubStrategy subStrategy &#x3D; new SubStrategy();\n\n        context.setStrategy(addStrategy);\n        int i1 &#x3D; context.executeStrategy(1, 2);\n        System.out.println(i1);\n\n        context.setStrategy(subStrategy);\n        int i2 &#x3D; context.executeStrategy(5, 2);\n        System.out.println(i2);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p>两个3</p>\n<h2 id=\"24-模板模式\"><a href=\"#24-模板模式\" class=\"headerlink\" title=\"24.模板模式\"></a>24.模板模式</h2><p>Template，在抽象类中提前定义了某个操作的一系列流程的模板，用户只需要实现具体细节即可。</p>\n<p><strong>定义抽象模板父类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class MyGame &#123;\n\n    protected String name;\n\n    abstract void downloadGame();\n    abstract void installGame();\n    abstract void openGame();\n\n    public void playGame() &#123;\n        downloadGame();\n        installGame();\n        openGame();\n        System.out.println(&quot;开始游戏:[&quot; + name + &quot;]&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>创建抽象父类的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LOL extends MyGame&#123;\n\n    public LOL()&#123;\n        this.name &#x3D; &quot;LOL&quot;;\n    &#125;\n\n    @Override\n    void downloadGame() &#123;\n        System.out.println(&quot;正在下载游戏:&quot; + name);\n    &#125;\n\n    @Override\n    void installGame() &#123;\n        System.out.println(&quot;正在安装游戏:&quot; + name);\n    &#125;\n\n    @Override\n    void openGame() &#123;\n        System.out.println(&quot;正在打开游戏:&quot; + name);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CSGO extends MyGame&#123;\n\n    public CSGO() &#123;\n        this.name &#x3D; &quot;CSGO&quot;;\n    &#125;\n\n    @Override\n    void downloadGame() &#123;\n        System.out.println(&quot;正在下载游戏:&quot; + name);\n    &#125;\n\n    @Override\n    void installGame() &#123;\n        System.out.println(&quot;正在安装游戏:&quot; + name);\n    &#125;\n\n    @Override\n    void openGame() &#123;\n        System.out.println(&quot;正在打开游戏:&quot; + name);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        LOL lol &#x3D; new LOL();\n        CSGO csgo &#x3D; new CSGO();\n\n        lol.playGame();\n        csgo.playGame();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221215170923686.png\" alt=\"image-20221215170923686\"></p>\n<h2 id=\"25-访问者模式\"><a href=\"#25-访问者模式\" class=\"headerlink\" title=\"25.访问者模式\"></a>25.访问者模式</h2><p>Visitor，封装一些作用于某些数据结构中的各元素的操作，它可以在不改变数据结构的前提下赋予这些元素新的操作。</p>\n<p><strong>定义被访问者的统一接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Person&#123;\n\n    public void accept(Visitor visitor);\n&#125;</code></pre>\n\n<p><strong>定义被访问者实例</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@AllArgsConstructor\npublic class Student implements Person &#123;\n\n    private String name;\n    private Integer rank;\n\n    @Override\n    public void accept(Visitor visitor) &#123;\n        visitor.visit(this);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@AllArgsConstructor\npublic class Teacher implements Person &#123;\n\n    private String name;\n    private Integer salary;\n\n    @Override\n    public void accept(Visitor visitor) &#123;\n        visitor.visit(this);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义访问者接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Visitor &#123;\n\n    public void visit(Student student);\n\n    public void visit(Teacher teacher);\n&#125;</code></pre>\n\n<p><strong>定义访问者实例</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Headmaster implements Visitor &#123;\n    @Override\n    public void visit(Student student) &#123;\n        System.out.println(&quot;访问学生:&quot; + student.getName() + &quot;,排名为:&quot; + student.getRank());\n    &#125;\n\n    @Override\n    public void visit(Teacher teacher) &#123;\n        System.out.println(&quot;访问老师:&quot; + teacher.getName() + &quot;,月薪为:&quot; + teacher.getSalary());\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Student student &#x3D; new Student(&quot;张三&quot;,21);\n        Teacher teacher &#x3D; new Teacher(&quot;张雪迎&quot;,8000);\n        Headmaster headmaster &#x3D; new Headmaster();\n\n        student.accept(headmaster);\n        teacher.accept(headmaster);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221216100457969.png\" alt=\"image-20221216100457969\"></p>\n","text":"设计模式菜鸟设计模式： https://www.runoob.com/design-pattern/design-pattern-tutorial.html UML类图教程： https://blog.csdn.net/weixin_57504000/article/detail...","link":"","photos":[],"count_time":{"symbolsCount":"40k","symbolsTime":"37 mins."},"categories":[{"name":"技术","slug":"技术","count":6,"path":"api/categories/技术.json"},{"name":"设计模式","slug":"技术/设计模式","count":1,"path":"api/categories/技术/设计模式.json"},{"name":"开发常用","slug":"技术/设计模式/开发常用","count":1,"path":"api/categories/技术/设计模式/开发常用.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":1,"path":"api/tags/设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">设计模式</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">一、创建型模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">1.工厂模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">2.抽象工厂模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E6%9E%84%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.构造器模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">4.单例模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">5.原型模式</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">二、结构型模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">6.适配器模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">7.桥接模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">8.过滤器模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">9.组合模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">10.装饰器模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">11.外观模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">12.享元模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">13.代理模式</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">三、行为型模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">14.责任链模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">15.命令模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">16.解释器模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#17-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">17.迭代器模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#18-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">18.中介者模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#19-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">19.备忘录模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#20-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">20.观察者模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#21-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">21.状态模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#22-%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">22.空对象模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#23-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">23.策略模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#24-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">24.模板模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#25-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">25.访问者模式</span></a></li></ol></li></ol>","author":{"name":"CleWm","slug":"blog-author","avatar":"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/467a8fb87ff3c96961397cd53bcc2c0.jpg","link":"/","description":"记录学习 & 生活的碎片，欢迎参观！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"分布式Session","uid":"2ee2f111cfbae00cef07edd04fd1c972","slug":"Java/分布式Session","date":"2022-11-03T23:45:40.713Z","updated":"2022-11-03T23:47:10.776Z","comments":true,"path":"api/articles/Java/分布式Session.json","keywords":null,"cover":"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/4k%20%E5%88%9D%E9%9F%B3%20%E5%A5%B3%E5%AD%A9%20%E7%AC%9B%E5%AD%90%20%E9%95%BF%E5%8F%91%20%E9%95%BF%E8%A3%99%E5%AD%90%20%E5%8A%A8%E6%BC%AB%E5%A3%81%E7%BA%B8_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg","text":" 分布式Session Session本质：session技术就是一种基于后端有别于数据库的临时存储数据的技术 存活时间：可以通过如下来设置一次Session的存活时间，在这个时间内若再次发送请求，则Session的存活时间将会刷新，若超过时间无请求发送，再次发送的时候会再次创建...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"技术","slug":"技术","count":6,"path":"api/categories/技术.json"},{"name":"分布式","slug":"技术/分布式","count":4,"path":"api/categories/技术/分布式.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"分布式","slug":"分布式","count":3,"path":"api/tags/分布式.json"}],"author":{"name":"CleWm","slug":"blog-author","avatar":"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/467a8fb87ff3c96961397cd53bcc2c0.jpg","link":"/","description":"记录学习 & 生活的碎片，欢迎参观！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}