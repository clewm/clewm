{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-aurora/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-16x16.png","path":"icons/favicon-16x16.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-32x32.png","path":"icons/favicon-32x32.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/img/default-cover.df7c128c.jpg","path":"static/img/default-cover.df7c128c.jpg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/404.1a6cd5bd.css","path":"static/css/404.1a6cd5bd.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/about.32dfa3b0.css","path":"static/css/about.32dfa3b0.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/app.0d31776f.css","path":"static/css/app.0d31776f.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/archives.c0d49bd5.css","path":"static/css/archives.c0d49bd5.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/categories.10e2be12.css","path":"static/css/categories.10e2be12.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/post.9f951a60.css","path":"static/css/post.9f951a60.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/page.749ad047.css","path":"static/css/page.749ad047.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/chunk-libs.eebac533.css","path":"static/css/chunk-libs.eebac533.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/result.10e2be12.css","path":"static/css/result.10e2be12.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/tags.10e2be12.css","path":"static/css/tags.10e2be12.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/404.00d640a8.js","path":"static/js/404.00d640a8.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/about.024aacd1.js","path":"static/js/about.024aacd1.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/app.6d2c358d.js","path":"static/js/app.6d2c358d.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/archives.574ac664.js","path":"static/js/archives.574ac664.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/categories.90aa5475.js","path":"static/js/categories.90aa5475.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/page.a02618ad.js","path":"static/js/page.a02618ad.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/result.39470350.js","path":"static/js/result.39470350.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/tags.2ad613f5.js","path":"static/js/tags.2ad613f5.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/chunk-libs.dc6146cd.js","path":"static/js/chunk-libs.dc6146cd.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/post.cebfbaa4.js","path":"static/js/post.cebfbaa4.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/about/index.md","hash":"d8f348b328138202db7909de1fbe9c6ac86e0ea7","modified":1667348989809},{"_id":"source/_posts/Java/MongDB.md","hash":"3304bfccd8c3e22e7f5e1aaa71a1943ba3d42b4c","modified":1669086045886},{"_id":"source/_posts/Java/SkyWalking分布式链路追踪.md","hash":"11e4c5afb02b26f05f860f13ca480699058e02b7","modified":1669085152605},{"_id":"source/_posts/Java/分布式ID.md","hash":"e01fbc9a96afbb8c26809659bbd562c4fbc5cf48","modified":1667519048464},{"_id":"source/_posts/Java/分布式Session.md","hash":"0a216cac0d3e28596696d76a0d5ddbdcb47c7166","modified":1667519230776},{"_id":"source/_posts/Java/设计模式.md","hash":"71f16170ffde0d2dd4370d622f407d2847bf5584","modified":1671245354440},{"_id":"source/_posts/Java/可复用代码.md","hash":"7eb93f4782bb076fa7628756efba4ce2c54c23d5","modified":1667518912931},{"_id":"node_modules/hexo-theme-aurora/.browserslistrc","hash":"db215b841182d2af3259a1c1d6e1957bca333970","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/CHANGELOG_CN.md","hash":"5d13c251e8b77fd86870da50f3be98f8822edc66","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/CHANGELOG.md","hash":"e68f3af8af17d326a48e1b317e01d7429193217e","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/README.md","hash":"c50f58b08b75780990c18ab85761e3e24aac0d90","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/LICENSE","hash":"21cf269018b0cf04e1126b6b9b1a5e6af7c5e61f","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/package.json","hash":"1b312a6a2de107ba9dc952614f1078c78664a4e4","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/jest.config.js","hash":"425f08cb718a56630ce61ae0686f35c55ef565df","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/data/cn.yml","hash":"4f5dcc1e2953df7a8e4e683c1a9115f6e0041f5e","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/scripts/index.js","hash":"2a3c62a860581ee6813ca4bcaa7c952f614e818c","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/_config.yml","hash":"e6b2335cb393444b8a1fc1ad65331f4a30bc8915","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/_config.aurora.yml","hash":"e6b2335cb393444b8a1fc1ad65331f4a30bc8915","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/data/en.yml","hash":"7bbd6c0da0ae2f93f8a786a3be77fbe4e95a787e","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/.circleci/config.yml","hash":"534051be311581f69aa8287120275a04539290e4","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/layout/index.ejs","hash":"94732830a65b718d2fa506b8598df44f14399fd8","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/filters/index.js","hash":"5eacff9446dd6c9a7eb0a0c84be9187055440454","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/index.js","hash":"dfbb0fdbf990bd67684ed891a4aaa1fd8dcd23f2","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/category.js","hash":"0ae21ffcf6e471ebfb72ac62a833991fae86ec8a","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/page.js","hash":"1be54ea9cdf8e293e67bf457075fcdd8a72b8779","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/post.js","hash":"76c3268e8b6887fb1fd11c4d71004aad9dc215fc","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/search.js","hash":"a2a636e1df76efdcaca37226b490afa539ce766b","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/site.js","hash":"b5f5ce813b4b0b322eceb11b036dc65201604256","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/statistic.js","hash":"1c641956e15cec96490de16a88ccc7bec0c9d5c4","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/tag.js","hash":"975e79e73d2503a33dbc63655b948100cc46d44f","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/symbols-count-time.js","hash":"d1a81e31b2988edcdf4b4761cec7326a980f097a","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/mapper.js","hash":"7a99508d910321b90b4afa0df02ad90f62336901","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/toc.js","hash":"5c7348c550ef7f164d492847801a360cdefc60a2","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/utils.js","hash":"93ff75f0e35a1dc40d5406cc097f5988dd820600","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/truncate-html.js","hash":"49d4832af027eabe5b8383a24e66dceae761533e","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/injector/index.js","hash":"7ca562ea3af3068ee925b5a8afdce0eaa1e15e64","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/img/default-cover.df7c128c.jpg","hash":"1934ace0c6f2397d15729f9b08cc4d42e45bf437","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/css/404.1a6cd5bd.css","hash":"a7a4d83756520d8f6c410ac0ffe9a45d63868113","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/css/about.32dfa3b0.css","hash":"614ef7c4e52877c76ffddb26192bf8fffddcb8d8","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/css/categories.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/css/archives.c0d49bd5.css","hash":"c56213315c57254d0a6e6301ef24c2186fef4d2b","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/css/result.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/css/tags.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/css/chunk-libs.eebac533.css","hash":"41226b6c29aadcc6190fe7c2c4c37464855b8453","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/css/post.9f951a60.css","hash":"8e360582d745d6483fdfc18c46f75897b44721a6","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/css/page.749ad047.css","hash":"6fcf0e6f3c628954c5f8105791e0e7f3e6512da6","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/js/404.00d640a8.js","hash":"74f1da9e0f953e73e4fe1a6554433f56fdcdf54d","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/js/about.024aacd1.js","hash":"7ce2b3f7d232dd3b3930ac993bb841452e2cde89","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/js/archives.574ac664.js","hash":"fbb094fb4f7a01bffd6975aca27142935bfdca73","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/js/categories.90aa5475.js","hash":"0dde3d731fc665962a4c330338a2c663c330be26","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/js/result.39470350.js","hash":"f6f5ab2ca7274dad169ec600a419d1a2aeb2347c","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/js/page.a02618ad.js","hash":"db775fbfbaa1cf8bbf4cc4f2b0a869519d508e3a","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/js/tags.2ad613f5.js","hash":"4f49139e435788710115fc884dc26a5b1e0d4833","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/js/post.cebfbaa4.js","hash":"53586f9dab5886a366e9397eb17088e74af5cde1","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/css/app.0d31776f.css","hash":"43b43acd76bd8dc22f34cc49c7e026c45c3a5004","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/js/app.6d2c358d.js","hash":"e176c20c22ce36e38935f463977e9b89b281c715","modified":1667348149270},{"_id":"node_modules/hexo-theme-aurora/source/static/js/chunk-libs.dc6146cd.js","hash":"534266637d09abf39278f4d3a21bd36728740105","modified":1667348149270},{"_id":"public/api/posts/1.json","hash":"2f1b7dd7604f1747799c2663b743589d1f3b4335","modified":1671245376047},{"_id":"public/api/articles/Java/设计模式.json","hash":"9693ee73d5d8defc4ce0121fbb8f6dbcc9881dcd","modified":1671245376047},{"_id":"public/api/articles/Java/分布式Session.json","hash":"9ff0ad84c8cdd25490fb341b674cf79e0a66fbe6","modified":1671245376047},{"_id":"public/api/articles/Java/可复用代码.json","hash":"55933fd0f93c10fba2103d5d775daa890374d96c","modified":1671245376047},{"_id":"public/api/articles/Java/SkyWalking分布式链路追踪.json","hash":"a71a430d92edcec9e3eed7f9e002420d19e73d65","modified":1671245376047},{"_id":"public/api/articles/Java/分布式ID.json","hash":"a44d271e5ee2d7c75b269103227b496949345743","modified":1671245376047},{"_id":"public/api/articles/Java/MongDB.json","hash":"855126d9a6a0e5f37bf1446f8cd9ac20e1cf8c8e","modified":1671245376047},{"_id":"public/api/features.json","hash":"97d170e1550eee4afc0af065b78cda302a97674c","modified":1671245376047},{"_id":"public/api/authors/blog-author.json","hash":"9ff29c927332def15e6514d75788724be4cd64a4","modified":1671245376047},{"_id":"public/api/site.json","hash":"deb3f5451df192f2b08abdfc0fb418bbe6f0cf44","modified":1671245376047},{"_id":"public/api/categories.json","hash":"ba10143cd2265c0aa34c01f54f532cee47f29649","modified":1671245376047},{"_id":"public/api/categories/技术.json","hash":"0ff356e38acb18097252f183351a9b65a51400d6","modified":1671245376047},{"_id":"public/api/categories/技术/分布式.json","hash":"e3af453569d35e3207eeafff79e2764be6f6205b","modified":1671245376047},{"_id":"public/api/categories/技术/开发常用.json","hash":"25455bc7df311b445d4b7b2a9aa52f11a995e0b5","modified":1671245376047},{"_id":"public/api/categories/技术/设计模式.json","hash":"8eac6caca3b65c43919585e0c8d95f73b200e1c3","modified":1671245376047},{"_id":"public/api/categories/技术/分布式/中间件.json","hash":"ed0229e6d13e456b0fefec5f46d9fa3f287a52df","modified":1671245376047},{"_id":"public/api/categories/技术/设计模式/开发常用.json","hash":"57cbee097b9b1cb582af41d44379f6c270cc2383","modified":1671245376047},{"_id":"public/api/categories/技术/分布式/中间件/数据库.json","hash":"b5f5c1ebe3a44f136a2a054d4546fdd71c3a319c","modified":1671245376047},{"_id":"public/api/categories/技术/分布式/中间件/分布式链路追踪.json","hash":"97e672cc0f8a1572c834d93e279b07a0d26e2176","modified":1671245376047},{"_id":"public/api/tags.json","hash":"764d9c1e5873434934c94fe526a1327d3c2d351b","modified":1671245376047},{"_id":"public/api/tags/Java.json","hash":"07c6033f1b1bc0070e3eff5a6a3054b5950c20e6","modified":1671245376047},{"_id":"public/api/tags/分布式存储引擎.json","hash":"ddd427764f8abae8105ad502514fa1496a13cfbe","modified":1671245376047},{"_id":"public/api/tags/高并发.json","hash":"63e52b0785068b7726630c7867ad099766b5b2ed","modified":1671245376047},{"_id":"public/api/tags/分布式.json","hash":"3dd34751e4a6287ba1e968f818d8ac4b743a6ada","modified":1671245376047},{"_id":"public/api/tags/设计模式.json","hash":"4978f8700b8818bf2c02ec9a3130d166297f6516","modified":1671245376047},{"_id":"public/api/pages/about/index.json","hash":"e634e3fe863f6bf7c199b2236281b4812ff465a2","modified":1671245376047},{"_id":"public/api/statistic.json","hash":"3eb15fd75b1bf598386c192e7d034d998d3693df","modified":1671245376047},{"_id":"public/api/search.json","hash":"5ec24b3ab0946931974c973f4e7c887686bdbce3","modified":1671245376047},{"_id":"public/post/Java/设计模式.html","hash":"f63f84148e3aa9c7b9be3221a585135f6c68d622","modified":1671245376047},{"_id":"public/post/Java/分布式Session.html","hash":"f63f84148e3aa9c7b9be3221a585135f6c68d622","modified":1671245376047},{"_id":"public/post/Java/可复用代码.html","hash":"f63f84148e3aa9c7b9be3221a585135f6c68d622","modified":1671245376047},{"_id":"public/post/Java/SkyWalking分布式链路追踪.html","hash":"f63f84148e3aa9c7b9be3221a585135f6c68d622","modified":1671245376047},{"_id":"public/post/Java/分布式ID.html","hash":"f63f84148e3aa9c7b9be3221a585135f6c68d622","modified":1671245376047},{"_id":"public/post/Java/MongDB.html","hash":"f63f84148e3aa9c7b9be3221a585135f6c68d622","modified":1671245376047},{"_id":"public/index.html","hash":"f63f84148e3aa9c7b9be3221a585135f6c68d622","modified":1671245376047},{"_id":"public/tags/index.html","hash":"f63f84148e3aa9c7b9be3221a585135f6c68d622","modified":1671245376047},{"_id":"public/archives/index.html","hash":"f63f84148e3aa9c7b9be3221a585135f6c68d622","modified":1671245376047},{"_id":"public/page/about/index.html","hash":"f63f84148e3aa9c7b9be3221a585135f6c68d622","modified":1671245376047},{"_id":"public/tags/search/index.html","hash":"f63f84148e3aa9c7b9be3221a585135f6c68d622","modified":1671245376047},{"_id":"public/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":1671245376047},{"_id":"public/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":1671245376047},{"_id":"public/static/img/default-cover.df7c128c.jpg","hash":"1934ace0c6f2397d15729f9b08cc4d42e45bf437","modified":1671245376047},{"_id":"public/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":1671245376047},{"_id":"public/static/css/404.1a6cd5bd.css","hash":"a7a4d83756520d8f6c410ac0ffe9a45d63868113","modified":1671245376047},{"_id":"public/static/css/about.32dfa3b0.css","hash":"614ef7c4e52877c76ffddb26192bf8fffddcb8d8","modified":1671245376047},{"_id":"public/static/css/archives.c0d49bd5.css","hash":"c56213315c57254d0a6e6301ef24c2186fef4d2b","modified":1671245376047},{"_id":"public/static/css/categories.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1671245376047},{"_id":"public/static/css/post.9f951a60.css","hash":"8e360582d745d6483fdfc18c46f75897b44721a6","modified":1671245376047},{"_id":"public/static/css/page.749ad047.css","hash":"6fcf0e6f3c628954c5f8105791e0e7f3e6512da6","modified":1671245376047},{"_id":"public/static/css/chunk-libs.eebac533.css","hash":"41226b6c29aadcc6190fe7c2c4c37464855b8453","modified":1671245376047},{"_id":"public/static/css/result.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1671245376047},{"_id":"public/static/css/tags.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1671245376047},{"_id":"public/static/js/404.00d640a8.js","hash":"74f1da9e0f953e73e4fe1a6554433f56fdcdf54d","modified":1671245376047},{"_id":"public/static/js/about.024aacd1.js","hash":"7ce2b3f7d232dd3b3930ac993bb841452e2cde89","modified":1671245376047},{"_id":"public/static/js/archives.574ac664.js","hash":"fbb094fb4f7a01bffd6975aca27142935bfdca73","modified":1671245376047},{"_id":"public/static/js/categories.90aa5475.js","hash":"0dde3d731fc665962a4c330338a2c663c330be26","modified":1671245376047},{"_id":"public/static/js/page.a02618ad.js","hash":"db775fbfbaa1cf8bbf4cc4f2b0a869519d508e3a","modified":1671245376047},{"_id":"public/static/js/tags.2ad613f5.js","hash":"4f49139e435788710115fc884dc26a5b1e0d4833","modified":1671245376047},{"_id":"public/static/js/result.39470350.js","hash":"f6f5ab2ca7274dad169ec600a419d1a2aeb2347c","modified":1671245376047},{"_id":"public/static/js/post.cebfbaa4.js","hash":"53586f9dab5886a366e9397eb17088e74af5cde1","modified":1671245376047},{"_id":"public/static/css/app.0d31776f.css","hash":"43b43acd76bd8dc22f34cc49c7e026c45c3a5004","modified":1671245376047},{"_id":"public/static/js/app.6d2c358d.js","hash":"e176c20c22ce36e38935f463977e9b89b281c715","modified":1671245376047},{"_id":"public/static/js/chunk-libs.dc6146cd.js","hash":"534266637d09abf39278f4d3a21bd36728740105","modified":1671245376047}],"Category":[{"name":"技术","_id":"clbrcchl50003qkiq66td1f7m"},{"name":"分布式","parent":"clbrcchl50003qkiq66td1f7m","_id":"clbrcchld000eqkiq4b6031ag"},{"name":"开发常用","parent":"clbrcchl50003qkiq66td1f7m","_id":"clbrcchlf000lqkiq808pfh53"},{"name":"设计模式","parent":"clbrcchl50003qkiq66td1f7m","_id":"clbrcchlg000qqkiq36vsacjh"},{"name":"中间件","parent":"clbrcchld000eqkiq4b6031ag","_id":"clbrcchli0013qkiq3h0f5phe"},{"name":"开发常用","parent":"clbrcchlg000qqkiq36vsacjh","_id":"clbrcchlj0017qkiq74bf8i6j"},{"name":"数据库","parent":"clbrcchli0013qkiq3h0f5phe","_id":"clbrcchlk001aqkiq2pzoeuis"},{"name":"分布式链路追踪","parent":"clbrcchli0013qkiq3h0f5phe","_id":"clbrcchlk001eqkiq4y1d0hnn"}],"Data":[],"Page":[{"_content":"## 这是About页面","source":"about/index.md","raw":"## 这是About页面","date":"2022-11-02T00:29:49.809Z","updated":"2022-11-02T00:29:49.809Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"clbrcchks0000qkiq6tin6heh","content":"<h2 id=\"这是About页面\"><a href=\"#这是About页面\" class=\"headerlink\" title=\"这是About页面\"></a>这是About页面</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"这是About页面\"><a href=\"#这是About页面\" class=\"headerlink\" title=\"这是About页面\"></a>这是About页面</h2>"}],"Post":[{"title":"MongoDB","description":"MongoDB数据库","_content":"\n\n\n# MongoDB\n\n## 概念\n\n一种非关系型数据库(NoSQL)\n\n应用场景：高并发的、需要低延时的，对事务要求、安全性不是很高的场景。\n\n## 和Reids的区别？\n\nRedis主要把数据存储在内存中，其“缓存”的性质远大于其“数据存储“的性质，其中数据的增删改查也只是像变量操作一样简单；\n\nMongoDB却是一个“存储数据”的系统，增删改查可以添加很多条件，就像SQL数据库一样灵活，这一点在面试的时候很受用。\n\n## 术语对比\n\n![image-20221122105852998](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122105852998.png)\n\n## Windows安装/启动\n\n下载zip格式的mongoDB包\n\n```\nhttps://www.mongodb.com/try/download/community\n```\n\n下载之后解压，在根目录下创建文件夹data/db\n\n![image-20221122105904463](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122105904463.png)\n\n进入bin目录下进入cmd\n\n执行如下\n\n```cmd\nmongod --dbpath=../data/db  #指定数据库存放位置\n```\n\n重新进入bin下的cmd，执行如下：\n\n```cmd\nmongo 或者 mongo --host=127.0.0.1 --port=27017 #27017是默认端口号\n```\n\n## Linux安装/启动\n\n<img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122105922151.png\" alt=\"image-20221122105922151\" style=\"zoom:50%;\" />\n\n配置内容如下：\n\n```yaml\nsystemLog:\n\t#MongoDB发送所有日志输出的目标指定为文件\n\t# #The path of the 1log file to which mongod or mongos should send all diagnostic 1ogging information\n\tdestination: file\n    #mongod或mongos应向其发送所有诊断日志记录信息的日志文件的路径\n    path: \"/mongodb/sing1e/1og/mongod. log\"\n    #当mongos或mongod实例重新启动时，mongos或mongod会将新条目附加到现有日志文件的末尾。\n    logAppend: true\nstorage:\n    #mongod实例存储其数据的目录。storage . dbpath设置仅适用于mongod.\n    ##The directory where the mongod instance stores its data. Default value is \"/data/db\".\n    dbpath: \"/mongodb/sing1e/data/db\"\n    journal:\n        #启用或禁用持久性日志以确保数据文件保持有效和可恢复。\n        enabled: true\nprocessManagement:\n    #启用在后台运行mongos或mongod进程的守护进程模式。\n    fork: true\nnet:\n    #服务实例绑定的IP，默认是localhost\n    bindIp: 1oca1host,192.168.0.2\n    #绑定的端口，默认是27017\n    port: 27017\n```\n\n启动：\n\n```cmd\n/usr/local/mongodb/bin/mongod -f /mongodb/single/mongod.conf\n```\n\n结果应该是Successfully\n\n然后就可以使用可视化工具或者Shell命令行进行连接，如果连接不上，尝试关闭防火墙\n\n```cmd\n#查看防火墙状态 systemctl status firewalld \n#临时关闭防火墙 systemctl stop firewalld \n#开机禁止启动防火墙 systemctl disable firewalld\n```\n\n关闭数据库：\n\n```cmd\n//客户端登录服务，注意，这里通过localhost登录，如果需要远程登录，必须先登录认证才行。 \nmongo --port 27017 //#切换到admin库 \nuse admin //关闭服务 \ndb.shutdownServer()\n```\n\n## 图形化界面\n\n到官网下载Compass，直接运行即可\n\n## 使用\n\n### 数据库\n\n```cmd\nuse 数据库名称 #选择/创建\n\nshow dbs #查看数据库(磁盘里的)\n\ndb #查看正在使用的数据库\n\ndb.dropDatabase() #删除数据库 db指的是数据库对象，操作的是当前使用的数据库\n```\n\n### 集合\n\n```cmd\ndb.createCollection(\"My\") #创建一个叫My的集合\n\nshow collections #查看所有集合\n\ndb.集合名.drop() #删除某个集合\n```\n\n### 文档\n\n##### **文档的id值必须为字符串!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!不是数字**\n\n#### 查询/插入\n\n##### 普通查询\n\n```cmd\ndb.集合名.insert({\"name\":\"value\"}) #单条数据的插入，若此时集合未被创建，会隐式地创建好集合\n\ndb.集合名.insertMany([\n    {\n        xxx:xxx\n    },\n    {\n        xxx:xxx\n    },\n])  #插入多条数据\n\ndb.集合名.find() #查看集合内容\n\ndb.集合名.find({\"name\":\"张三\"}) #查询名字为张三的内容\n\ndb.集合名.findOne() / db.集合名.findOne({xxx:xxx})#查询一条数据，类似于limit\n\ndb.集合名.find({查询的条件},{字段1:1,字段2:0})#只显示部分字段,显示字段1，不显示字段2，以逗号分割\n```\n\n##### 统计查询 count\n\n```cmd\ndb.comment.count() #查询所有数据数量\n\ndb.comment.count({条件})\n```\n\n##### 分页查询 limt/skip\n\n```cmd\ndb.comment.find().limit(3) #限制查询数量\n```\n\n```cmd\ndb.comment.find().limit(2).skip(2)\n```\n\n##### 排序 sort\n\n```cmd\ndb.comment.find().sort({xxx:1/0}) #1为升序，-1为降序\n```\n\n##### 正则查询 / /\n\n```cmd\ndb.comment.find({字段:/正则表达式/})\n```\n\n##### 比较查询 gt/lt\n\n```cmd\ndb.comment.find({xxx:{$gt:value}})\n\ngt：大于\ngte：大于等于\n\nlt：小于\nlte：小于等于\n```\n\n##### 包含查询 in/nin\n\n```cmd\ndb.comment.find({xxx:{$in:[\"value1\",\"value2\"]}}) #包含\n\ndb.comment.find({xxx:{$nin:[\"value1\",\"value2\"]}}) #不包含\n```\n\n##### 多条件查询 and/or\n\n```cmd\ndb.comment.find({$and:[{\"xxx\":\"value\"},{\"xxx2\":{$gt:NumberInt(233)}}]})\n\n\ndb.comment.find({$or:[{\"xxx\":\"value\"},{\"xxx2\":{$gt:NumberInt(233)}}]})\n```\n\n\n\n#### Try catch包裹插入语句\n\n![image-20220714132811240](http://www.clewm.top/MarkDownImages/image-20220714132811240.png)\n\n可以知道哪条数据插入失败\n\n#### 更新\n\n如下是覆盖更新\n\n```cmd\ndb.comment.update({更新的条件},{更新的内容})\n```\n\n如下才是局部更新\n\n```cmd\ndb.comment.update({更新的条件},{$set:{更新的内容}})\n```\n\n默认是只修改找到的第一条数据，若想修改全部\n\n```cmd\ndb.comment.update({更新的条件},{$set:{更新的内容}},{multi:true})\n```\n\n使某个字段自增1\n\n```cmd\ndb.comment.update({更新的条件},{$inc:{XXX:NumberInt(1)}})\n```\n\n#### 删除\n\n```cmd\ndb.comment.remove({删除的条件})\n\ndb.comment.remove({}) #删除全部\n\n#以上是过时的方法，下面是新的\nuse 数据库名\ndb.文档名.deleteOne({\"uid\":\"123\"})\n\ndb.文档名.deleteMany({\"sex\":\"男\"}) #删多个满足条件的\n\ndb.文档名.deleteMany({}) #删所有\n```\n\n### 索引\n\n```cmd\ndb.comment.getIndexs() #查看索引\n\ndb.comment.createIndex(keys,options) #查看索引 options里常用的是name：指定索引名称和unique指定是否是唯一索引\n```\n\n#### 单字段索引\n\n```cmd\ndb.comment.createIndex({\"userId\":1}) #给userId字段添加一个升序的单字段索引\n```\n\n#### 复合索引\n\n```cmd\ndb.comment.createIndex({\"userId\":1,\"age\":-1}) #给userId字段添加一个升序的索引,age为降序的索引\n```\n\n#### 其他索引\n\n<img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122105945634.png\" alt=\"image-20221122105945634\" style=\"zoom:67%;\" />\n\n#### 删除索引\n\n```cmd\ndb.comment.dropIndex({\"userId\":1}) #删除userId字段的升序的索引\n\ndb.comment.dropIndexes() #删除所有索引\n```\n\n### 性能检查\n\n```cmd\ndb.comment.find(xxx).explain()\n```\n\n#### 覆盖查询\n\n类似于MySQL中的覆盖索引\n\n就是查询的字段正是索引的字段\n\n\n\n## 整合到SpringBoot\n\n依赖：\n\n```xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-mongodb</artifactId>\n        </dependency>\n```\n\n编写配置：\n\n```yaml\n# 应用名称\nspring:\n  application:\n    name: mongotest\n  data:\n    mongodb:\n      database: mytest\n      host: 127.0.0.1\n      port: 27017\n#      username: 如果有\n#      password: 如果有\nserver:\n  port: 8990\n```\n\n创建实体类，并指定文档名\n\n```java\n@Document(collection = \"user\") //可以省略，省略的话默认文档名为实体类的小写名\n@Data\npublic class User {\n\n    //mongoDB里自带的id为字符串！！！！！！！！！！！！\n    public String id;\n\n    @Field(\"name\")\n    public String name;\n\n    public Integer sex;\n\n//    @Indexed 添加单字段索引\n    public Long compId;\n\n    public String phone;\n}\n```\n\n注入模板类：\n\n```java\n    @Autowired\n    private MongoTemplate mongoTemplate;\n```\n\n### 基本增添：\n\n```java\n    @GetMapping(\"/save\")\n    public String save() {\n        User user = new User();\n        user.setName(\"CleWM\");\n        user.setSex(1);\n        user.setCompId(10001L);\n        user.setPhone(\"18083822909\");\n        //insert和save的区别？\n        //insert: 若新增数据的主键已经存在，则会抛 org.springframework.dao.DuplicateKeyException 异常提示主键重复，不保存当前数据。\n        //save: 若新增数据的主键已经存在，则会对当前已经存在的数据进行修改操作\n        User insert = mongoTemplate.insert(user);\n        return insert.getId().toString();\n    }\n```\n\n### 基本查询：\n\n```java\n    @GetMapping(\"/get\")\n    public String get() {\n        Query query = new Query();\n        query.addCriteria(Criteria.where(\"name\").is(\"CleWM\"));\n        List<User> res = mongoTemplate.find(query, User.class);\n        return res.get(0).toString();\n    }\n```\n\n### 基本删除：\n\n```java\nmongoTemplate.remove(obj)\n    \n//根据条件删除\nQuery query = new Query();\nquery.addCriteria(Criteria.where(\"id\").is(commentId));\nComment res = mongoTemplate.findAndRemove(query, Comment.class);\n```\n\n### 基本修改：\n\n```java\nQuery query = new Query();\nquery.addCriteria(Criteria.where(\"id\").is(commentId));\nComment res = mongoTemplate.findAndRemove(query, Comment.class);\n\nUpdate update = new Update();\nupdate.set(\"key\",\"value\");\nmongoTemplate.updateFirst(query,update,Comment.class);\n```\n\n### 排序\n\n```java\n//实体类的字段需要实现Comparable接口，并重写方法，如下，注意，o和this的位置不能颠倒，否则升序和降序也会反过来。\n    @Override\n    public int compareTo(@NotNull Comment o) {\n        return o.getLikes().compareTo(this.getLikes());\n    }\n```\n\n```java\n    @Override\n    public List getList(CommentFuzzySearchDTO commentFuzzySearchDTO) {\n        Query query = new Query().with(Sort.by(\"likes\").descending()); //降序排序\n        query.addCriteria(Criteria.where(\"item_id\").is(commentFuzzySearchDTO.getItemId()));\n        Integer curr = commentFuzzySearchDTO.getCurr();\n        Integer pageSize = commentFuzzySearchDTO.getPageSize();\n        List<Comment> commentList = mongoTemplate.find(query, Comment.class)\n                .stream().skip((curr - 1) * pageSize).limit(pageSize).sorted().collect(Collectors.toList());\n        return commentList;\n    }\n```\n\n### 自增\n\n```java\npublic Boolean likeInc(String commentId) {\n    Query query = new Query();\n    query.addCriteria(Criteria.where(\"_id\").is(commentId));\n    Update update = new Update();\n    update.inc(\"likes\");\n    UpdateResult updateResult = mongoTemplate.updateFirst(query, update, Comment.class);\n    long modifiedCount = updateResult.getModifiedCount();\n    return modifiedCount > 0;\n}\n```\n\n### 更多使用\n\n参考https://blog.csdn.net/qq_36331657/article/details/116431191\n\nhttps://blog.csdn.net/weixin_40392053/article/details/120265736\n\n\n\n## 副本集\n\n三个节点：\n\n- 主节点，Primary\n- 从节点，Slave \n- 选举节点，A也属于Slave，无法成为主节点\n\n### 触发选举条件：\n\n<img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122110005391.png\" alt=\"image-20221122110005391\" style=\"zoom:67%;\" />\n","source":"_posts/Java/MongDB.md","raw":"---\ntitle: MongoDB\n\ncategories: \n- 技术\n- 分布式\n- 中间件\n- 数据库\n\ntags:\n- Java\n- 分布式存储引擎\n- 高并发\n\ndescription: MongoDB数据库\n---\n\n\n\n# MongoDB\n\n## 概念\n\n一种非关系型数据库(NoSQL)\n\n应用场景：高并发的、需要低延时的，对事务要求、安全性不是很高的场景。\n\n## 和Reids的区别？\n\nRedis主要把数据存储在内存中，其“缓存”的性质远大于其“数据存储“的性质，其中数据的增删改查也只是像变量操作一样简单；\n\nMongoDB却是一个“存储数据”的系统，增删改查可以添加很多条件，就像SQL数据库一样灵活，这一点在面试的时候很受用。\n\n## 术语对比\n\n![image-20221122105852998](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122105852998.png)\n\n## Windows安装/启动\n\n下载zip格式的mongoDB包\n\n```\nhttps://www.mongodb.com/try/download/community\n```\n\n下载之后解压，在根目录下创建文件夹data/db\n\n![image-20221122105904463](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122105904463.png)\n\n进入bin目录下进入cmd\n\n执行如下\n\n```cmd\nmongod --dbpath=../data/db  #指定数据库存放位置\n```\n\n重新进入bin下的cmd，执行如下：\n\n```cmd\nmongo 或者 mongo --host=127.0.0.1 --port=27017 #27017是默认端口号\n```\n\n## Linux安装/启动\n\n<img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122105922151.png\" alt=\"image-20221122105922151\" style=\"zoom:50%;\" />\n\n配置内容如下：\n\n```yaml\nsystemLog:\n\t#MongoDB发送所有日志输出的目标指定为文件\n\t# #The path of the 1log file to which mongod or mongos should send all diagnostic 1ogging information\n\tdestination: file\n    #mongod或mongos应向其发送所有诊断日志记录信息的日志文件的路径\n    path: \"/mongodb/sing1e/1og/mongod. log\"\n    #当mongos或mongod实例重新启动时，mongos或mongod会将新条目附加到现有日志文件的末尾。\n    logAppend: true\nstorage:\n    #mongod实例存储其数据的目录。storage . dbpath设置仅适用于mongod.\n    ##The directory where the mongod instance stores its data. Default value is \"/data/db\".\n    dbpath: \"/mongodb/sing1e/data/db\"\n    journal:\n        #启用或禁用持久性日志以确保数据文件保持有效和可恢复。\n        enabled: true\nprocessManagement:\n    #启用在后台运行mongos或mongod进程的守护进程模式。\n    fork: true\nnet:\n    #服务实例绑定的IP，默认是localhost\n    bindIp: 1oca1host,192.168.0.2\n    #绑定的端口，默认是27017\n    port: 27017\n```\n\n启动：\n\n```cmd\n/usr/local/mongodb/bin/mongod -f /mongodb/single/mongod.conf\n```\n\n结果应该是Successfully\n\n然后就可以使用可视化工具或者Shell命令行进行连接，如果连接不上，尝试关闭防火墙\n\n```cmd\n#查看防火墙状态 systemctl status firewalld \n#临时关闭防火墙 systemctl stop firewalld \n#开机禁止启动防火墙 systemctl disable firewalld\n```\n\n关闭数据库：\n\n```cmd\n//客户端登录服务，注意，这里通过localhost登录，如果需要远程登录，必须先登录认证才行。 \nmongo --port 27017 //#切换到admin库 \nuse admin //关闭服务 \ndb.shutdownServer()\n```\n\n## 图形化界面\n\n到官网下载Compass，直接运行即可\n\n## 使用\n\n### 数据库\n\n```cmd\nuse 数据库名称 #选择/创建\n\nshow dbs #查看数据库(磁盘里的)\n\ndb #查看正在使用的数据库\n\ndb.dropDatabase() #删除数据库 db指的是数据库对象，操作的是当前使用的数据库\n```\n\n### 集合\n\n```cmd\ndb.createCollection(\"My\") #创建一个叫My的集合\n\nshow collections #查看所有集合\n\ndb.集合名.drop() #删除某个集合\n```\n\n### 文档\n\n##### **文档的id值必须为字符串!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!不是数字**\n\n#### 查询/插入\n\n##### 普通查询\n\n```cmd\ndb.集合名.insert({\"name\":\"value\"}) #单条数据的插入，若此时集合未被创建，会隐式地创建好集合\n\ndb.集合名.insertMany([\n    {\n        xxx:xxx\n    },\n    {\n        xxx:xxx\n    },\n])  #插入多条数据\n\ndb.集合名.find() #查看集合内容\n\ndb.集合名.find({\"name\":\"张三\"}) #查询名字为张三的内容\n\ndb.集合名.findOne() / db.集合名.findOne({xxx:xxx})#查询一条数据，类似于limit\n\ndb.集合名.find({查询的条件},{字段1:1,字段2:0})#只显示部分字段,显示字段1，不显示字段2，以逗号分割\n```\n\n##### 统计查询 count\n\n```cmd\ndb.comment.count() #查询所有数据数量\n\ndb.comment.count({条件})\n```\n\n##### 分页查询 limt/skip\n\n```cmd\ndb.comment.find().limit(3) #限制查询数量\n```\n\n```cmd\ndb.comment.find().limit(2).skip(2)\n```\n\n##### 排序 sort\n\n```cmd\ndb.comment.find().sort({xxx:1/0}) #1为升序，-1为降序\n```\n\n##### 正则查询 / /\n\n```cmd\ndb.comment.find({字段:/正则表达式/})\n```\n\n##### 比较查询 gt/lt\n\n```cmd\ndb.comment.find({xxx:{$gt:value}})\n\ngt：大于\ngte：大于等于\n\nlt：小于\nlte：小于等于\n```\n\n##### 包含查询 in/nin\n\n```cmd\ndb.comment.find({xxx:{$in:[\"value1\",\"value2\"]}}) #包含\n\ndb.comment.find({xxx:{$nin:[\"value1\",\"value2\"]}}) #不包含\n```\n\n##### 多条件查询 and/or\n\n```cmd\ndb.comment.find({$and:[{\"xxx\":\"value\"},{\"xxx2\":{$gt:NumberInt(233)}}]})\n\n\ndb.comment.find({$or:[{\"xxx\":\"value\"},{\"xxx2\":{$gt:NumberInt(233)}}]})\n```\n\n\n\n#### Try catch包裹插入语句\n\n![image-20220714132811240](http://www.clewm.top/MarkDownImages/image-20220714132811240.png)\n\n可以知道哪条数据插入失败\n\n#### 更新\n\n如下是覆盖更新\n\n```cmd\ndb.comment.update({更新的条件},{更新的内容})\n```\n\n如下才是局部更新\n\n```cmd\ndb.comment.update({更新的条件},{$set:{更新的内容}})\n```\n\n默认是只修改找到的第一条数据，若想修改全部\n\n```cmd\ndb.comment.update({更新的条件},{$set:{更新的内容}},{multi:true})\n```\n\n使某个字段自增1\n\n```cmd\ndb.comment.update({更新的条件},{$inc:{XXX:NumberInt(1)}})\n```\n\n#### 删除\n\n```cmd\ndb.comment.remove({删除的条件})\n\ndb.comment.remove({}) #删除全部\n\n#以上是过时的方法，下面是新的\nuse 数据库名\ndb.文档名.deleteOne({\"uid\":\"123\"})\n\ndb.文档名.deleteMany({\"sex\":\"男\"}) #删多个满足条件的\n\ndb.文档名.deleteMany({}) #删所有\n```\n\n### 索引\n\n```cmd\ndb.comment.getIndexs() #查看索引\n\ndb.comment.createIndex(keys,options) #查看索引 options里常用的是name：指定索引名称和unique指定是否是唯一索引\n```\n\n#### 单字段索引\n\n```cmd\ndb.comment.createIndex({\"userId\":1}) #给userId字段添加一个升序的单字段索引\n```\n\n#### 复合索引\n\n```cmd\ndb.comment.createIndex({\"userId\":1,\"age\":-1}) #给userId字段添加一个升序的索引,age为降序的索引\n```\n\n#### 其他索引\n\n<img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122105945634.png\" alt=\"image-20221122105945634\" style=\"zoom:67%;\" />\n\n#### 删除索引\n\n```cmd\ndb.comment.dropIndex({\"userId\":1}) #删除userId字段的升序的索引\n\ndb.comment.dropIndexes() #删除所有索引\n```\n\n### 性能检查\n\n```cmd\ndb.comment.find(xxx).explain()\n```\n\n#### 覆盖查询\n\n类似于MySQL中的覆盖索引\n\n就是查询的字段正是索引的字段\n\n\n\n## 整合到SpringBoot\n\n依赖：\n\n```xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-mongodb</artifactId>\n        </dependency>\n```\n\n编写配置：\n\n```yaml\n# 应用名称\nspring:\n  application:\n    name: mongotest\n  data:\n    mongodb:\n      database: mytest\n      host: 127.0.0.1\n      port: 27017\n#      username: 如果有\n#      password: 如果有\nserver:\n  port: 8990\n```\n\n创建实体类，并指定文档名\n\n```java\n@Document(collection = \"user\") //可以省略，省略的话默认文档名为实体类的小写名\n@Data\npublic class User {\n\n    //mongoDB里自带的id为字符串！！！！！！！！！！！！\n    public String id;\n\n    @Field(\"name\")\n    public String name;\n\n    public Integer sex;\n\n//    @Indexed 添加单字段索引\n    public Long compId;\n\n    public String phone;\n}\n```\n\n注入模板类：\n\n```java\n    @Autowired\n    private MongoTemplate mongoTemplate;\n```\n\n### 基本增添：\n\n```java\n    @GetMapping(\"/save\")\n    public String save() {\n        User user = new User();\n        user.setName(\"CleWM\");\n        user.setSex(1);\n        user.setCompId(10001L);\n        user.setPhone(\"18083822909\");\n        //insert和save的区别？\n        //insert: 若新增数据的主键已经存在，则会抛 org.springframework.dao.DuplicateKeyException 异常提示主键重复，不保存当前数据。\n        //save: 若新增数据的主键已经存在，则会对当前已经存在的数据进行修改操作\n        User insert = mongoTemplate.insert(user);\n        return insert.getId().toString();\n    }\n```\n\n### 基本查询：\n\n```java\n    @GetMapping(\"/get\")\n    public String get() {\n        Query query = new Query();\n        query.addCriteria(Criteria.where(\"name\").is(\"CleWM\"));\n        List<User> res = mongoTemplate.find(query, User.class);\n        return res.get(0).toString();\n    }\n```\n\n### 基本删除：\n\n```java\nmongoTemplate.remove(obj)\n    \n//根据条件删除\nQuery query = new Query();\nquery.addCriteria(Criteria.where(\"id\").is(commentId));\nComment res = mongoTemplate.findAndRemove(query, Comment.class);\n```\n\n### 基本修改：\n\n```java\nQuery query = new Query();\nquery.addCriteria(Criteria.where(\"id\").is(commentId));\nComment res = mongoTemplate.findAndRemove(query, Comment.class);\n\nUpdate update = new Update();\nupdate.set(\"key\",\"value\");\nmongoTemplate.updateFirst(query,update,Comment.class);\n```\n\n### 排序\n\n```java\n//实体类的字段需要实现Comparable接口，并重写方法，如下，注意，o和this的位置不能颠倒，否则升序和降序也会反过来。\n    @Override\n    public int compareTo(@NotNull Comment o) {\n        return o.getLikes().compareTo(this.getLikes());\n    }\n```\n\n```java\n    @Override\n    public List getList(CommentFuzzySearchDTO commentFuzzySearchDTO) {\n        Query query = new Query().with(Sort.by(\"likes\").descending()); //降序排序\n        query.addCriteria(Criteria.where(\"item_id\").is(commentFuzzySearchDTO.getItemId()));\n        Integer curr = commentFuzzySearchDTO.getCurr();\n        Integer pageSize = commentFuzzySearchDTO.getPageSize();\n        List<Comment> commentList = mongoTemplate.find(query, Comment.class)\n                .stream().skip((curr - 1) * pageSize).limit(pageSize).sorted().collect(Collectors.toList());\n        return commentList;\n    }\n```\n\n### 自增\n\n```java\npublic Boolean likeInc(String commentId) {\n    Query query = new Query();\n    query.addCriteria(Criteria.where(\"_id\").is(commentId));\n    Update update = new Update();\n    update.inc(\"likes\");\n    UpdateResult updateResult = mongoTemplate.updateFirst(query, update, Comment.class);\n    long modifiedCount = updateResult.getModifiedCount();\n    return modifiedCount > 0;\n}\n```\n\n### 更多使用\n\n参考https://blog.csdn.net/qq_36331657/article/details/116431191\n\nhttps://blog.csdn.net/weixin_40392053/article/details/120265736\n\n\n\n## 副本集\n\n三个节点：\n\n- 主节点，Primary\n- 从节点，Slave \n- 选举节点，A也属于Slave，无法成为主节点\n\n### 触发选举条件：\n\n<img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122110005391.png\" alt=\"image-20221122110005391\" style=\"zoom:67%;\" />\n","slug":"Java/MongDB","published":1,"date":"2022-07-14T02:40:19.176Z","updated":"2022-11-22T03:00:45.886Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbrcchkv0001qkiq7i6i3td4","content":"<h1 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>一种非关系型数据库(NoSQL)</p>\n<p>应用场景：高并发的、需要低延时的，对事务要求、安全性不是很高的场景。</p>\n<h2 id=\"和Reids的区别？\"><a href=\"#和Reids的区别？\" class=\"headerlink\" title=\"和Reids的区别？\"></a>和Reids的区别？</h2><p>Redis主要把数据存储在内存中，其“缓存”的性质远大于其“数据存储“的性质，其中数据的增删改查也只是像变量操作一样简单；</p>\n<p>MongoDB却是一个“存储数据”的系统，增删改查可以添加很多条件，就像SQL数据库一样灵活，这一点在面试的时候很受用。</p>\n<h2 id=\"术语对比\"><a href=\"#术语对比\" class=\"headerlink\" title=\"术语对比\"></a>术语对比</h2><p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122105852998.png\" alt=\"image-20221122105852998\"></p>\n<h2 id=\"Windows安装-启动\"><a href=\"#Windows安装-启动\" class=\"headerlink\" title=\"Windows安装/启动\"></a>Windows安装/启动</h2><p>下载zip格式的mongoDB包</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;www.mongodb.com&#x2F;try&#x2F;download&#x2F;community</code></pre>\n\n<p>下载之后解压，在根目录下创建文件夹data/db</p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122105904463.png\" alt=\"image-20221122105904463\"></p>\n<p>进入bin目录下进入cmd</p>\n<p>执行如下</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">mongod --dbpath&#x3D;..&#x2F;data&#x2F;db  #指定数据库存放位置</code></pre>\n\n<p>重新进入bin下的cmd，执行如下：</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">mongo 或者 mongo --host&#x3D;127.0.0.1 --port&#x3D;27017 #27017是默认端口号</code></pre>\n\n<h2 id=\"Linux安装-启动\"><a href=\"#Linux安装-启动\" class=\"headerlink\" title=\"Linux安装/启动\"></a>Linux安装/启动</h2><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122105922151.png\" alt=\"image-20221122105922151\" style=\"zoom:50%;\" />\n\n<p>配置内容如下：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">systemLog:\n\t#MongoDB发送所有日志输出的目标指定为文件\n\t# #The path of the 1log file to which mongod or mongos should send all diagnostic 1ogging information\n\tdestination: file\n    #mongod或mongos应向其发送所有诊断日志记录信息的日志文件的路径\n    path: &quot;&#x2F;mongodb&#x2F;sing1e&#x2F;1og&#x2F;mongod. log&quot;\n    #当mongos或mongod实例重新启动时，mongos或mongod会将新条目附加到现有日志文件的末尾。\n    logAppend: true\nstorage:\n    #mongod实例存储其数据的目录。storage . dbpath设置仅适用于mongod.\n    ##The directory where the mongod instance stores its data. Default value is &quot;&#x2F;data&#x2F;db&quot;.\n    dbpath: &quot;&#x2F;mongodb&#x2F;sing1e&#x2F;data&#x2F;db&quot;\n    journal:\n        #启用或禁用持久性日志以确保数据文件保持有效和可恢复。\n        enabled: true\nprocessManagement:\n    #启用在后台运行mongos或mongod进程的守护进程模式。\n    fork: true\nnet:\n    #服务实例绑定的IP，默认是localhost\n    bindIp: 1oca1host,192.168.0.2\n    #绑定的端口，默认是27017\n    port: 27017</code></pre>\n\n<p>启动：</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;bin&#x2F;mongod -f &#x2F;mongodb&#x2F;single&#x2F;mongod.conf</code></pre>\n\n<p>结果应该是Successfully</p>\n<p>然后就可以使用可视化工具或者Shell命令行进行连接，如果连接不上，尝试关闭防火墙</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">#查看防火墙状态 systemctl status firewalld \n#临时关闭防火墙 systemctl stop firewalld \n#开机禁止启动防火墙 systemctl disable firewalld</code></pre>\n\n<p>关闭数据库：</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">&#x2F;&#x2F;客户端登录服务，注意，这里通过localhost登录，如果需要远程登录，必须先登录认证才行。 \nmongo --port 27017 &#x2F;&#x2F;#切换到admin库 \nuse admin &#x2F;&#x2F;关闭服务 \ndb.shutdownServer()</code></pre>\n\n<h2 id=\"图形化界面\"><a href=\"#图形化界面\" class=\"headerlink\" title=\"图形化界面\"></a>图形化界面</h2><p>到官网下载Compass，直接运行即可</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">use 数据库名称 #选择&#x2F;创建\n\nshow dbs #查看数据库(磁盘里的)\n\ndb #查看正在使用的数据库\n\ndb.dropDatabase() #删除数据库 db指的是数据库对象，操作的是当前使用的数据库</code></pre>\n\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.createCollection(&quot;My&quot;) #创建一个叫My的集合\n\nshow collections #查看所有集合\n\ndb.集合名.drop() #删除某个集合</code></pre>\n\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><h5 id=\"文档的id值必须为字符串-不是数字\"><a href=\"#文档的id值必须为字符串-不是数字\" class=\"headerlink\" title=\"文档的id值必须为字符串!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!不是数字\"></a><strong>文档的id值必须为字符串!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!不是数字</strong></h5><h4 id=\"查询-插入\"><a href=\"#查询-插入\" class=\"headerlink\" title=\"查询/插入\"></a>查询/插入</h4><h5 id=\"普通查询\"><a href=\"#普通查询\" class=\"headerlink\" title=\"普通查询\"></a>普通查询</h5><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.集合名.insert(&#123;&quot;name&quot;:&quot;value&quot;&#125;) #单条数据的插入，若此时集合未被创建，会隐式地创建好集合\n\ndb.集合名.insertMany([\n    &#123;\n        xxx:xxx\n    &#125;,\n    &#123;\n        xxx:xxx\n    &#125;,\n])  #插入多条数据\n\ndb.集合名.find() #查看集合内容\n\ndb.集合名.find(&#123;&quot;name&quot;:&quot;张三&quot;&#125;) #查询名字为张三的内容\n\ndb.集合名.findOne() &#x2F; db.集合名.findOne(&#123;xxx:xxx&#125;)#查询一条数据，类似于limit\n\ndb.集合名.find(&#123;查询的条件&#125;,&#123;字段1:1,字段2:0&#125;)#只显示部分字段,显示字段1，不显示字段2，以逗号分割</code></pre>\n\n<h5 id=\"统计查询-count\"><a href=\"#统计查询-count\" class=\"headerlink\" title=\"统计查询 count\"></a>统计查询 count</h5><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.count() #查询所有数据数量\n\ndb.comment.count(&#123;条件&#125;)</code></pre>\n\n<h5 id=\"分页查询-limt-skip\"><a href=\"#分页查询-limt-skip\" class=\"headerlink\" title=\"分页查询 limt/skip\"></a>分页查询 limt/skip</h5><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.find().limit(3) #限制查询数量</code></pre>\n\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.find().limit(2).skip(2)</code></pre>\n\n<h5 id=\"排序-sort\"><a href=\"#排序-sort\" class=\"headerlink\" title=\"排序 sort\"></a>排序 sort</h5><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.find().sort(&#123;xxx:1&#x2F;0&#125;) #1为升序，-1为降序</code></pre>\n\n<h5 id=\"正则查询\"><a href=\"#正则查询\" class=\"headerlink\" title=\"正则查询 / /\"></a>正则查询 / /</h5><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.find(&#123;字段:&#x2F;正则表达式&#x2F;&#125;)</code></pre>\n\n<h5 id=\"比较查询-gt-lt\"><a href=\"#比较查询-gt-lt\" class=\"headerlink\" title=\"比较查询 gt/lt\"></a>比较查询 gt/lt</h5><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.find(&#123;xxx:&#123;$gt:value&#125;&#125;)\n\ngt：大于\ngte：大于等于\n\nlt：小于\nlte：小于等于</code></pre>\n\n<h5 id=\"包含查询-in-nin\"><a href=\"#包含查询-in-nin\" class=\"headerlink\" title=\"包含查询 in/nin\"></a>包含查询 in/nin</h5><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.find(&#123;xxx:&#123;$in:[&quot;value1&quot;,&quot;value2&quot;]&#125;&#125;) #包含\n\ndb.comment.find(&#123;xxx:&#123;$nin:[&quot;value1&quot;,&quot;value2&quot;]&#125;&#125;) #不包含</code></pre>\n\n<h5 id=\"多条件查询-and-or\"><a href=\"#多条件查询-and-or\" class=\"headerlink\" title=\"多条件查询 and/or\"></a>多条件查询 and/or</h5><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.find(&#123;$and:[&#123;&quot;xxx&quot;:&quot;value&quot;&#125;,&#123;&quot;xxx2&quot;:&#123;$gt:NumberInt(233)&#125;&#125;]&#125;)\n\n\ndb.comment.find(&#123;$or:[&#123;&quot;xxx&quot;:&quot;value&quot;&#125;,&#123;&quot;xxx2&quot;:&#123;$gt:NumberInt(233)&#125;&#125;]&#125;)</code></pre>\n\n\n\n<h4 id=\"Try-catch包裹插入语句\"><a href=\"#Try-catch包裹插入语句\" class=\"headerlink\" title=\"Try catch包裹插入语句\"></a>Try catch包裹插入语句</h4><p><img src=\"http://www.clewm.top/MarkDownImages/image-20220714132811240.png\" alt=\"image-20220714132811240\"></p>\n<p>可以知道哪条数据插入失败</p>\n<h4 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h4><p>如下是覆盖更新</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.update(&#123;更新的条件&#125;,&#123;更新的内容&#125;)</code></pre>\n\n<p>如下才是局部更新</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.update(&#123;更新的条件&#125;,&#123;$set:&#123;更新的内容&#125;&#125;)</code></pre>\n\n<p>默认是只修改找到的第一条数据，若想修改全部</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.update(&#123;更新的条件&#125;,&#123;$set:&#123;更新的内容&#125;&#125;,&#123;multi:true&#125;)</code></pre>\n\n<p>使某个字段自增1</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.update(&#123;更新的条件&#125;,&#123;$inc:&#123;XXX:NumberInt(1)&#125;&#125;)</code></pre>\n\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.remove(&#123;删除的条件&#125;)\n\ndb.comment.remove(&#123;&#125;) #删除全部\n\n#以上是过时的方法，下面是新的\nuse 数据库名\ndb.文档名.deleteOne(&#123;&quot;uid&quot;:&quot;123&quot;&#125;)\n\ndb.文档名.deleteMany(&#123;&quot;sex&quot;:&quot;男&quot;&#125;) #删多个满足条件的\n\ndb.文档名.deleteMany(&#123;&#125;) #删所有</code></pre>\n\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.getIndexs() #查看索引\n\ndb.comment.createIndex(keys,options) #查看索引 options里常用的是name：指定索引名称和unique指定是否是唯一索引</code></pre>\n\n<h4 id=\"单字段索引\"><a href=\"#单字段索引\" class=\"headerlink\" title=\"单字段索引\"></a>单字段索引</h4><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.createIndex(&#123;&quot;userId&quot;:1&#125;) #给userId字段添加一个升序的单字段索引</code></pre>\n\n<h4 id=\"复合索引\"><a href=\"#复合索引\" class=\"headerlink\" title=\"复合索引\"></a>复合索引</h4><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.createIndex(&#123;&quot;userId&quot;:1,&quot;age&quot;:-1&#125;) #给userId字段添加一个升序的索引,age为降序的索引</code></pre>\n\n<h4 id=\"其他索引\"><a href=\"#其他索引\" class=\"headerlink\" title=\"其他索引\"></a>其他索引</h4><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122105945634.png\" alt=\"image-20221122105945634\" style=\"zoom:67%;\" />\n\n<h4 id=\"删除索引\"><a href=\"#删除索引\" class=\"headerlink\" title=\"删除索引\"></a>删除索引</h4><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.dropIndex(&#123;&quot;userId&quot;:1&#125;) #删除userId字段的升序的索引\n\ndb.comment.dropIndexes() #删除所有索引</code></pre>\n\n<h3 id=\"性能检查\"><a href=\"#性能检查\" class=\"headerlink\" title=\"性能检查\"></a>性能检查</h3><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.find(xxx).explain()</code></pre>\n\n<h4 id=\"覆盖查询\"><a href=\"#覆盖查询\" class=\"headerlink\" title=\"覆盖查询\"></a>覆盖查询</h4><p>类似于MySQL中的覆盖索引</p>\n<p>就是查询的字段正是索引的字段</p>\n<h2 id=\"整合到SpringBoot\"><a href=\"#整合到SpringBoot\" class=\"headerlink\" title=\"整合到SpringBoot\"></a>整合到SpringBoot</h2><p>依赖：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>编写配置：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"># 应用名称\nspring:\n  application:\n    name: mongotest\n  data:\n    mongodb:\n      database: mytest\n      host: 127.0.0.1\n      port: 27017\n#      username: 如果有\n#      password: 如果有\nserver:\n  port: 8990</code></pre>\n\n<p>创建实体类，并指定文档名</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Document(collection &#x3D; &quot;user&quot;) &#x2F;&#x2F;可以省略，省略的话默认文档名为实体类的小写名\n@Data\npublic class User &#123;\n\n    &#x2F;&#x2F;mongoDB里自带的id为字符串！！！！！！！！！！！！\n    public String id;\n\n    @Field(&quot;name&quot;)\n    public String name;\n\n    public Integer sex;\n\n&#x2F;&#x2F;    @Indexed 添加单字段索引\n    public Long compId;\n\n    public String phone;\n&#125;</code></pre>\n\n<p>注入模板类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Autowired\nprivate MongoTemplate mongoTemplate;</code></pre>\n\n<h3 id=\"基本增添：\"><a href=\"#基本增添：\" class=\"headerlink\" title=\"基本增添：\"></a>基本增添：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;save&quot;)\npublic String save() &#123;\n    User user &#x3D; new User();\n    user.setName(&quot;CleWM&quot;);\n    user.setSex(1);\n    user.setCompId(10001L);\n    user.setPhone(&quot;18083822909&quot;);\n    &#x2F;&#x2F;insert和save的区别？\n    &#x2F;&#x2F;insert: 若新增数据的主键已经存在，则会抛 org.springframework.dao.DuplicateKeyException 异常提示主键重复，不保存当前数据。\n    &#x2F;&#x2F;save: 若新增数据的主键已经存在，则会对当前已经存在的数据进行修改操作\n    User insert &#x3D; mongoTemplate.insert(user);\n    return insert.getId().toString();\n&#125;</code></pre>\n\n<h3 id=\"基本查询：\"><a href=\"#基本查询：\" class=\"headerlink\" title=\"基本查询：\"></a>基本查询：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;get&quot;)\npublic String get() &#123;\n    Query query &#x3D; new Query();\n    query.addCriteria(Criteria.where(&quot;name&quot;).is(&quot;CleWM&quot;));\n    List&lt;User&gt; res &#x3D; mongoTemplate.find(query, User.class);\n    return res.get(0).toString();\n&#125;</code></pre>\n\n<h3 id=\"基本删除：\"><a href=\"#基本删除：\" class=\"headerlink\" title=\"基本删除：\"></a>基本删除：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">mongoTemplate.remove(obj)\n    \n&#x2F;&#x2F;根据条件删除\nQuery query &#x3D; new Query();\nquery.addCriteria(Criteria.where(&quot;id&quot;).is(commentId));\nComment res &#x3D; mongoTemplate.findAndRemove(query, Comment.class);</code></pre>\n\n<h3 id=\"基本修改：\"><a href=\"#基本修改：\" class=\"headerlink\" title=\"基本修改：\"></a>基本修改：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Query query &#x3D; new Query();\nquery.addCriteria(Criteria.where(&quot;id&quot;).is(commentId));\nComment res &#x3D; mongoTemplate.findAndRemove(query, Comment.class);\n\nUpdate update &#x3D; new Update();\nupdate.set(&quot;key&quot;,&quot;value&quot;);\nmongoTemplate.updateFirst(query,update,Comment.class);</code></pre>\n\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;实体类的字段需要实现Comparable接口，并重写方法，如下，注意，o和this的位置不能颠倒，否则升序和降序也会反过来。\n    @Override\n    public int compareTo(@NotNull Comment o) &#123;\n        return o.getLikes().compareTo(this.getLikes());\n    &#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic List getList(CommentFuzzySearchDTO commentFuzzySearchDTO) &#123;\n    Query query &#x3D; new Query().with(Sort.by(&quot;likes&quot;).descending()); &#x2F;&#x2F;降序排序\n    query.addCriteria(Criteria.where(&quot;item_id&quot;).is(commentFuzzySearchDTO.getItemId()));\n    Integer curr &#x3D; commentFuzzySearchDTO.getCurr();\n    Integer pageSize &#x3D; commentFuzzySearchDTO.getPageSize();\n    List&lt;Comment&gt; commentList &#x3D; mongoTemplate.find(query, Comment.class)\n            .stream().skip((curr - 1) * pageSize).limit(pageSize).sorted().collect(Collectors.toList());\n    return commentList;\n&#125;</code></pre>\n\n<h3 id=\"自增\"><a href=\"#自增\" class=\"headerlink\" title=\"自增\"></a>自增</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Boolean likeInc(String commentId) &#123;\n    Query query &#x3D; new Query();\n    query.addCriteria(Criteria.where(&quot;_id&quot;).is(commentId));\n    Update update &#x3D; new Update();\n    update.inc(&quot;likes&quot;);\n    UpdateResult updateResult &#x3D; mongoTemplate.updateFirst(query, update, Comment.class);\n    long modifiedCount &#x3D; updateResult.getModifiedCount();\n    return modifiedCount &gt; 0;\n&#125;</code></pre>\n\n<h3 id=\"更多使用\"><a href=\"#更多使用\" class=\"headerlink\" title=\"更多使用\"></a>更多使用</h3><p>参考<a href=\"https://blog.csdn.net/qq_36331657/article/details/116431191\">https://blog.csdn.net/qq_36331657/article/details/116431191</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_40392053/article/details/120265736\">https://blog.csdn.net/weixin_40392053/article/details/120265736</a></p>\n<h2 id=\"副本集\"><a href=\"#副本集\" class=\"headerlink\" title=\"副本集\"></a>副本集</h2><p>三个节点：</p>\n<ul>\n<li>主节点，Primary</li>\n<li>从节点，Slave </li>\n<li>选举节点，A也属于Slave，无法成为主节点</li>\n</ul>\n<h3 id=\"触发选举条件：\"><a href=\"#触发选举条件：\" class=\"headerlink\" title=\"触发选举条件：\"></a>触发选举条件：</h3><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122110005391.png\" alt=\"image-20221122110005391\" style=\"zoom:67%;\" />\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>一种非关系型数据库(NoSQL)</p>\n<p>应用场景：高并发的、需要低延时的，对事务要求、安全性不是很高的场景。</p>\n<h2 id=\"和Reids的区别？\"><a href=\"#和Reids的区别？\" class=\"headerlink\" title=\"和Reids的区别？\"></a>和Reids的区别？</h2><p>Redis主要把数据存储在内存中，其“缓存”的性质远大于其“数据存储“的性质，其中数据的增删改查也只是像变量操作一样简单；</p>\n<p>MongoDB却是一个“存储数据”的系统，增删改查可以添加很多条件，就像SQL数据库一样灵活，这一点在面试的时候很受用。</p>\n<h2 id=\"术语对比\"><a href=\"#术语对比\" class=\"headerlink\" title=\"术语对比\"></a>术语对比</h2><p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122105852998.png\" alt=\"image-20221122105852998\"></p>\n<h2 id=\"Windows安装-启动\"><a href=\"#Windows安装-启动\" class=\"headerlink\" title=\"Windows安装/启动\"></a>Windows安装/启动</h2><p>下载zip格式的mongoDB包</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;www.mongodb.com&#x2F;try&#x2F;download&#x2F;community</code></pre>\n\n<p>下载之后解压，在根目录下创建文件夹data/db</p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122105904463.png\" alt=\"image-20221122105904463\"></p>\n<p>进入bin目录下进入cmd</p>\n<p>执行如下</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">mongod --dbpath&#x3D;..&#x2F;data&#x2F;db  #指定数据库存放位置</code></pre>\n\n<p>重新进入bin下的cmd，执行如下：</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">mongo 或者 mongo --host&#x3D;127.0.0.1 --port&#x3D;27017 #27017是默认端口号</code></pre>\n\n<h2 id=\"Linux安装-启动\"><a href=\"#Linux安装-启动\" class=\"headerlink\" title=\"Linux安装/启动\"></a>Linux安装/启动</h2><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122105922151.png\" alt=\"image-20221122105922151\" style=\"zoom:50%;\" />\n\n<p>配置内容如下：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">systemLog:\n\t#MongoDB发送所有日志输出的目标指定为文件\n\t# #The path of the 1log file to which mongod or mongos should send all diagnostic 1ogging information\n\tdestination: file\n    #mongod或mongos应向其发送所有诊断日志记录信息的日志文件的路径\n    path: &quot;&#x2F;mongodb&#x2F;sing1e&#x2F;1og&#x2F;mongod. log&quot;\n    #当mongos或mongod实例重新启动时，mongos或mongod会将新条目附加到现有日志文件的末尾。\n    logAppend: true\nstorage:\n    #mongod实例存储其数据的目录。storage . dbpath设置仅适用于mongod.\n    ##The directory where the mongod instance stores its data. Default value is &quot;&#x2F;data&#x2F;db&quot;.\n    dbpath: &quot;&#x2F;mongodb&#x2F;sing1e&#x2F;data&#x2F;db&quot;\n    journal:\n        #启用或禁用持久性日志以确保数据文件保持有效和可恢复。\n        enabled: true\nprocessManagement:\n    #启用在后台运行mongos或mongod进程的守护进程模式。\n    fork: true\nnet:\n    #服务实例绑定的IP，默认是localhost\n    bindIp: 1oca1host,192.168.0.2\n    #绑定的端口，默认是27017\n    port: 27017</code></pre>\n\n<p>启动：</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;bin&#x2F;mongod -f &#x2F;mongodb&#x2F;single&#x2F;mongod.conf</code></pre>\n\n<p>结果应该是Successfully</p>\n<p>然后就可以使用可视化工具或者Shell命令行进行连接，如果连接不上，尝试关闭防火墙</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">#查看防火墙状态 systemctl status firewalld \n#临时关闭防火墙 systemctl stop firewalld \n#开机禁止启动防火墙 systemctl disable firewalld</code></pre>\n\n<p>关闭数据库：</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">&#x2F;&#x2F;客户端登录服务，注意，这里通过localhost登录，如果需要远程登录，必须先登录认证才行。 \nmongo --port 27017 &#x2F;&#x2F;#切换到admin库 \nuse admin &#x2F;&#x2F;关闭服务 \ndb.shutdownServer()</code></pre>\n\n<h2 id=\"图形化界面\"><a href=\"#图形化界面\" class=\"headerlink\" title=\"图形化界面\"></a>图形化界面</h2><p>到官网下载Compass，直接运行即可</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">use 数据库名称 #选择&#x2F;创建\n\nshow dbs #查看数据库(磁盘里的)\n\ndb #查看正在使用的数据库\n\ndb.dropDatabase() #删除数据库 db指的是数据库对象，操作的是当前使用的数据库</code></pre>\n\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.createCollection(&quot;My&quot;) #创建一个叫My的集合\n\nshow collections #查看所有集合\n\ndb.集合名.drop() #删除某个集合</code></pre>\n\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><h5 id=\"文档的id值必须为字符串-不是数字\"><a href=\"#文档的id值必须为字符串-不是数字\" class=\"headerlink\" title=\"文档的id值必须为字符串!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!不是数字\"></a><strong>文档的id值必须为字符串!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!不是数字</strong></h5><h4 id=\"查询-插入\"><a href=\"#查询-插入\" class=\"headerlink\" title=\"查询/插入\"></a>查询/插入</h4><h5 id=\"普通查询\"><a href=\"#普通查询\" class=\"headerlink\" title=\"普通查询\"></a>普通查询</h5><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.集合名.insert(&#123;&quot;name&quot;:&quot;value&quot;&#125;) #单条数据的插入，若此时集合未被创建，会隐式地创建好集合\n\ndb.集合名.insertMany([\n    &#123;\n        xxx:xxx\n    &#125;,\n    &#123;\n        xxx:xxx\n    &#125;,\n])  #插入多条数据\n\ndb.集合名.find() #查看集合内容\n\ndb.集合名.find(&#123;&quot;name&quot;:&quot;张三&quot;&#125;) #查询名字为张三的内容\n\ndb.集合名.findOne() &#x2F; db.集合名.findOne(&#123;xxx:xxx&#125;)#查询一条数据，类似于limit\n\ndb.集合名.find(&#123;查询的条件&#125;,&#123;字段1:1,字段2:0&#125;)#只显示部分字段,显示字段1，不显示字段2，以逗号分割</code></pre>\n\n<h5 id=\"统计查询-count\"><a href=\"#统计查询-count\" class=\"headerlink\" title=\"统计查询 count\"></a>统计查询 count</h5><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.count() #查询所有数据数量\n\ndb.comment.count(&#123;条件&#125;)</code></pre>\n\n<h5 id=\"分页查询-limt-skip\"><a href=\"#分页查询-limt-skip\" class=\"headerlink\" title=\"分页查询 limt/skip\"></a>分页查询 limt/skip</h5><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.find().limit(3) #限制查询数量</code></pre>\n\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.find().limit(2).skip(2)</code></pre>\n\n<h5 id=\"排序-sort\"><a href=\"#排序-sort\" class=\"headerlink\" title=\"排序 sort\"></a>排序 sort</h5><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.find().sort(&#123;xxx:1&#x2F;0&#125;) #1为升序，-1为降序</code></pre>\n\n<h5 id=\"正则查询\"><a href=\"#正则查询\" class=\"headerlink\" title=\"正则查询 / /\"></a>正则查询 / /</h5><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.find(&#123;字段:&#x2F;正则表达式&#x2F;&#125;)</code></pre>\n\n<h5 id=\"比较查询-gt-lt\"><a href=\"#比较查询-gt-lt\" class=\"headerlink\" title=\"比较查询 gt/lt\"></a>比较查询 gt/lt</h5><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.find(&#123;xxx:&#123;$gt:value&#125;&#125;)\n\ngt：大于\ngte：大于等于\n\nlt：小于\nlte：小于等于</code></pre>\n\n<h5 id=\"包含查询-in-nin\"><a href=\"#包含查询-in-nin\" class=\"headerlink\" title=\"包含查询 in/nin\"></a>包含查询 in/nin</h5><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.find(&#123;xxx:&#123;$in:[&quot;value1&quot;,&quot;value2&quot;]&#125;&#125;) #包含\n\ndb.comment.find(&#123;xxx:&#123;$nin:[&quot;value1&quot;,&quot;value2&quot;]&#125;&#125;) #不包含</code></pre>\n\n<h5 id=\"多条件查询-and-or\"><a href=\"#多条件查询-and-or\" class=\"headerlink\" title=\"多条件查询 and/or\"></a>多条件查询 and/or</h5><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.find(&#123;$and:[&#123;&quot;xxx&quot;:&quot;value&quot;&#125;,&#123;&quot;xxx2&quot;:&#123;$gt:NumberInt(233)&#125;&#125;]&#125;)\n\n\ndb.comment.find(&#123;$or:[&#123;&quot;xxx&quot;:&quot;value&quot;&#125;,&#123;&quot;xxx2&quot;:&#123;$gt:NumberInt(233)&#125;&#125;]&#125;)</code></pre>\n\n\n\n<h4 id=\"Try-catch包裹插入语句\"><a href=\"#Try-catch包裹插入语句\" class=\"headerlink\" title=\"Try catch包裹插入语句\"></a>Try catch包裹插入语句</h4><p><img src=\"http://www.clewm.top/MarkDownImages/image-20220714132811240.png\" alt=\"image-20220714132811240\"></p>\n<p>可以知道哪条数据插入失败</p>\n<h4 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h4><p>如下是覆盖更新</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.update(&#123;更新的条件&#125;,&#123;更新的内容&#125;)</code></pre>\n\n<p>如下才是局部更新</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.update(&#123;更新的条件&#125;,&#123;$set:&#123;更新的内容&#125;&#125;)</code></pre>\n\n<p>默认是只修改找到的第一条数据，若想修改全部</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.update(&#123;更新的条件&#125;,&#123;$set:&#123;更新的内容&#125;&#125;,&#123;multi:true&#125;)</code></pre>\n\n<p>使某个字段自增1</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.update(&#123;更新的条件&#125;,&#123;$inc:&#123;XXX:NumberInt(1)&#125;&#125;)</code></pre>\n\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.remove(&#123;删除的条件&#125;)\n\ndb.comment.remove(&#123;&#125;) #删除全部\n\n#以上是过时的方法，下面是新的\nuse 数据库名\ndb.文档名.deleteOne(&#123;&quot;uid&quot;:&quot;123&quot;&#125;)\n\ndb.文档名.deleteMany(&#123;&quot;sex&quot;:&quot;男&quot;&#125;) #删多个满足条件的\n\ndb.文档名.deleteMany(&#123;&#125;) #删所有</code></pre>\n\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.getIndexs() #查看索引\n\ndb.comment.createIndex(keys,options) #查看索引 options里常用的是name：指定索引名称和unique指定是否是唯一索引</code></pre>\n\n<h4 id=\"单字段索引\"><a href=\"#单字段索引\" class=\"headerlink\" title=\"单字段索引\"></a>单字段索引</h4><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.createIndex(&#123;&quot;userId&quot;:1&#125;) #给userId字段添加一个升序的单字段索引</code></pre>\n\n<h4 id=\"复合索引\"><a href=\"#复合索引\" class=\"headerlink\" title=\"复合索引\"></a>复合索引</h4><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.createIndex(&#123;&quot;userId&quot;:1,&quot;age&quot;:-1&#125;) #给userId字段添加一个升序的索引,age为降序的索引</code></pre>\n\n<h4 id=\"其他索引\"><a href=\"#其他索引\" class=\"headerlink\" title=\"其他索引\"></a>其他索引</h4><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122105945634.png\" alt=\"image-20221122105945634\" style=\"zoom:67%;\" />\n\n<h4 id=\"删除索引\"><a href=\"#删除索引\" class=\"headerlink\" title=\"删除索引\"></a>删除索引</h4><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.dropIndex(&#123;&quot;userId&quot;:1&#125;) #删除userId字段的升序的索引\n\ndb.comment.dropIndexes() #删除所有索引</code></pre>\n\n<h3 id=\"性能检查\"><a href=\"#性能检查\" class=\"headerlink\" title=\"性能检查\"></a>性能检查</h3><pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">db.comment.find(xxx).explain()</code></pre>\n\n<h4 id=\"覆盖查询\"><a href=\"#覆盖查询\" class=\"headerlink\" title=\"覆盖查询\"></a>覆盖查询</h4><p>类似于MySQL中的覆盖索引</p>\n<p>就是查询的字段正是索引的字段</p>\n<h2 id=\"整合到SpringBoot\"><a href=\"#整合到SpringBoot\" class=\"headerlink\" title=\"整合到SpringBoot\"></a>整合到SpringBoot</h2><p>依赖：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>编写配置：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"># 应用名称\nspring:\n  application:\n    name: mongotest\n  data:\n    mongodb:\n      database: mytest\n      host: 127.0.0.1\n      port: 27017\n#      username: 如果有\n#      password: 如果有\nserver:\n  port: 8990</code></pre>\n\n<p>创建实体类，并指定文档名</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Document(collection &#x3D; &quot;user&quot;) &#x2F;&#x2F;可以省略，省略的话默认文档名为实体类的小写名\n@Data\npublic class User &#123;\n\n    &#x2F;&#x2F;mongoDB里自带的id为字符串！！！！！！！！！！！！\n    public String id;\n\n    @Field(&quot;name&quot;)\n    public String name;\n\n    public Integer sex;\n\n&#x2F;&#x2F;    @Indexed 添加单字段索引\n    public Long compId;\n\n    public String phone;\n&#125;</code></pre>\n\n<p>注入模板类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Autowired\nprivate MongoTemplate mongoTemplate;</code></pre>\n\n<h3 id=\"基本增添：\"><a href=\"#基本增添：\" class=\"headerlink\" title=\"基本增添：\"></a>基本增添：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;save&quot;)\npublic String save() &#123;\n    User user &#x3D; new User();\n    user.setName(&quot;CleWM&quot;);\n    user.setSex(1);\n    user.setCompId(10001L);\n    user.setPhone(&quot;18083822909&quot;);\n    &#x2F;&#x2F;insert和save的区别？\n    &#x2F;&#x2F;insert: 若新增数据的主键已经存在，则会抛 org.springframework.dao.DuplicateKeyException 异常提示主键重复，不保存当前数据。\n    &#x2F;&#x2F;save: 若新增数据的主键已经存在，则会对当前已经存在的数据进行修改操作\n    User insert &#x3D; mongoTemplate.insert(user);\n    return insert.getId().toString();\n&#125;</code></pre>\n\n<h3 id=\"基本查询：\"><a href=\"#基本查询：\" class=\"headerlink\" title=\"基本查询：\"></a>基本查询：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;get&quot;)\npublic String get() &#123;\n    Query query &#x3D; new Query();\n    query.addCriteria(Criteria.where(&quot;name&quot;).is(&quot;CleWM&quot;));\n    List&lt;User&gt; res &#x3D; mongoTemplate.find(query, User.class);\n    return res.get(0).toString();\n&#125;</code></pre>\n\n<h3 id=\"基本删除：\"><a href=\"#基本删除：\" class=\"headerlink\" title=\"基本删除：\"></a>基本删除：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">mongoTemplate.remove(obj)\n    \n&#x2F;&#x2F;根据条件删除\nQuery query &#x3D; new Query();\nquery.addCriteria(Criteria.where(&quot;id&quot;).is(commentId));\nComment res &#x3D; mongoTemplate.findAndRemove(query, Comment.class);</code></pre>\n\n<h3 id=\"基本修改：\"><a href=\"#基本修改：\" class=\"headerlink\" title=\"基本修改：\"></a>基本修改：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Query query &#x3D; new Query();\nquery.addCriteria(Criteria.where(&quot;id&quot;).is(commentId));\nComment res &#x3D; mongoTemplate.findAndRemove(query, Comment.class);\n\nUpdate update &#x3D; new Update();\nupdate.set(&quot;key&quot;,&quot;value&quot;);\nmongoTemplate.updateFirst(query,update,Comment.class);</code></pre>\n\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;实体类的字段需要实现Comparable接口，并重写方法，如下，注意，o和this的位置不能颠倒，否则升序和降序也会反过来。\n    @Override\n    public int compareTo(@NotNull Comment o) &#123;\n        return o.getLikes().compareTo(this.getLikes());\n    &#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic List getList(CommentFuzzySearchDTO commentFuzzySearchDTO) &#123;\n    Query query &#x3D; new Query().with(Sort.by(&quot;likes&quot;).descending()); &#x2F;&#x2F;降序排序\n    query.addCriteria(Criteria.where(&quot;item_id&quot;).is(commentFuzzySearchDTO.getItemId()));\n    Integer curr &#x3D; commentFuzzySearchDTO.getCurr();\n    Integer pageSize &#x3D; commentFuzzySearchDTO.getPageSize();\n    List&lt;Comment&gt; commentList &#x3D; mongoTemplate.find(query, Comment.class)\n            .stream().skip((curr - 1) * pageSize).limit(pageSize).sorted().collect(Collectors.toList());\n    return commentList;\n&#125;</code></pre>\n\n<h3 id=\"自增\"><a href=\"#自增\" class=\"headerlink\" title=\"自增\"></a>自增</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Boolean likeInc(String commentId) &#123;\n    Query query &#x3D; new Query();\n    query.addCriteria(Criteria.where(&quot;_id&quot;).is(commentId));\n    Update update &#x3D; new Update();\n    update.inc(&quot;likes&quot;);\n    UpdateResult updateResult &#x3D; mongoTemplate.updateFirst(query, update, Comment.class);\n    long modifiedCount &#x3D; updateResult.getModifiedCount();\n    return modifiedCount &gt; 0;\n&#125;</code></pre>\n\n<h3 id=\"更多使用\"><a href=\"#更多使用\" class=\"headerlink\" title=\"更多使用\"></a>更多使用</h3><p>参考<a href=\"https://blog.csdn.net/qq_36331657/article/details/116431191\">https://blog.csdn.net/qq_36331657/article/details/116431191</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_40392053/article/details/120265736\">https://blog.csdn.net/weixin_40392053/article/details/120265736</a></p>\n<h2 id=\"副本集\"><a href=\"#副本集\" class=\"headerlink\" title=\"副本集\"></a>副本集</h2><p>三个节点：</p>\n<ul>\n<li>主节点，Primary</li>\n<li>从节点，Slave </li>\n<li>选举节点，A也属于Slave，无法成为主节点</li>\n</ul>\n<h3 id=\"触发选举条件：\"><a href=\"#触发选举条件：\" class=\"headerlink\" title=\"触发选举条件：\"></a>触发选举条件：</h3><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221122110005391.png\" alt=\"image-20221122110005391\" style=\"zoom:67%;\" />\n"},{"title":"SkyWalking","description":"分布式链路追踪","_content":"\n\n\n# SkyWalking\n\n### 下载地址：http://skywalking.apache.org/downloads/\n\n## 概念：\n\n可实现基于Open Tracing规范的分布式链路追踪功能的APM应用性能管理平台\n\n![image-20220823114137847](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823114137847.png)\n\n### UI界面的jar包和配置文件（可修改端  口）\n\n![image-20220823114222953](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823114222953.png)\n\n修改skywalking服务端数据存储方式：\n\n默认是使用H2进行存储，如果服务端重启的话，数据就会丢失，推荐使用es存储，可以在如下位置处进行修改：\n\n![image-20220823134907000](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823134907000.png)\n\nselector处修改为elasticsearch，然后修改es的一些默认配置即可\n\n![image-20220823134723074](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823134723074.png)\n\n### 端口说明\n\n![image-20220823114611913](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823114611913.png)\n\n## 服务接入\n\n比如我需要在window系统上启动一个需要被监控的服务，就需要在这个系统上提前准备一个和skywalking服务端对应版本的skywalking-agent.jar\n\n下载地址：https://archive.apache.org/dist/skywalking/，解压后在根目录即可找到，170多MB的那个\n\n- 如果是通过idea启动的话，在启动配置的VM参数处填入以下：\n\n```shell \n-javaagent:C:\\_Code\\lcss\\lcss-gateway\\agent\\skywalking-agent.jar #jar包具体位置\n-Dskywalking.agent.service_name=lcss-gateway #服务名，最好与nacos中的名字对应\n-Dskywalking.collector.backend_service=192.168.1.104:11800 #skywalking服务端暴露的收集数据的端口\n```\n\n- 如果是在docker中的话：\n\n同样需要提前准备agent（包含有jar包）\n\n原本项目的启动方式：\n\n```shell\njava -jar spring-boot-demo-0.0.1-SNAPSHOT.jar\n```\n\n现在变为：\n\n```shell\njava -javaagent:/opt/apache-skywalking-apm-bin/agent/skywalking-agent.jar -Dskywalking.agent.service_name=服务名 -Dskywalking.collector.backend_service=127.0.0.1:11800 -jar /opt/spring-boot-demo-0.0.1-SNAPSHOT.jar\n```\n\n\n\n### 操作如下：\n\n与Src目录平级下建一个agent文件夹，放agent文件夹（从如下路径拷贝来的）\n\n![image-20220916142200142](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220916142200142.png)\n\n![image-20220916142128932](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220916142128932.png)\n\n文件：\n\n```dockerfile\nFROM openjdk:8-jdk-alpine\n\nRUN mkdir -p /lcss-gateway\n\nWORKDIR /lcss-gateway\n\nARG JAR_FILE=target/lcss-gateway.jar\n\nCOPY ${JAR_FILE} app.jar\nCOPY agent /lcss-gateway/agent ==========>>>>关键,把agent的jar包复制到容器中\n\nEXPOSE 20010\n\nENTRYPOINT [\"java\", \"-javaagent:/lcss-gateway/agent/skywalking-agent.jar\", \"-Dskywalking.agent.service_name=lcss-gateway\",\"-Dskywalking.collector.backend_service=192.168.1.104:11800\", \"-jar\",\"app.jar\"]\n```\n\n### ps:docker部署启动的时候提示config没找到的踩坑\n\n项目的agent不能只拷贝一个jar包，需要把整个agent文件夹都拷贝进去，因为里面还有配置文件！！\n\n## 日志收集（版本8.4及以上！）\n\n**ps：SpringBoot默认的日志框架是logback，这里介绍的也是基于logback的日志收集方法，可以配合Lombok的@Slf4j正常使用******\n\n依赖：\n\n```xml\n<dependency>\n    <groupId>org.apache.skywalking</groupId>\n    <artifactId>apm-toolkit-trace</artifactId>\n    <version>8.5.0</version> =============================该版本最好和skyWalking的版本对应\n</dependency>\n\n<dependency>\n    <groupId>org.apache.skywalking</groupId>\n    <artifactId>apm-toolkit-logback-1.x</artifactId>\n    <version>8.5.0</version> =============================该版本最好和skyWalking的版本对应\n</dependency>\n```\n\n\n\n在resource下创建logback-spring.xml文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration scan=\"true\" scanPeriod=\"10 seconds\">\n\n    <appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"> ========用来格式化日志输出的\n        <encoder class=\"ch.qos.logback.core.encoder.LayoutWrappingEncoder\">\n            <layout class=\"org.apache.skywalking.apm.toolkit.log.logback.v1.x.TraceIdPatternLogbackLayout\">\n                <Pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%tid] [%thread] %-5level %logger{36} -%msg%n</Pattern>\n            </layout>\n        </encoder>\n    </appender>\n\n    <appender name=\"grpc\" =====================用来上报日志的class=\"org.apache.skywalking.apm.toolkit.log.logback.v1.x.log.GRPCLogClientAppender\">\n        <encoder class=\"ch.qos.logback.core.encoder.LayoutWrappingEncoder\">\n            <layout class=\"org.apache.skywalking.apm.toolkit.log.logback.v1.x.mdc.TraceIdMDCPatternLogbackLayout\">\n                <Pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{tid}] [%thread] %-5level %logger{36} -%msg%n</Pattern>\n            </layout>\n        </encoder>\n    </appender>\n\n    <root level=\"INFO\">\n        <appender-ref ref=\"stdout\"/> ===================用来格式化日志输出的\n        <appender-ref ref=\"grpc\"/> =====================用来上报日志的\n    </root>\n</configuration>\n```\n\n如果服务和skyWalking不在同一个服务器上，还需要在agent文件夹下的config的agent.config中添加如下配置：\n\n```\nplugin.toolkit.log.grpc.reporter.server_host=${SW_GRPC_LOG_SERVER_HOST:172.28.231.100}  ===地址\nplugin.toolkit.log.grpc.reporter.server_port=${SW_GRPC_LOG_SERVER_PORT:11800} ===端口\nplugin.toolkit.log.grpc.reporter.max_message_size=${SW_GRPC_LOG_MAX_MESSAGE_SIZE:10485760} ===最大日志大小\nplugin.toolkit.log.grpc.reporter.upstream_timeout=${SW_GRPC_LOG_GRPC_UPSTREAM_TIMEOUT:30} \n```\n\n如何定位某条日志对应的调用链路？\n\n![image-20220918111842645](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220918111842645.png)\n\n通过该TID在skyWalking中进行搜索，不支持模糊查询\n\n![image-20220918111916766](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220918111916766.png)\n","source":"_posts/Java/SkyWalking分布式链路追踪.md","raw":"---\ntitle: SkyWalking\n\ncategories: \n- 技术\n- 分布式\n- 中间件\n- 分布式链路追踪\n\ntags:\n- Java\n- 分布式\n\ndescription: 分布式链路追踪\n---\n\n\n\n# SkyWalking\n\n### 下载地址：http://skywalking.apache.org/downloads/\n\n## 概念：\n\n可实现基于Open Tracing规范的分布式链路追踪功能的APM应用性能管理平台\n\n![image-20220823114137847](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823114137847.png)\n\n### UI界面的jar包和配置文件（可修改端  口）\n\n![image-20220823114222953](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823114222953.png)\n\n修改skywalking服务端数据存储方式：\n\n默认是使用H2进行存储，如果服务端重启的话，数据就会丢失，推荐使用es存储，可以在如下位置处进行修改：\n\n![image-20220823134907000](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823134907000.png)\n\nselector处修改为elasticsearch，然后修改es的一些默认配置即可\n\n![image-20220823134723074](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823134723074.png)\n\n### 端口说明\n\n![image-20220823114611913](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823114611913.png)\n\n## 服务接入\n\n比如我需要在window系统上启动一个需要被监控的服务，就需要在这个系统上提前准备一个和skywalking服务端对应版本的skywalking-agent.jar\n\n下载地址：https://archive.apache.org/dist/skywalking/，解压后在根目录即可找到，170多MB的那个\n\n- 如果是通过idea启动的话，在启动配置的VM参数处填入以下：\n\n```shell \n-javaagent:C:\\_Code\\lcss\\lcss-gateway\\agent\\skywalking-agent.jar #jar包具体位置\n-Dskywalking.agent.service_name=lcss-gateway #服务名，最好与nacos中的名字对应\n-Dskywalking.collector.backend_service=192.168.1.104:11800 #skywalking服务端暴露的收集数据的端口\n```\n\n- 如果是在docker中的话：\n\n同样需要提前准备agent（包含有jar包）\n\n原本项目的启动方式：\n\n```shell\njava -jar spring-boot-demo-0.0.1-SNAPSHOT.jar\n```\n\n现在变为：\n\n```shell\njava -javaagent:/opt/apache-skywalking-apm-bin/agent/skywalking-agent.jar -Dskywalking.agent.service_name=服务名 -Dskywalking.collector.backend_service=127.0.0.1:11800 -jar /opt/spring-boot-demo-0.0.1-SNAPSHOT.jar\n```\n\n\n\n### 操作如下：\n\n与Src目录平级下建一个agent文件夹，放agent文件夹（从如下路径拷贝来的）\n\n![image-20220916142200142](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220916142200142.png)\n\n![image-20220916142128932](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220916142128932.png)\n\n文件：\n\n```dockerfile\nFROM openjdk:8-jdk-alpine\n\nRUN mkdir -p /lcss-gateway\n\nWORKDIR /lcss-gateway\n\nARG JAR_FILE=target/lcss-gateway.jar\n\nCOPY ${JAR_FILE} app.jar\nCOPY agent /lcss-gateway/agent ==========>>>>关键,把agent的jar包复制到容器中\n\nEXPOSE 20010\n\nENTRYPOINT [\"java\", \"-javaagent:/lcss-gateway/agent/skywalking-agent.jar\", \"-Dskywalking.agent.service_name=lcss-gateway\",\"-Dskywalking.collector.backend_service=192.168.1.104:11800\", \"-jar\",\"app.jar\"]\n```\n\n### ps:docker部署启动的时候提示config没找到的踩坑\n\n项目的agent不能只拷贝一个jar包，需要把整个agent文件夹都拷贝进去，因为里面还有配置文件！！\n\n## 日志收集（版本8.4及以上！）\n\n**ps：SpringBoot默认的日志框架是logback，这里介绍的也是基于logback的日志收集方法，可以配合Lombok的@Slf4j正常使用******\n\n依赖：\n\n```xml\n<dependency>\n    <groupId>org.apache.skywalking</groupId>\n    <artifactId>apm-toolkit-trace</artifactId>\n    <version>8.5.0</version> =============================该版本最好和skyWalking的版本对应\n</dependency>\n\n<dependency>\n    <groupId>org.apache.skywalking</groupId>\n    <artifactId>apm-toolkit-logback-1.x</artifactId>\n    <version>8.5.0</version> =============================该版本最好和skyWalking的版本对应\n</dependency>\n```\n\n\n\n在resource下创建logback-spring.xml文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration scan=\"true\" scanPeriod=\"10 seconds\">\n\n    <appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"> ========用来格式化日志输出的\n        <encoder class=\"ch.qos.logback.core.encoder.LayoutWrappingEncoder\">\n            <layout class=\"org.apache.skywalking.apm.toolkit.log.logback.v1.x.TraceIdPatternLogbackLayout\">\n                <Pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%tid] [%thread] %-5level %logger{36} -%msg%n</Pattern>\n            </layout>\n        </encoder>\n    </appender>\n\n    <appender name=\"grpc\" =====================用来上报日志的class=\"org.apache.skywalking.apm.toolkit.log.logback.v1.x.log.GRPCLogClientAppender\">\n        <encoder class=\"ch.qos.logback.core.encoder.LayoutWrappingEncoder\">\n            <layout class=\"org.apache.skywalking.apm.toolkit.log.logback.v1.x.mdc.TraceIdMDCPatternLogbackLayout\">\n                <Pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{tid}] [%thread] %-5level %logger{36} -%msg%n</Pattern>\n            </layout>\n        </encoder>\n    </appender>\n\n    <root level=\"INFO\">\n        <appender-ref ref=\"stdout\"/> ===================用来格式化日志输出的\n        <appender-ref ref=\"grpc\"/> =====================用来上报日志的\n    </root>\n</configuration>\n```\n\n如果服务和skyWalking不在同一个服务器上，还需要在agent文件夹下的config的agent.config中添加如下配置：\n\n```\nplugin.toolkit.log.grpc.reporter.server_host=${SW_GRPC_LOG_SERVER_HOST:172.28.231.100}  ===地址\nplugin.toolkit.log.grpc.reporter.server_port=${SW_GRPC_LOG_SERVER_PORT:11800} ===端口\nplugin.toolkit.log.grpc.reporter.max_message_size=${SW_GRPC_LOG_MAX_MESSAGE_SIZE:10485760} ===最大日志大小\nplugin.toolkit.log.grpc.reporter.upstream_timeout=${SW_GRPC_LOG_GRPC_UPSTREAM_TIMEOUT:30} \n```\n\n如何定位某条日志对应的调用链路？\n\n![image-20220918111842645](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220918111842645.png)\n\n通过该TID在skyWalking中进行搜索，不支持模糊查询\n\n![image-20220918111916766](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220918111916766.png)\n","slug":"Java/SkyWalking分布式链路追踪","published":1,"date":"2022-08-19T22:55:50.542Z","updated":"2022-11-22T02:45:52.605Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbrcchl30002qkiq0m2rfvx4","content":"<h1 id=\"SkyWalking\"><a href=\"#SkyWalking\" class=\"headerlink\" title=\"SkyWalking\"></a>SkyWalking</h1><h3 id=\"下载地址：http-skywalking-apache-org-downloads\"><a href=\"#下载地址：http-skywalking-apache-org-downloads\" class=\"headerlink\" title=\"下载地址：http://skywalking.apache.org/downloads/\"></a>下载地址：<a href=\"http://skywalking.apache.org/downloads/\">http://skywalking.apache.org/downloads/</a></h3><h2 id=\"概念：\"><a href=\"#概念：\" class=\"headerlink\" title=\"概念：\"></a>概念：</h2><p>可实现基于Open Tracing规范的分布式链路追踪功能的APM应用性能管理平台</p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823114137847.png\" alt=\"image-20220823114137847\"></p>\n<h3 id=\"UI界面的jar包和配置文件（可修改端-口）\"><a href=\"#UI界面的jar包和配置文件（可修改端-口）\" class=\"headerlink\" title=\"UI界面的jar包和配置文件（可修改端  口）\"></a>UI界面的jar包和配置文件（可修改端  口）</h3><p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823114222953.png\" alt=\"image-20220823114222953\"></p>\n<p>修改skywalking服务端数据存储方式：</p>\n<p>默认是使用H2进行存储，如果服务端重启的话，数据就会丢失，推荐使用es存储，可以在如下位置处进行修改：</p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823134907000.png\" alt=\"image-20220823134907000\"></p>\n<p>selector处修改为elasticsearch，然后修改es的一些默认配置即可</p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823134723074.png\" alt=\"image-20220823134723074\"></p>\n<h3 id=\"端口说明\"><a href=\"#端口说明\" class=\"headerlink\" title=\"端口说明\"></a>端口说明</h3><p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823114611913.png\" alt=\"image-20220823114611913\"></p>\n<h2 id=\"服务接入\"><a href=\"#服务接入\" class=\"headerlink\" title=\"服务接入\"></a>服务接入</h2><p>比如我需要在window系统上启动一个需要被监控的服务，就需要在这个系统上提前准备一个和skywalking服务端对应版本的skywalking-agent.jar</p>\n<p>下载地址：<a href=\"https://archive.apache.org/dist/skywalking/%EF%BC%8C%E8%A7%A3%E5%8E%8B%E5%90%8E%E5%9C%A8%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8D%B3%E5%8F%AF%E6%89%BE%E5%88%B0%EF%BC%8C170%E5%A4%9AMB%E7%9A%84%E9%82%A3%E4%B8%AA\">https://archive.apache.org/dist/skywalking/，解压后在根目录即可找到，170多MB的那个</a></p>\n<ul>\n<li>如果是通过idea启动的话，在启动配置的VM参数处填入以下：</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">-javaagent:C:\\_Code\\lcss\\lcss-gateway\\agent\\skywalking-agent.jar #jar包具体位置\n-Dskywalking.agent.service_name&#x3D;lcss-gateway #服务名，最好与nacos中的名字对应\n-Dskywalking.collector.backend_service&#x3D;192.168.1.104:11800 #skywalking服务端暴露的收集数据的端口</code></pre>\n\n<ul>\n<li>如果是在docker中的话：</li>\n</ul>\n<p>同样需要提前准备agent（包含有jar包）</p>\n<p>原本项目的启动方式：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">java -jar spring-boot-demo-0.0.1-SNAPSHOT.jar</code></pre>\n\n<p>现在变为：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">java -javaagent:&#x2F;opt&#x2F;apache-skywalking-apm-bin&#x2F;agent&#x2F;skywalking-agent.jar -Dskywalking.agent.service_name&#x3D;服务名 -Dskywalking.collector.backend_service&#x3D;127.0.0.1:11800 -jar &#x2F;opt&#x2F;spring-boot-demo-0.0.1-SNAPSHOT.jar</code></pre>\n\n\n\n<h3 id=\"操作如下：\"><a href=\"#操作如下：\" class=\"headerlink\" title=\"操作如下：\"></a>操作如下：</h3><p>与Src目录平级下建一个agent文件夹，放agent文件夹（从如下路径拷贝来的）</p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220916142200142.png\" alt=\"image-20220916142200142\"></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220916142128932.png\" alt=\"image-20220916142128932\"></p>\n<p>文件：</p>\n<pre class=\"line-numbers language-docker\" data-language=\"docker\"><code class=\"language-docker\">FROM openjdk:8-jdk-alpine\n\nRUN mkdir -p &#x2F;lcss-gateway\n\nWORKDIR &#x2F;lcss-gateway\n\nARG JAR_FILE&#x3D;target&#x2F;lcss-gateway.jar\n\nCOPY $&#123;JAR_FILE&#125; app.jar\nCOPY agent &#x2F;lcss-gateway&#x2F;agent &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;&gt;关键,把agent的jar包复制到容器中\n\nEXPOSE 20010\n\nENTRYPOINT [&quot;java&quot;, &quot;-javaagent:&#x2F;lcss-gateway&#x2F;agent&#x2F;skywalking-agent.jar&quot;, &quot;-Dskywalking.agent.service_name&#x3D;lcss-gateway&quot;,&quot;-Dskywalking.collector.backend_service&#x3D;192.168.1.104:11800&quot;, &quot;-jar&quot;,&quot;app.jar&quot;]</code></pre>\n\n<h3 id=\"ps-docker部署启动的时候提示config没找到的踩坑\"><a href=\"#ps-docker部署启动的时候提示config没找到的踩坑\" class=\"headerlink\" title=\"ps:docker部署启动的时候提示config没找到的踩坑\"></a>ps:docker部署启动的时候提示config没找到的踩坑</h3><p>项目的agent不能只拷贝一个jar包，需要把整个agent文件夹都拷贝进去，因为里面还有配置文件！！</p>\n<h2 id=\"日志收集（版本8-4及以上！）\"><a href=\"#日志收集（版本8-4及以上！）\" class=\"headerlink\" title=\"日志收集（版本8.4及以上！）\"></a>日志收集（版本8.4及以上！）</h2><p><strong>ps：SpringBoot默认的日志框架是logback，这里介绍的也是基于logback的日志收集方法，可以配合Lombok的@Slf4j正常使用</strong>****</p>\n<p>依赖：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.skywalking&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;apm-toolkit-trace&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;8.5.0&lt;&#x2F;version&gt; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;该版本最好和skyWalking的版本对应\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.skywalking&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;apm-toolkit-logback-1.x&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;8.5.0&lt;&#x2F;version&gt; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;该版本最好和skyWalking的版本对应\n&lt;&#x2F;dependency&gt;</code></pre>\n\n\n\n<p>在resource下创建logback-spring.xml文件</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;configuration scan&#x3D;&quot;true&quot; scanPeriod&#x3D;&quot;10 seconds&quot;&gt;\n\n    &lt;appender name&#x3D;&quot;stdout&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;用来格式化日志输出的\n        &lt;encoder class&#x3D;&quot;ch.qos.logback.core.encoder.LayoutWrappingEncoder&quot;&gt;\n            &lt;layout class&#x3D;&quot;org.apache.skywalking.apm.toolkit.log.logback.v1.x.TraceIdPatternLogbackLayout&quot;&gt;\n                &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%tid] [%thread] %-5level %logger&#123;36&#125; -%msg%n&lt;&#x2F;Pattern&gt;\n            &lt;&#x2F;layout&gt;\n        &lt;&#x2F;encoder&gt;\n    &lt;&#x2F;appender&gt;\n\n    &lt;appender name&#x3D;&quot;grpc&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;用来上报日志的class&#x3D;&quot;org.apache.skywalking.apm.toolkit.log.logback.v1.x.log.GRPCLogClientAppender&quot;&gt;\n        &lt;encoder class&#x3D;&quot;ch.qos.logback.core.encoder.LayoutWrappingEncoder&quot;&gt;\n            &lt;layout class&#x3D;&quot;org.apache.skywalking.apm.toolkit.log.logback.v1.x.mdc.TraceIdMDCPatternLogbackLayout&quot;&gt;\n                &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;tid&#125;] [%thread] %-5level %logger&#123;36&#125; -%msg%n&lt;&#x2F;Pattern&gt;\n            &lt;&#x2F;layout&gt;\n        &lt;&#x2F;encoder&gt;\n    &lt;&#x2F;appender&gt;\n\n    &lt;root level&#x3D;&quot;INFO&quot;&gt;\n        &lt;appender-ref ref&#x3D;&quot;stdout&quot;&#x2F;&gt; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;用来格式化日志输出的\n        &lt;appender-ref ref&#x3D;&quot;grpc&quot;&#x2F;&gt; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;用来上报日志的\n    &lt;&#x2F;root&gt;\n&lt;&#x2F;configuration&gt;</code></pre>\n\n<p>如果服务和skyWalking不在同一个服务器上，还需要在agent文件夹下的config的agent.config中添加如下配置：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">plugin.toolkit.log.grpc.reporter.server_host&#x3D;$&#123;SW_GRPC_LOG_SERVER_HOST:172.28.231.100&#125;  &#x3D;&#x3D;&#x3D;地址\nplugin.toolkit.log.grpc.reporter.server_port&#x3D;$&#123;SW_GRPC_LOG_SERVER_PORT:11800&#125; &#x3D;&#x3D;&#x3D;端口\nplugin.toolkit.log.grpc.reporter.max_message_size&#x3D;$&#123;SW_GRPC_LOG_MAX_MESSAGE_SIZE:10485760&#125; &#x3D;&#x3D;&#x3D;最大日志大小\nplugin.toolkit.log.grpc.reporter.upstream_timeout&#x3D;$&#123;SW_GRPC_LOG_GRPC_UPSTREAM_TIMEOUT:30&#125; </code></pre>\n\n<p>如何定位某条日志对应的调用链路？</p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220918111842645.png\" alt=\"image-20220918111842645\"></p>\n<p>通过该TID在skyWalking中进行搜索，不支持模糊查询</p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220918111916766.png\" alt=\"image-20220918111916766\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SkyWalking\"><a href=\"#SkyWalking\" class=\"headerlink\" title=\"SkyWalking\"></a>SkyWalking</h1><h3 id=\"下载地址：http-skywalking-apache-org-downloads\"><a href=\"#下载地址：http-skywalking-apache-org-downloads\" class=\"headerlink\" title=\"下载地址：http://skywalking.apache.org/downloads/\"></a>下载地址：<a href=\"http://skywalking.apache.org/downloads/\">http://skywalking.apache.org/downloads/</a></h3><h2 id=\"概念：\"><a href=\"#概念：\" class=\"headerlink\" title=\"概念：\"></a>概念：</h2><p>可实现基于Open Tracing规范的分布式链路追踪功能的APM应用性能管理平台</p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823114137847.png\" alt=\"image-20220823114137847\"></p>\n<h3 id=\"UI界面的jar包和配置文件（可修改端-口）\"><a href=\"#UI界面的jar包和配置文件（可修改端-口）\" class=\"headerlink\" title=\"UI界面的jar包和配置文件（可修改端  口）\"></a>UI界面的jar包和配置文件（可修改端  口）</h3><p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823114222953.png\" alt=\"image-20220823114222953\"></p>\n<p>修改skywalking服务端数据存储方式：</p>\n<p>默认是使用H2进行存储，如果服务端重启的话，数据就会丢失，推荐使用es存储，可以在如下位置处进行修改：</p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823134907000.png\" alt=\"image-20220823134907000\"></p>\n<p>selector处修改为elasticsearch，然后修改es的一些默认配置即可</p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823134723074.png\" alt=\"image-20220823134723074\"></p>\n<h3 id=\"端口说明\"><a href=\"#端口说明\" class=\"headerlink\" title=\"端口说明\"></a>端口说明</h3><p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220823114611913.png\" alt=\"image-20220823114611913\"></p>\n<h2 id=\"服务接入\"><a href=\"#服务接入\" class=\"headerlink\" title=\"服务接入\"></a>服务接入</h2><p>比如我需要在window系统上启动一个需要被监控的服务，就需要在这个系统上提前准备一个和skywalking服务端对应版本的skywalking-agent.jar</p>\n<p>下载地址：<a href=\"https://archive.apache.org/dist/skywalking/%EF%BC%8C%E8%A7%A3%E5%8E%8B%E5%90%8E%E5%9C%A8%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%8D%B3%E5%8F%AF%E6%89%BE%E5%88%B0%EF%BC%8C170%E5%A4%9AMB%E7%9A%84%E9%82%A3%E4%B8%AA\">https://archive.apache.org/dist/skywalking/，解压后在根目录即可找到，170多MB的那个</a></p>\n<ul>\n<li>如果是通过idea启动的话，在启动配置的VM参数处填入以下：</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">-javaagent:C:\\_Code\\lcss\\lcss-gateway\\agent\\skywalking-agent.jar #jar包具体位置\n-Dskywalking.agent.service_name&#x3D;lcss-gateway #服务名，最好与nacos中的名字对应\n-Dskywalking.collector.backend_service&#x3D;192.168.1.104:11800 #skywalking服务端暴露的收集数据的端口</code></pre>\n\n<ul>\n<li>如果是在docker中的话：</li>\n</ul>\n<p>同样需要提前准备agent（包含有jar包）</p>\n<p>原本项目的启动方式：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">java -jar spring-boot-demo-0.0.1-SNAPSHOT.jar</code></pre>\n\n<p>现在变为：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">java -javaagent:&#x2F;opt&#x2F;apache-skywalking-apm-bin&#x2F;agent&#x2F;skywalking-agent.jar -Dskywalking.agent.service_name&#x3D;服务名 -Dskywalking.collector.backend_service&#x3D;127.0.0.1:11800 -jar &#x2F;opt&#x2F;spring-boot-demo-0.0.1-SNAPSHOT.jar</code></pre>\n\n\n\n<h3 id=\"操作如下：\"><a href=\"#操作如下：\" class=\"headerlink\" title=\"操作如下：\"></a>操作如下：</h3><p>与Src目录平级下建一个agent文件夹，放agent文件夹（从如下路径拷贝来的）</p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220916142200142.png\" alt=\"image-20220916142200142\"></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220916142128932.png\" alt=\"image-20220916142128932\"></p>\n<p>文件：</p>\n<pre class=\"line-numbers language-docker\" data-language=\"docker\"><code class=\"language-docker\">FROM openjdk:8-jdk-alpine\n\nRUN mkdir -p &#x2F;lcss-gateway\n\nWORKDIR &#x2F;lcss-gateway\n\nARG JAR_FILE&#x3D;target&#x2F;lcss-gateway.jar\n\nCOPY $&#123;JAR_FILE&#125; app.jar\nCOPY agent &#x2F;lcss-gateway&#x2F;agent &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;&gt;关键,把agent的jar包复制到容器中\n\nEXPOSE 20010\n\nENTRYPOINT [&quot;java&quot;, &quot;-javaagent:&#x2F;lcss-gateway&#x2F;agent&#x2F;skywalking-agent.jar&quot;, &quot;-Dskywalking.agent.service_name&#x3D;lcss-gateway&quot;,&quot;-Dskywalking.collector.backend_service&#x3D;192.168.1.104:11800&quot;, &quot;-jar&quot;,&quot;app.jar&quot;]</code></pre>\n\n<h3 id=\"ps-docker部署启动的时候提示config没找到的踩坑\"><a href=\"#ps-docker部署启动的时候提示config没找到的踩坑\" class=\"headerlink\" title=\"ps:docker部署启动的时候提示config没找到的踩坑\"></a>ps:docker部署启动的时候提示config没找到的踩坑</h3><p>项目的agent不能只拷贝一个jar包，需要把整个agent文件夹都拷贝进去，因为里面还有配置文件！！</p>\n<h2 id=\"日志收集（版本8-4及以上！）\"><a href=\"#日志收集（版本8-4及以上！）\" class=\"headerlink\" title=\"日志收集（版本8.4及以上！）\"></a>日志收集（版本8.4及以上！）</h2><p><strong>ps：SpringBoot默认的日志框架是logback，这里介绍的也是基于logback的日志收集方法，可以配合Lombok的@Slf4j正常使用</strong>****</p>\n<p>依赖：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.skywalking&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;apm-toolkit-trace&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;8.5.0&lt;&#x2F;version&gt; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;该版本最好和skyWalking的版本对应\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.skywalking&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;apm-toolkit-logback-1.x&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;8.5.0&lt;&#x2F;version&gt; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;该版本最好和skyWalking的版本对应\n&lt;&#x2F;dependency&gt;</code></pre>\n\n\n\n<p>在resource下创建logback-spring.xml文件</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;configuration scan&#x3D;&quot;true&quot; scanPeriod&#x3D;&quot;10 seconds&quot;&gt;\n\n    &lt;appender name&#x3D;&quot;stdout&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;用来格式化日志输出的\n        &lt;encoder class&#x3D;&quot;ch.qos.logback.core.encoder.LayoutWrappingEncoder&quot;&gt;\n            &lt;layout class&#x3D;&quot;org.apache.skywalking.apm.toolkit.log.logback.v1.x.TraceIdPatternLogbackLayout&quot;&gt;\n                &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%tid] [%thread] %-5level %logger&#123;36&#125; -%msg%n&lt;&#x2F;Pattern&gt;\n            &lt;&#x2F;layout&gt;\n        &lt;&#x2F;encoder&gt;\n    &lt;&#x2F;appender&gt;\n\n    &lt;appender name&#x3D;&quot;grpc&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;用来上报日志的class&#x3D;&quot;org.apache.skywalking.apm.toolkit.log.logback.v1.x.log.GRPCLogClientAppender&quot;&gt;\n        &lt;encoder class&#x3D;&quot;ch.qos.logback.core.encoder.LayoutWrappingEncoder&quot;&gt;\n            &lt;layout class&#x3D;&quot;org.apache.skywalking.apm.toolkit.log.logback.v1.x.mdc.TraceIdMDCPatternLogbackLayout&quot;&gt;\n                &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;tid&#125;] [%thread] %-5level %logger&#123;36&#125; -%msg%n&lt;&#x2F;Pattern&gt;\n            &lt;&#x2F;layout&gt;\n        &lt;&#x2F;encoder&gt;\n    &lt;&#x2F;appender&gt;\n\n    &lt;root level&#x3D;&quot;INFO&quot;&gt;\n        &lt;appender-ref ref&#x3D;&quot;stdout&quot;&#x2F;&gt; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;用来格式化日志输出的\n        &lt;appender-ref ref&#x3D;&quot;grpc&quot;&#x2F;&gt; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;用来上报日志的\n    &lt;&#x2F;root&gt;\n&lt;&#x2F;configuration&gt;</code></pre>\n\n<p>如果服务和skyWalking不在同一个服务器上，还需要在agent文件夹下的config的agent.config中添加如下配置：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">plugin.toolkit.log.grpc.reporter.server_host&#x3D;$&#123;SW_GRPC_LOG_SERVER_HOST:172.28.231.100&#125;  &#x3D;&#x3D;&#x3D;地址\nplugin.toolkit.log.grpc.reporter.server_port&#x3D;$&#123;SW_GRPC_LOG_SERVER_PORT:11800&#125; &#x3D;&#x3D;&#x3D;端口\nplugin.toolkit.log.grpc.reporter.max_message_size&#x3D;$&#123;SW_GRPC_LOG_MAX_MESSAGE_SIZE:10485760&#125; &#x3D;&#x3D;&#x3D;最大日志大小\nplugin.toolkit.log.grpc.reporter.upstream_timeout&#x3D;$&#123;SW_GRPC_LOG_GRPC_UPSTREAM_TIMEOUT:30&#125; </code></pre>\n\n<p>如何定位某条日志对应的调用链路？</p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220918111842645.png\" alt=\"image-20220918111842645\"></p>\n<p>通过该TID在skyWalking中进行搜索，不支持模糊查询</p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220918111916766.png\" alt=\"image-20220918111916766\"></p>\n"},{"title":"分布式ID","description":"分布式ID的生成与使用","cover":"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/4k%20%E7%BE%8E%E5%A5%B3%20%E7%99%BD%E8%89%B2%E5%8F%A4%E8%A3%85%20%E5%8F%A4%E9%A3%8E%20%D0%A1%CF%AA%20%E7%80%91%E5%B8%83%20%E5%B2%A9%E7%9F%B3%20%E9%AB%98%E6%B8%85%20%E5%A3%81%E7%BA%B8_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg","_content":"\n![4k 美女 白色古装 古风 СϪ 瀑布 岩石 高清 壁纸_彼岸图网](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/4k%20%E7%BE%8E%E5%A5%B3%20%E7%99%BD%E8%89%B2%E5%8F%A4%E8%A3%85%20%E5%8F%A4%E9%A3%8E%20%D0%A1%CF%AA%20%E7%80%91%E5%B8%83%20%E5%B2%A9%E7%9F%B3%20%E9%AB%98%E6%B8%85%20%E5%A3%81%E7%BA%B8_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg)\n\n# 分布式ID\n\n## 雪花算法\n\n![image-20220720144035556](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220720144035556.png)\n\n共64位，这三个部分是保证唯一性的重要条件，缺一不可，但是可以根据业务需要调整他们占用的位数，添加其他的信息，比如业务代码。\n\n## 工作流程\n\n![img](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/1734261-20220210191137958-980879319.png)\n\n还需要配合Redis一起使用\n\n## 雪花算法生成ID配合Redis使用实现集群唯一ID(长度为18位)\n\n```java\n/**\n * @author sungm\n * @since 2021-11-06 21:16\n */\n@Slf4j\n@Service\npublic class SnowflakeManager {\n\n    /** 开始时间戳: 2020-01-01 00:00:00 */\n    private static final Long START_TIMESTAMP = 1577808000000L;\n    /** 12位最大序号: 2^12 - 1 */\n    private static final Long MAX_SEQ = ~(-1L << 12);\n    /** 10位最大机器码： 2^10 -1 */\n    private static final Long MAX_MACHINE = ~(-1L << 10);\n\n    /** 当前机器码 */\n    private Long machine;\n    /** 最后生成的序号 */\n    private Long lastSeq = 0L;\n    /** 最后一个序号生成的时间 */\n    private Long lastSqlTimestamp = 0L;\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    /** 定义雪花算法的 Key，把机器码存到Redis中 */\n    private static final String RECORD_SNOWFLAKE_MACHINE_SEQ_REDIS_KEY = \"RECORD_SNOWFLAKE_MACHINE_SEQ\";\n    private static final String RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY = \"RECORD_SNOWFLAKE_MACHINE_MAP\";\n\n    @PostConstruct\n    public void init() throws UnknownHostException {\n        //获取当前机器的IP地址\n        final String hostAddress = InetAddress.getLocalHost().getHostAddress();\n        //初始化Redis缓存\n        stringRedisTemplate.opsForValue().setIfAbsent(RECORD_SNOWFLAKE_MACHINE_SEQ_REDIS_KEY, \"0\");\n        stringRedisTemplate.opsForHash().putIfAbsent(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY, \"default\", \"0\");\n        //不包含当前主机IP地址时，设置递增的值\n        if (!stringRedisTemplate.opsForHash().keys(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY).contains(hostAddress)) {\n            stringRedisTemplate.opsForHash().put(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY, hostAddress\n                    , stringRedisTemplate.opsForValue().increment(RECORD_SNOWFLAKE_MACHINE_SEQ_REDIS_KEY, 1L).toString());\n        }\n        //获取当前主机对应的编码\n        machine = Long.parseLong((String) stringRedisTemplate.opsForHash().get(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY, hostAddress));\n        log.info(\"主机：{}，机器码：{}\", hostAddress, machine);\n        //做个校验\n        if (machine > MAX_MACHINE) {\n            throw new RuntimeException(\"机器码已达到最大值\" + MAX_MACHINE + \", 请排查无效数据！\");\n        }\n    }\n\n    public synchronized Long nextId() {\n        //获取当前时间\n        Long now = System.currentTimeMillis();\n        if (lastSqlTimestamp.equals(now) && ++lastSeq > MAX_SEQ) {\n            throw new RuntimeException(\"同一毫秒内生成的序号达到\" + MAX_SEQ + \", 请注意并发量！\");\n        }\n        if (!lastSqlTimestamp.equals(now)) {\n            lastSeq = 0L;\n        }\n        lastSqlTimestamp = now;\n        /* 0 - 41位时间戳 - 10位机器码 - 12位序列*/\n        return ((now - START_TIMESTAMP) << 22) | machine << 12 | lastSeq;\n    }\n\n}\n```\n\n","source":"_posts/Java/分布式ID.md","raw":"---\ntitle: 分布式ID\n\ncategories: \n- 技术\n- 分布式\n\ntags:\n- Java\n- 分布式\n\ndescription: 分布式ID的生成与使用\n\ncover: https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/4k%20%E7%BE%8E%E5%A5%B3%20%E7%99%BD%E8%89%B2%E5%8F%A4%E8%A3%85%20%E5%8F%A4%E9%A3%8E%20%D0%A1%CF%AA%20%E7%80%91%E5%B8%83%20%E5%B2%A9%E7%9F%B3%20%E9%AB%98%E6%B8%85%20%E5%A3%81%E7%BA%B8_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg\n---\n\n![4k 美女 白色古装 古风 СϪ 瀑布 岩石 高清 壁纸_彼岸图网](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/4k%20%E7%BE%8E%E5%A5%B3%20%E7%99%BD%E8%89%B2%E5%8F%A4%E8%A3%85%20%E5%8F%A4%E9%A3%8E%20%D0%A1%CF%AA%20%E7%80%91%E5%B8%83%20%E5%B2%A9%E7%9F%B3%20%E9%AB%98%E6%B8%85%20%E5%A3%81%E7%BA%B8_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg)\n\n# 分布式ID\n\n## 雪花算法\n\n![image-20220720144035556](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220720144035556.png)\n\n共64位，这三个部分是保证唯一性的重要条件，缺一不可，但是可以根据业务需要调整他们占用的位数，添加其他的信息，比如业务代码。\n\n## 工作流程\n\n![img](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/1734261-20220210191137958-980879319.png)\n\n还需要配合Redis一起使用\n\n## 雪花算法生成ID配合Redis使用实现集群唯一ID(长度为18位)\n\n```java\n/**\n * @author sungm\n * @since 2021-11-06 21:16\n */\n@Slf4j\n@Service\npublic class SnowflakeManager {\n\n    /** 开始时间戳: 2020-01-01 00:00:00 */\n    private static final Long START_TIMESTAMP = 1577808000000L;\n    /** 12位最大序号: 2^12 - 1 */\n    private static final Long MAX_SEQ = ~(-1L << 12);\n    /** 10位最大机器码： 2^10 -1 */\n    private static final Long MAX_MACHINE = ~(-1L << 10);\n\n    /** 当前机器码 */\n    private Long machine;\n    /** 最后生成的序号 */\n    private Long lastSeq = 0L;\n    /** 最后一个序号生成的时间 */\n    private Long lastSqlTimestamp = 0L;\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    /** 定义雪花算法的 Key，把机器码存到Redis中 */\n    private static final String RECORD_SNOWFLAKE_MACHINE_SEQ_REDIS_KEY = \"RECORD_SNOWFLAKE_MACHINE_SEQ\";\n    private static final String RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY = \"RECORD_SNOWFLAKE_MACHINE_MAP\";\n\n    @PostConstruct\n    public void init() throws UnknownHostException {\n        //获取当前机器的IP地址\n        final String hostAddress = InetAddress.getLocalHost().getHostAddress();\n        //初始化Redis缓存\n        stringRedisTemplate.opsForValue().setIfAbsent(RECORD_SNOWFLAKE_MACHINE_SEQ_REDIS_KEY, \"0\");\n        stringRedisTemplate.opsForHash().putIfAbsent(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY, \"default\", \"0\");\n        //不包含当前主机IP地址时，设置递增的值\n        if (!stringRedisTemplate.opsForHash().keys(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY).contains(hostAddress)) {\n            stringRedisTemplate.opsForHash().put(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY, hostAddress\n                    , stringRedisTemplate.opsForValue().increment(RECORD_SNOWFLAKE_MACHINE_SEQ_REDIS_KEY, 1L).toString());\n        }\n        //获取当前主机对应的编码\n        machine = Long.parseLong((String) stringRedisTemplate.opsForHash().get(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY, hostAddress));\n        log.info(\"主机：{}，机器码：{}\", hostAddress, machine);\n        //做个校验\n        if (machine > MAX_MACHINE) {\n            throw new RuntimeException(\"机器码已达到最大值\" + MAX_MACHINE + \", 请排查无效数据！\");\n        }\n    }\n\n    public synchronized Long nextId() {\n        //获取当前时间\n        Long now = System.currentTimeMillis();\n        if (lastSqlTimestamp.equals(now) && ++lastSeq > MAX_SEQ) {\n            throw new RuntimeException(\"同一毫秒内生成的序号达到\" + MAX_SEQ + \", 请注意并发量！\");\n        }\n        if (!lastSqlTimestamp.equals(now)) {\n            lastSeq = 0L;\n        }\n        lastSqlTimestamp = now;\n        /* 0 - 41位时间戳 - 10位机器码 - 12位序列*/\n        return ((now - START_TIMESTAMP) << 22) | machine << 12 | lastSeq;\n    }\n\n}\n```\n\n","slug":"Java/分布式ID","published":1,"date":"2022-07-20T01:57:56.986Z","updated":"2022-11-03T23:44:08.464Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbrcchl70005qkiqb05v6x1x","content":"<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/4k%20%E7%BE%8E%E5%A5%B3%20%E7%99%BD%E8%89%B2%E5%8F%A4%E8%A3%85%20%E5%8F%A4%E9%A3%8E%20%D0%A1%CF%AA%20%E7%80%91%E5%B8%83%20%E5%B2%A9%E7%9F%B3%20%E9%AB%98%E6%B8%85%20%E5%A3%81%E7%BA%B8_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg\" alt=\"4k 美女 白色古装 古风 СϪ 瀑布 岩石 高清 壁纸_彼岸图网\"></p>\n<h1 id=\"分布式ID\"><a href=\"#分布式ID\" class=\"headerlink\" title=\"分布式ID\"></a>分布式ID</h1><h2 id=\"雪花算法\"><a href=\"#雪花算法\" class=\"headerlink\" title=\"雪花算法\"></a>雪花算法</h2><p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220720144035556.png\" alt=\"image-20220720144035556\"></p>\n<p>共64位，这三个部分是保证唯一性的重要条件，缺一不可，但是可以根据业务需要调整他们占用的位数，添加其他的信息，比如业务代码。</p>\n<h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/1734261-20220210191137958-980879319.png\" alt=\"img\"></p>\n<p>还需要配合Redis一起使用</p>\n<h2 id=\"雪花算法生成ID配合Redis使用实现集群唯一ID-长度为18位\"><a href=\"#雪花算法生成ID配合Redis使用实现集群唯一ID-长度为18位\" class=\"headerlink\" title=\"雪花算法生成ID配合Redis使用实现集群唯一ID(长度为18位)\"></a>雪花算法生成ID配合Redis使用实现集群唯一ID(长度为18位)</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * @author sungm\n * @since 2021-11-06 21:16\n *&#x2F;\n@Slf4j\n@Service\npublic class SnowflakeManager &#123;\n\n    &#x2F;** 开始时间戳: 2020-01-01 00:00:00 *&#x2F;\n    private static final Long START_TIMESTAMP &#x3D; 1577808000000L;\n    &#x2F;** 12位最大序号: 2^12 - 1 *&#x2F;\n    private static final Long MAX_SEQ &#x3D; ~(-1L &lt;&lt; 12);\n    &#x2F;** 10位最大机器码： 2^10 -1 *&#x2F;\n    private static final Long MAX_MACHINE &#x3D; ~(-1L &lt;&lt; 10);\n\n    &#x2F;** 当前机器码 *&#x2F;\n    private Long machine;\n    &#x2F;** 最后生成的序号 *&#x2F;\n    private Long lastSeq &#x3D; 0L;\n    &#x2F;** 最后一个序号生成的时间 *&#x2F;\n    private Long lastSqlTimestamp &#x3D; 0L;\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    &#x2F;** 定义雪花算法的 Key，把机器码存到Redis中 *&#x2F;\n    private static final String RECORD_SNOWFLAKE_MACHINE_SEQ_REDIS_KEY &#x3D; &quot;RECORD_SNOWFLAKE_MACHINE_SEQ&quot;;\n    private static final String RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY &#x3D; &quot;RECORD_SNOWFLAKE_MACHINE_MAP&quot;;\n\n    @PostConstruct\n    public void init() throws UnknownHostException &#123;\n        &#x2F;&#x2F;获取当前机器的IP地址\n        final String hostAddress &#x3D; InetAddress.getLocalHost().getHostAddress();\n        &#x2F;&#x2F;初始化Redis缓存\n        stringRedisTemplate.opsForValue().setIfAbsent(RECORD_SNOWFLAKE_MACHINE_SEQ_REDIS_KEY, &quot;0&quot;);\n        stringRedisTemplate.opsForHash().putIfAbsent(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY, &quot;default&quot;, &quot;0&quot;);\n        &#x2F;&#x2F;不包含当前主机IP地址时，设置递增的值\n        if (!stringRedisTemplate.opsForHash().keys(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY).contains(hostAddress)) &#123;\n            stringRedisTemplate.opsForHash().put(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY, hostAddress\n                    , stringRedisTemplate.opsForValue().increment(RECORD_SNOWFLAKE_MACHINE_SEQ_REDIS_KEY, 1L).toString());\n        &#125;\n        &#x2F;&#x2F;获取当前主机对应的编码\n        machine &#x3D; Long.parseLong((String) stringRedisTemplate.opsForHash().get(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY, hostAddress));\n        log.info(&quot;主机：&#123;&#125;，机器码：&#123;&#125;&quot;, hostAddress, machine);\n        &#x2F;&#x2F;做个校验\n        if (machine &gt; MAX_MACHINE) &#123;\n            throw new RuntimeException(&quot;机器码已达到最大值&quot; + MAX_MACHINE + &quot;, 请排查无效数据！&quot;);\n        &#125;\n    &#125;\n\n    public synchronized Long nextId() &#123;\n        &#x2F;&#x2F;获取当前时间\n        Long now &#x3D; System.currentTimeMillis();\n        if (lastSqlTimestamp.equals(now) &amp;&amp; ++lastSeq &gt; MAX_SEQ) &#123;\n            throw new RuntimeException(&quot;同一毫秒内生成的序号达到&quot; + MAX_SEQ + &quot;, 请注意并发量！&quot;);\n        &#125;\n        if (!lastSqlTimestamp.equals(now)) &#123;\n            lastSeq &#x3D; 0L;\n        &#125;\n        lastSqlTimestamp &#x3D; now;\n        &#x2F;* 0 - 41位时间戳 - 10位机器码 - 12位序列*&#x2F;\n        return ((now - START_TIMESTAMP) &lt;&lt; 22) | machine &lt;&lt; 12 | lastSeq;\n    &#125;\n\n&#125;</code></pre>\n\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/4k%20%E7%BE%8E%E5%A5%B3%20%E7%99%BD%E8%89%B2%E5%8F%A4%E8%A3%85%20%E5%8F%A4%E9%A3%8E%20%D0%A1%CF%AA%20%E7%80%91%E5%B8%83%20%E5%B2%A9%E7%9F%B3%20%E9%AB%98%E6%B8%85%20%E5%A3%81%E7%BA%B8_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg\" alt=\"4k 美女 白色古装 古风 СϪ 瀑布 岩石 高清 壁纸_彼岸图网\"></p>\n<h1 id=\"分布式ID\"><a href=\"#分布式ID\" class=\"headerlink\" title=\"分布式ID\"></a>分布式ID</h1><h2 id=\"雪花算法\"><a href=\"#雪花算法\" class=\"headerlink\" title=\"雪花算法\"></a>雪花算法</h2><p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220720144035556.png\" alt=\"image-20220720144035556\"></p>\n<p>共64位，这三个部分是保证唯一性的重要条件，缺一不可，但是可以根据业务需要调整他们占用的位数，添加其他的信息，比如业务代码。</p>\n<h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/1734261-20220210191137958-980879319.png\" alt=\"img\"></p>\n<p>还需要配合Redis一起使用</p>\n<h2 id=\"雪花算法生成ID配合Redis使用实现集群唯一ID-长度为18位\"><a href=\"#雪花算法生成ID配合Redis使用实现集群唯一ID-长度为18位\" class=\"headerlink\" title=\"雪花算法生成ID配合Redis使用实现集群唯一ID(长度为18位)\"></a>雪花算法生成ID配合Redis使用实现集群唯一ID(长度为18位)</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * @author sungm\n * @since 2021-11-06 21:16\n *&#x2F;\n@Slf4j\n@Service\npublic class SnowflakeManager &#123;\n\n    &#x2F;** 开始时间戳: 2020-01-01 00:00:00 *&#x2F;\n    private static final Long START_TIMESTAMP &#x3D; 1577808000000L;\n    &#x2F;** 12位最大序号: 2^12 - 1 *&#x2F;\n    private static final Long MAX_SEQ &#x3D; ~(-1L &lt;&lt; 12);\n    &#x2F;** 10位最大机器码： 2^10 -1 *&#x2F;\n    private static final Long MAX_MACHINE &#x3D; ~(-1L &lt;&lt; 10);\n\n    &#x2F;** 当前机器码 *&#x2F;\n    private Long machine;\n    &#x2F;** 最后生成的序号 *&#x2F;\n    private Long lastSeq &#x3D; 0L;\n    &#x2F;** 最后一个序号生成的时间 *&#x2F;\n    private Long lastSqlTimestamp &#x3D; 0L;\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    &#x2F;** 定义雪花算法的 Key，把机器码存到Redis中 *&#x2F;\n    private static final String RECORD_SNOWFLAKE_MACHINE_SEQ_REDIS_KEY &#x3D; &quot;RECORD_SNOWFLAKE_MACHINE_SEQ&quot;;\n    private static final String RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY &#x3D; &quot;RECORD_SNOWFLAKE_MACHINE_MAP&quot;;\n\n    @PostConstruct\n    public void init() throws UnknownHostException &#123;\n        &#x2F;&#x2F;获取当前机器的IP地址\n        final String hostAddress &#x3D; InetAddress.getLocalHost().getHostAddress();\n        &#x2F;&#x2F;初始化Redis缓存\n        stringRedisTemplate.opsForValue().setIfAbsent(RECORD_SNOWFLAKE_MACHINE_SEQ_REDIS_KEY, &quot;0&quot;);\n        stringRedisTemplate.opsForHash().putIfAbsent(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY, &quot;default&quot;, &quot;0&quot;);\n        &#x2F;&#x2F;不包含当前主机IP地址时，设置递增的值\n        if (!stringRedisTemplate.opsForHash().keys(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY).contains(hostAddress)) &#123;\n            stringRedisTemplate.opsForHash().put(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY, hostAddress\n                    , stringRedisTemplate.opsForValue().increment(RECORD_SNOWFLAKE_MACHINE_SEQ_REDIS_KEY, 1L).toString());\n        &#125;\n        &#x2F;&#x2F;获取当前主机对应的编码\n        machine &#x3D; Long.parseLong((String) stringRedisTemplate.opsForHash().get(RECORD_SNOWFLAKE_MACHINE_MAP_REDIS_KEY, hostAddress));\n        log.info(&quot;主机：&#123;&#125;，机器码：&#123;&#125;&quot;, hostAddress, machine);\n        &#x2F;&#x2F;做个校验\n        if (machine &gt; MAX_MACHINE) &#123;\n            throw new RuntimeException(&quot;机器码已达到最大值&quot; + MAX_MACHINE + &quot;, 请排查无效数据！&quot;);\n        &#125;\n    &#125;\n\n    public synchronized Long nextId() &#123;\n        &#x2F;&#x2F;获取当前时间\n        Long now &#x3D; System.currentTimeMillis();\n        if (lastSqlTimestamp.equals(now) &amp;&amp; ++lastSeq &gt; MAX_SEQ) &#123;\n            throw new RuntimeException(&quot;同一毫秒内生成的序号达到&quot; + MAX_SEQ + &quot;, 请注意并发量！&quot;);\n        &#125;\n        if (!lastSqlTimestamp.equals(now)) &#123;\n            lastSeq &#x3D; 0L;\n        &#125;\n        lastSqlTimestamp &#x3D; now;\n        &#x2F;* 0 - 41位时间戳 - 10位机器码 - 12位序列*&#x2F;\n        return ((now - START_TIMESTAMP) &lt;&lt; 22) | machine &lt;&lt; 12 | lastSeq;\n    &#125;\n\n&#125;</code></pre>\n\n"},{"title":"分布式Session","description":"分布式Session的生成与使用","cover":"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/4k%20%E5%88%9D%E9%9F%B3%20%E5%A5%B3%E5%AD%A9%20%E7%AC%9B%E5%AD%90%20%E9%95%BF%E5%8F%91%20%E9%95%BF%E8%A3%99%E5%AD%90%20%E5%8A%A8%E6%BC%AB%E5%A3%81%E7%BA%B8_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg","_content":"\n![4k 初音 女孩 笛子 长发 长裙子 动漫壁纸_彼岸图网](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/4k%20%E5%88%9D%E9%9F%B3%20%E5%A5%B3%E5%AD%A9%20%E7%AC%9B%E5%AD%90%20%E9%95%BF%E5%8F%91%20%E9%95%BF%E8%A3%99%E5%AD%90%20%E5%8A%A8%E6%BC%AB%E5%A3%81%E7%BA%B8_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg)\n\n# 分布式Session\n\n<img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220720101945526.png\" alt=\"image-20220720101945526\" style=\"zoom: 200%;\" />\n\n## Session\n\n### 本质：\n\n**session技术就是一种基于后端有别于数据库的临时存储数据的技术**\n\n\n\n### 存活时间：\n\n可以通过如下来设置一次Session的存活时间，在这个时间内若再次发送请求，则Session的存活时间将会刷新，若超过时间无请求发送，再次发送的时候会再次创建一次新的Session会话。\n\n```java\nHttpSession session = request.getSession();\nsession.setMaxInactiveInterval(2); //单位是秒\n\nsession.getId(); //查看session的唯一标识\n```\n\n### 实现\n\n添加redis官方的实现依赖即可，可以在配置类上添加如下注解，配置相关参数\n\n```xml\n        <dependency>\n            <groupId>org.springframework.session</groupId>\n            <artifactId>spring-session-data-redis</artifactId>\n            <version>2.7.0</version>\n        </dependency>\n```\n\n可以在配置类上添加如下注解，配置相关参数\n\n```java\n@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600 #Session的存活时间,redisNamespace = \"session_info存储在redis中的命名空间\",flushMode = FlushMode.IMMEDIATE #刷新策略,saveMode = SaveMode.ON_SET_ATTRIBUTE #刷新策略)\n```\n\n#### 刷新策略\n\n- ON_SAVE: 只有当SessionRepository.save(Session)方法被调用时,才会将session中的数据同步到redis中. 在web 应用中, 当请求完成响应后, 才开始同步. 也就是说在执行response之前session数据都是缓存在本地的.\n- IMMEDIATE: 实时同步session 数据到redis. 当执行SessionRepository.createSession()时, 会将session数据同步到redis中;当对session的attribute进行set/remove 等操作时, 也会同步session中的数据到redis中.\n\n#### 保存策略\n\n保存Session属性更改的时机，是调用Set属性方法时保存还是Get属性方法调用的时候保存，还是总是保存，一般默认即可。","source":"_posts/Java/分布式Session.md","raw":"---\ntitle: 分布式Session\n\ncategories: \n- 技术\n- 分布式\n\ntags:\n- Java\n- 分布式\n\ndescription: 分布式Session的生成与使用\n\ncover: https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/4k%20%E5%88%9D%E9%9F%B3%20%E5%A5%B3%E5%AD%A9%20%E7%AC%9B%E5%AD%90%20%E9%95%BF%E5%8F%91%20%E9%95%BF%E8%A3%99%E5%AD%90%20%E5%8A%A8%E6%BC%AB%E5%A3%81%E7%BA%B8_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg\n---\n\n![4k 初音 女孩 笛子 长发 长裙子 动漫壁纸_彼岸图网](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/4k%20%E5%88%9D%E9%9F%B3%20%E5%A5%B3%E5%AD%A9%20%E7%AC%9B%E5%AD%90%20%E9%95%BF%E5%8F%91%20%E9%95%BF%E8%A3%99%E5%AD%90%20%E5%8A%A8%E6%BC%AB%E5%A3%81%E7%BA%B8_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg)\n\n# 分布式Session\n\n<img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220720101945526.png\" alt=\"image-20220720101945526\" style=\"zoom: 200%;\" />\n\n## Session\n\n### 本质：\n\n**session技术就是一种基于后端有别于数据库的临时存储数据的技术**\n\n\n\n### 存活时间：\n\n可以通过如下来设置一次Session的存活时间，在这个时间内若再次发送请求，则Session的存活时间将会刷新，若超过时间无请求发送，再次发送的时候会再次创建一次新的Session会话。\n\n```java\nHttpSession session = request.getSession();\nsession.setMaxInactiveInterval(2); //单位是秒\n\nsession.getId(); //查看session的唯一标识\n```\n\n### 实现\n\n添加redis官方的实现依赖即可，可以在配置类上添加如下注解，配置相关参数\n\n```xml\n        <dependency>\n            <groupId>org.springframework.session</groupId>\n            <artifactId>spring-session-data-redis</artifactId>\n            <version>2.7.0</version>\n        </dependency>\n```\n\n可以在配置类上添加如下注解，配置相关参数\n\n```java\n@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600 #Session的存活时间,redisNamespace = \"session_info存储在redis中的命名空间\",flushMode = FlushMode.IMMEDIATE #刷新策略,saveMode = SaveMode.ON_SET_ATTRIBUTE #刷新策略)\n```\n\n#### 刷新策略\n\n- ON_SAVE: 只有当SessionRepository.save(Session)方法被调用时,才会将session中的数据同步到redis中. 在web 应用中, 当请求完成响应后, 才开始同步. 也就是说在执行response之前session数据都是缓存在本地的.\n- IMMEDIATE: 实时同步session 数据到redis. 当执行SessionRepository.createSession()时, 会将session数据同步到redis中;当对session的attribute进行set/remove 等操作时, 也会同步session中的数据到redis中.\n\n#### 保存策略\n\n保存Session属性更改的时机，是调用Set属性方法时保存还是Get属性方法调用的时候保存，还是总是保存，一般默认即可。","slug":"Java/分布式Session","published":1,"date":"2022-11-03T23:45:40.713Z","updated":"2022-11-03T23:47:10.776Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbrcchl80006qkiq1hdvcosa","content":"<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/4k%20%E5%88%9D%E9%9F%B3%20%E5%A5%B3%E5%AD%A9%20%E7%AC%9B%E5%AD%90%20%E9%95%BF%E5%8F%91%20%E9%95%BF%E8%A3%99%E5%AD%90%20%E5%8A%A8%E6%BC%AB%E5%A3%81%E7%BA%B8_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg\" alt=\"4k 初音 女孩 笛子 长发 长裙子 动漫壁纸_彼岸图网\"></p>\n<h1 id=\"分布式Session\"><a href=\"#分布式Session\" class=\"headerlink\" title=\"分布式Session\"></a>分布式Session</h1><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220720101945526.png\" alt=\"image-20220720101945526\" style=\"zoom: 200%;\" />\n\n<h2 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h2><h3 id=\"本质：\"><a href=\"#本质：\" class=\"headerlink\" title=\"本质：\"></a>本质：</h3><p><strong>session技术就是一种基于后端有别于数据库的临时存储数据的技术</strong></p>\n<h3 id=\"存活时间：\"><a href=\"#存活时间：\" class=\"headerlink\" title=\"存活时间：\"></a>存活时间：</h3><p>可以通过如下来设置一次Session的存活时间，在这个时间内若再次发送请求，则Session的存活时间将会刷新，若超过时间无请求发送，再次发送的时候会再次创建一次新的Session会话。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">HttpSession session &#x3D; request.getSession();\nsession.setMaxInactiveInterval(2); &#x2F;&#x2F;单位是秒\n\nsession.getId(); &#x2F;&#x2F;查看session的唯一标识</code></pre>\n\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>添加redis官方的实现依赖即可，可以在配置类上添加如下注解，配置相关参数</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.session&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-session-data-redis&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.7.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>可以在配置类上添加如下注解，配置相关参数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@EnableRedisHttpSession(maxInactiveIntervalInSeconds &#x3D; 3600 #Session的存活时间,redisNamespace &#x3D; &quot;session_info存储在redis中的命名空间&quot;,flushMode &#x3D; FlushMode.IMMEDIATE #刷新策略,saveMode &#x3D; SaveMode.ON_SET_ATTRIBUTE #刷新策略)</code></pre>\n\n<h4 id=\"刷新策略\"><a href=\"#刷新策略\" class=\"headerlink\" title=\"刷新策略\"></a>刷新策略</h4><ul>\n<li>ON_SAVE: 只有当SessionRepository.save(Session)方法被调用时,才会将session中的数据同步到redis中. 在web 应用中, 当请求完成响应后, 才开始同步. 也就是说在执行response之前session数据都是缓存在本地的.</li>\n<li>IMMEDIATE: 实时同步session 数据到redis. 当执行SessionRepository.createSession()时, 会将session数据同步到redis中;当对session的attribute进行set/remove 等操作时, 也会同步session中的数据到redis中.</li>\n</ul>\n<h4 id=\"保存策略\"><a href=\"#保存策略\" class=\"headerlink\" title=\"保存策略\"></a>保存策略</h4><p>保存Session属性更改的时机，是调用Set属性方法时保存还是Get属性方法调用的时候保存，还是总是保存，一般默认即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/4k%20%E5%88%9D%E9%9F%B3%20%E5%A5%B3%E5%AD%A9%20%E7%AC%9B%E5%AD%90%20%E9%95%BF%E5%8F%91%20%E9%95%BF%E8%A3%99%E5%AD%90%20%E5%8A%A8%E6%BC%AB%E5%A3%81%E7%BA%B8_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg\" alt=\"4k 初音 女孩 笛子 长发 长裙子 动漫壁纸_彼岸图网\"></p>\n<h1 id=\"分布式Session\"><a href=\"#分布式Session\" class=\"headerlink\" title=\"分布式Session\"></a>分布式Session</h1><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20220720101945526.png\" alt=\"image-20220720101945526\" style=\"zoom: 200%;\" />\n\n<h2 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h2><h3 id=\"本质：\"><a href=\"#本质：\" class=\"headerlink\" title=\"本质：\"></a>本质：</h3><p><strong>session技术就是一种基于后端有别于数据库的临时存储数据的技术</strong></p>\n<h3 id=\"存活时间：\"><a href=\"#存活时间：\" class=\"headerlink\" title=\"存活时间：\"></a>存活时间：</h3><p>可以通过如下来设置一次Session的存活时间，在这个时间内若再次发送请求，则Session的存活时间将会刷新，若超过时间无请求发送，再次发送的时候会再次创建一次新的Session会话。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">HttpSession session &#x3D; request.getSession();\nsession.setMaxInactiveInterval(2); &#x2F;&#x2F;单位是秒\n\nsession.getId(); &#x2F;&#x2F;查看session的唯一标识</code></pre>\n\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>添加redis官方的实现依赖即可，可以在配置类上添加如下注解，配置相关参数</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.session&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-session-data-redis&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.7.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>可以在配置类上添加如下注解，配置相关参数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@EnableRedisHttpSession(maxInactiveIntervalInSeconds &#x3D; 3600 #Session的存活时间,redisNamespace &#x3D; &quot;session_info存储在redis中的命名空间&quot;,flushMode &#x3D; FlushMode.IMMEDIATE #刷新策略,saveMode &#x3D; SaveMode.ON_SET_ATTRIBUTE #刷新策略)</code></pre>\n\n<h4 id=\"刷新策略\"><a href=\"#刷新策略\" class=\"headerlink\" title=\"刷新策略\"></a>刷新策略</h4><ul>\n<li>ON_SAVE: 只有当SessionRepository.save(Session)方法被调用时,才会将session中的数据同步到redis中. 在web 应用中, 当请求完成响应后, 才开始同步. 也就是说在执行response之前session数据都是缓存在本地的.</li>\n<li>IMMEDIATE: 实时同步session 数据到redis. 当执行SessionRepository.createSession()时, 会将session数据同步到redis中;当对session的attribute进行set/remove 等操作时, 也会同步session中的数据到redis中.</li>\n</ul>\n<h4 id=\"保存策略\"><a href=\"#保存策略\" class=\"headerlink\" title=\"保存策略\"></a>保存策略</h4><p>保存Session属性更改的时机，是调用Set属性方法时保存还是Get属性方法调用的时候保存，还是总是保存，一般默认即可。</p>\n"},{"title":"可复用代码","description":"记录了一些可复用的代码，避免重复编写浪费精力。","cover":"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/%E5%8F%A4%E9%A3%8E%20%E5%B1%85%E5%A3%AB%20%E9%BB%91%E7%99%BD%20%E7%BE%8E%E5%A5%B3%20%E5%A3%81%E7%BA%B8%204k_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg","_content":"\n\n\n记录了一些可复用的代码，避免重复编写浪费精力。\n\n\n\n<!-- more -->\n\n\n\n![古风 居士 黑白 美女 壁纸 4k_彼岸图网](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/%E5%8F%A4%E9%A3%8E%20%E5%B1%85%E5%A3%AB%20%E9%BB%91%E7%99%BD%20%E7%BE%8E%E5%A5%B3%20%E5%A3%81%E7%BA%B8%204k_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg)\n\n# 可复用代码\n\n## 结果类：\n\n```java\npackage com.clewm.lcss.res;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class R implements Serializable{\n\n    public String info;\n\n    public Object data;\n\n    public Integer code;\n\n    public Boolean flag;\n\n\n    ///////////////////////////////////////////////////////////////////////////\n    // TODO 成功\n    ///////////////////////////////////////////////////////////////////////////\n    public static R ok(){\n        return new R(ResCode.SUCCESS.getMsg(),null,ResCode.SUCCESS.getCode(),true);\n    }\n\n    public static R ok(String info){\n        return new R(info,null,ResCode.SUCCESS.getCode(),true);\n    }\n\n    public static R ok(Object data){\n        return new R(ResCode.SUCCESS.getMsg(),data,ResCode.SUCCESS.getCode(),true);\n    }\n\n    public static R ok(String info,Object data){\n        return new R(info,data,ResCode.SUCCESS.getCode(),true);\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // TODO 失败\n    ///////////////////////////////////////////////////////////////////////////\n\n    public static R fail(){\n        return new R(ResCode.FAIL.getMsg(),null,ResCode.FAIL.getCode(),false);\n    }\n\n    public static R fail(String info){\n        return new R(info,null,ResCode.FAIL.getCode(),false);\n    }\n\n    public static R fail(Object data){\n        return new R(ResCode.FAIL.getMsg(),data,ResCode.FAIL.getCode(),false);\n    }\n\n    public static R fail(ResCode code) {\n        return new R(code.getMsg(),null,code.getCode(),false);\n    }\n\n    public static R fail(String info,Object data){\n        return new R(info,data,ResCode.FAIL.getCode(),false);\n    }\n\n    public static R fail(Object data,ResCode code) {\n        return new R(code.getMsg(),data,code.getCode(),false);\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // TODO 异常\n    ///////////////////////////////////////////////////////////////////////////\n\n    public static R error() {\n        return new R(ResCode.ERROR.getMsg(),null,ResCode.ERROR.getCode(),false);\n    }\n\n    public static R error(String info) {\n        return new R(info,null,ResCode.ERROR.getCode(),false);\n    }\n\n    public static R error(ResCode code) {\n        return new R(code.getMsg(),null,code.getCode(),false);\n    }\n\n    public static R error(Object data,ResCode code) {\n        return new R(code.getMsg(),data,code.getCode(),false);\n    }\n}\n\n```\n\n## 状态码：\n\n```java\npackage com.clewm.lcss.res;\n\n\npublic enum ResCode {\n    //基础类型\n    SUCCESS(200,\"成功！\"),\n    FAIL(500,\"失败！\"),\n    ERROR(400,\"出现异常！\"),\n\n    //自定义类型\n    NOT_LOGIN(435,\"用户未登录！\");\n\n    private Integer code;\n    private String msg;\n\n    ResCode(Integer code,String msg){\n        this.code = code;\n        this.msg = msg;\n    }\n\n    public Integer getCode() {\n        return code;\n    }\n\n    public String getMsg() {\n        return msg;\n    }\n\n    @Override\n    public String toString() {\n        return code + \"-\" + msg;\n    }\n}\n```\n\n## 控制层的基本增删改查代码：\n\n```java\n    @Resource\n    private DetailService detailService;\n\n    @GetMapping(\"/test\")\n    public R test() {\n        return R.error(ResCode.NOT_LOGIN);\n    }\n\n    @GetMapping(\"/{detailId}\")\n    @Cacheable(value = \"detailInfo\",key = \"#detailId\")\n    public R getDetailInfo(@PathVariable String detailId) {\n        Detail detail = detailService.getById(detailId);\n        DetailVO detailVO = DetailConvert.INSTANCE.po2vo(detail);\n        return R.ok(detailVO);\n    }\n\n    @GetMapping(\"/del/{detailId}\")\n    @CacheEvict(value = \"detailInfo\",key = \"#detailId\")\n    public R delDetail(@PathVariable String detailId) {\n        boolean res = detailService.removeById(detailId);\n        return res ? R.ok(\"删除成功！\") : R.fail(\"删除失败！\");\n    }\n\n    @PostMapping(\"/update/\")\n    @CachePut(value = \"detailInfo\",key = \"#detailDTO.getId()\")\n    public R updateDetail(@RequestBody @Validated DetailDTO detailDTO) {\n        Detail detail = DetailConvert.INSTANCE.dto2po(detailDTO);\n        boolean res = detailService.update(detail, null);\n        return res ? R.ok(\"更新成功！\",detail) : R.fail(\"更新失败！\");\n    }\n\n    @PostMapping\n    public R add(@RequestBody @Validated DetailDTO detailDTO) {\n        Detail detail = detailService.add(detailDTO);\n        log.info(detail.toString());\n        DetailVO detailVO = DetailConvert.INSTANCE.po2vo(detail);\n        return ObjectUtils.isEmpty(detailVO.getId()) ? R.fail() : R.ok(detailVO);\n    }\n```\n\n**只需把detail换成业务实体名即可**\n\n业务层的基本增删改查代码：\n\n```java\n@Autowired\nprivate DetailMapper detailMapper;\n\n@Override\npublic Detail add(DetailDTO detailDTO) {\n    return Optional.ofNullable(detailDTO).map(d -> {\n        Detail detail = DetailConvert.INSTANCE.dto2po(d);\n        detailMapper.insert(detail);\n        return detail;\n    }).orElse(null);\n}\n```\n\n## 转换类：\n\n```java\nimport com.clewm.lcss.dto.DetailDTO;\nimport com.clewm.lcss.pojo.Detail;\nimport com.clewm.lcss.vo.DetailVO;\nimport org.mapstruct.Mapper;\nimport org.mapstruct.factory.Mappers;\n\n@Mapper\npublic interface DetailConvert{\n\n    DetailConvert INSTANCE = Mappers.getMapper(DetailConvert.class);\n\n    Detail dto2po(DetailDTO detailDTO);\n\n    DetailVO po2vo(Detail detail);\n}\n```\n\n## MyBatis分页插件：\n\n```java\n/**\n * @author clewm\n */\n@Configuration\npublic class MyBatisPlusPaginationInnerConfig {\n\n    /**\n     * 分页插件\n     */\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor() {\n        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));\n        return interceptor;\n    }\n\n}\n```\n\n\n\n## Druid数据源配置：\n\n```yaml\nspring:\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/lcss_person?characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull&useSSL=false&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=Asia/Shanghai\n    username: root\n    password: 123567\n    druid:\n      min-idle: 10\n      max-active: 100\n      test-while-idle: true\n      test-on-borrow: true\n      time-between-eviction-runs-millis: 3000000 #设置创建的连接等待时长，单位毫秒\n```\n\n## Minio配置类：\n\n```java\n@Configuration\npublic class MinioConfig {\n\n    @Resource\n    private MinioProperties minioProperties;\n\n    @Bean\n    public MinioClient minioClient() {\n        return MinioClient.builder()\n                .endpoint(minioProperties.getIp(),minioProperties.getPort(),false)\n                .credentials(minioProperties.getAccessKey(), minioProperties.getSecretKey())\n                .build();\n    }\n}\n```\n\n```java\n\n@Data\n@Component\n@ConfigurationProperties(prefix = \"minio\")\npublic class MinioProperties {\n\n    /**\n     * minio服务器地址\n     */\n    private String ip;\n\n    /**\n     * minio端口\n     */\n    private Integer port;\n\n    /**\n     * 用户名\n     */\n    private String accessKey;\n\n    /**\n     * 密码\n     */\n    private String secretKey;\n}\n```\n","source":"_posts/Java/可复用代码.md","raw":"---\n\ntitle: 可复用代码\n\ncategories: \n- 技术\n- 开发常用\n\ntags: Java\n\ndescription: 记录了一些可复用的代码，避免重复编写浪费精力。\n\ncover: https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/%E5%8F%A4%E9%A3%8E%20%E5%B1%85%E5%A3%AB%20%E9%BB%91%E7%99%BD%20%E7%BE%8E%E5%A5%B3%20%E5%A3%81%E7%BA%B8%204k_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg\n\n---\n\n\n\n记录了一些可复用的代码，避免重复编写浪费精力。\n\n\n\n<!-- more -->\n\n\n\n![古风 居士 黑白 美女 壁纸 4k_彼岸图网](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/%E5%8F%A4%E9%A3%8E%20%E5%B1%85%E5%A3%AB%20%E9%BB%91%E7%99%BD%20%E7%BE%8E%E5%A5%B3%20%E5%A3%81%E7%BA%B8%204k_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg)\n\n# 可复用代码\n\n## 结果类：\n\n```java\npackage com.clewm.lcss.res;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class R implements Serializable{\n\n    public String info;\n\n    public Object data;\n\n    public Integer code;\n\n    public Boolean flag;\n\n\n    ///////////////////////////////////////////////////////////////////////////\n    // TODO 成功\n    ///////////////////////////////////////////////////////////////////////////\n    public static R ok(){\n        return new R(ResCode.SUCCESS.getMsg(),null,ResCode.SUCCESS.getCode(),true);\n    }\n\n    public static R ok(String info){\n        return new R(info,null,ResCode.SUCCESS.getCode(),true);\n    }\n\n    public static R ok(Object data){\n        return new R(ResCode.SUCCESS.getMsg(),data,ResCode.SUCCESS.getCode(),true);\n    }\n\n    public static R ok(String info,Object data){\n        return new R(info,data,ResCode.SUCCESS.getCode(),true);\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // TODO 失败\n    ///////////////////////////////////////////////////////////////////////////\n\n    public static R fail(){\n        return new R(ResCode.FAIL.getMsg(),null,ResCode.FAIL.getCode(),false);\n    }\n\n    public static R fail(String info){\n        return new R(info,null,ResCode.FAIL.getCode(),false);\n    }\n\n    public static R fail(Object data){\n        return new R(ResCode.FAIL.getMsg(),data,ResCode.FAIL.getCode(),false);\n    }\n\n    public static R fail(ResCode code) {\n        return new R(code.getMsg(),null,code.getCode(),false);\n    }\n\n    public static R fail(String info,Object data){\n        return new R(info,data,ResCode.FAIL.getCode(),false);\n    }\n\n    public static R fail(Object data,ResCode code) {\n        return new R(code.getMsg(),data,code.getCode(),false);\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // TODO 异常\n    ///////////////////////////////////////////////////////////////////////////\n\n    public static R error() {\n        return new R(ResCode.ERROR.getMsg(),null,ResCode.ERROR.getCode(),false);\n    }\n\n    public static R error(String info) {\n        return new R(info,null,ResCode.ERROR.getCode(),false);\n    }\n\n    public static R error(ResCode code) {\n        return new R(code.getMsg(),null,code.getCode(),false);\n    }\n\n    public static R error(Object data,ResCode code) {\n        return new R(code.getMsg(),data,code.getCode(),false);\n    }\n}\n\n```\n\n## 状态码：\n\n```java\npackage com.clewm.lcss.res;\n\n\npublic enum ResCode {\n    //基础类型\n    SUCCESS(200,\"成功！\"),\n    FAIL(500,\"失败！\"),\n    ERROR(400,\"出现异常！\"),\n\n    //自定义类型\n    NOT_LOGIN(435,\"用户未登录！\");\n\n    private Integer code;\n    private String msg;\n\n    ResCode(Integer code,String msg){\n        this.code = code;\n        this.msg = msg;\n    }\n\n    public Integer getCode() {\n        return code;\n    }\n\n    public String getMsg() {\n        return msg;\n    }\n\n    @Override\n    public String toString() {\n        return code + \"-\" + msg;\n    }\n}\n```\n\n## 控制层的基本增删改查代码：\n\n```java\n    @Resource\n    private DetailService detailService;\n\n    @GetMapping(\"/test\")\n    public R test() {\n        return R.error(ResCode.NOT_LOGIN);\n    }\n\n    @GetMapping(\"/{detailId}\")\n    @Cacheable(value = \"detailInfo\",key = \"#detailId\")\n    public R getDetailInfo(@PathVariable String detailId) {\n        Detail detail = detailService.getById(detailId);\n        DetailVO detailVO = DetailConvert.INSTANCE.po2vo(detail);\n        return R.ok(detailVO);\n    }\n\n    @GetMapping(\"/del/{detailId}\")\n    @CacheEvict(value = \"detailInfo\",key = \"#detailId\")\n    public R delDetail(@PathVariable String detailId) {\n        boolean res = detailService.removeById(detailId);\n        return res ? R.ok(\"删除成功！\") : R.fail(\"删除失败！\");\n    }\n\n    @PostMapping(\"/update/\")\n    @CachePut(value = \"detailInfo\",key = \"#detailDTO.getId()\")\n    public R updateDetail(@RequestBody @Validated DetailDTO detailDTO) {\n        Detail detail = DetailConvert.INSTANCE.dto2po(detailDTO);\n        boolean res = detailService.update(detail, null);\n        return res ? R.ok(\"更新成功！\",detail) : R.fail(\"更新失败！\");\n    }\n\n    @PostMapping\n    public R add(@RequestBody @Validated DetailDTO detailDTO) {\n        Detail detail = detailService.add(detailDTO);\n        log.info(detail.toString());\n        DetailVO detailVO = DetailConvert.INSTANCE.po2vo(detail);\n        return ObjectUtils.isEmpty(detailVO.getId()) ? R.fail() : R.ok(detailVO);\n    }\n```\n\n**只需把detail换成业务实体名即可**\n\n业务层的基本增删改查代码：\n\n```java\n@Autowired\nprivate DetailMapper detailMapper;\n\n@Override\npublic Detail add(DetailDTO detailDTO) {\n    return Optional.ofNullable(detailDTO).map(d -> {\n        Detail detail = DetailConvert.INSTANCE.dto2po(d);\n        detailMapper.insert(detail);\n        return detail;\n    }).orElse(null);\n}\n```\n\n## 转换类：\n\n```java\nimport com.clewm.lcss.dto.DetailDTO;\nimport com.clewm.lcss.pojo.Detail;\nimport com.clewm.lcss.vo.DetailVO;\nimport org.mapstruct.Mapper;\nimport org.mapstruct.factory.Mappers;\n\n@Mapper\npublic interface DetailConvert{\n\n    DetailConvert INSTANCE = Mappers.getMapper(DetailConvert.class);\n\n    Detail dto2po(DetailDTO detailDTO);\n\n    DetailVO po2vo(Detail detail);\n}\n```\n\n## MyBatis分页插件：\n\n```java\n/**\n * @author clewm\n */\n@Configuration\npublic class MyBatisPlusPaginationInnerConfig {\n\n    /**\n     * 分页插件\n     */\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor() {\n        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));\n        return interceptor;\n    }\n\n}\n```\n\n\n\n## Druid数据源配置：\n\n```yaml\nspring:\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/lcss_person?characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull&useSSL=false&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=Asia/Shanghai\n    username: root\n    password: 123567\n    druid:\n      min-idle: 10\n      max-active: 100\n      test-while-idle: true\n      test-on-borrow: true\n      time-between-eviction-runs-millis: 3000000 #设置创建的连接等待时长，单位毫秒\n```\n\n## Minio配置类：\n\n```java\n@Configuration\npublic class MinioConfig {\n\n    @Resource\n    private MinioProperties minioProperties;\n\n    @Bean\n    public MinioClient minioClient() {\n        return MinioClient.builder()\n                .endpoint(minioProperties.getIp(),minioProperties.getPort(),false)\n                .credentials(minioProperties.getAccessKey(), minioProperties.getSecretKey())\n                .build();\n    }\n}\n```\n\n```java\n\n@Data\n@Component\n@ConfigurationProperties(prefix = \"minio\")\npublic class MinioProperties {\n\n    /**\n     * minio服务器地址\n     */\n    private String ip;\n\n    /**\n     * minio端口\n     */\n    private Integer port;\n\n    /**\n     * 用户名\n     */\n    private String accessKey;\n\n    /**\n     * 密码\n     */\n    private String secretKey;\n}\n```\n","slug":"Java/可复用代码","published":1,"date":"2022-11-02T01:20:37.454Z","updated":"2022-11-03T23:41:52.931Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbrcchl90007qkiqgd2sefyt","content":"<p>记录了一些可复用的代码，避免重复编写浪费精力。</p>\n<span id=\"more\"></span>\n\n\n\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/%E5%8F%A4%E9%A3%8E%20%E5%B1%85%E5%A3%AB%20%E9%BB%91%E7%99%BD%20%E7%BE%8E%E5%A5%B3%20%E5%A3%81%E7%BA%B8%204k_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg\" alt=\"古风 居士 黑白 美女 壁纸 4k_彼岸图网\"></p>\n<h1 id=\"可复用代码\"><a href=\"#可复用代码\" class=\"headerlink\" title=\"可复用代码\"></a>可复用代码</h1><h2 id=\"结果类：\"><a href=\"#结果类：\" class=\"headerlink\" title=\"结果类：\"></a>结果类：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.clewm.lcss.res;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class R implements Serializable&#123;\n\n    public String info;\n\n    public Object data;\n\n    public Integer code;\n\n    public Boolean flag;\n\n\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n    &#x2F;&#x2F; TODO 成功\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n    public static R ok()&#123;\n        return new R(ResCode.SUCCESS.getMsg(),null,ResCode.SUCCESS.getCode(),true);\n    &#125;\n\n    public static R ok(String info)&#123;\n        return new R(info,null,ResCode.SUCCESS.getCode(),true);\n    &#125;\n\n    public static R ok(Object data)&#123;\n        return new R(ResCode.SUCCESS.getMsg(),data,ResCode.SUCCESS.getCode(),true);\n    &#125;\n\n    public static R ok(String info,Object data)&#123;\n        return new R(info,data,ResCode.SUCCESS.getCode(),true);\n    &#125;\n\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n    &#x2F;&#x2F; TODO 失败\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n\n    public static R fail()&#123;\n        return new R(ResCode.FAIL.getMsg(),null,ResCode.FAIL.getCode(),false);\n    &#125;\n\n    public static R fail(String info)&#123;\n        return new R(info,null,ResCode.FAIL.getCode(),false);\n    &#125;\n\n    public static R fail(Object data)&#123;\n        return new R(ResCode.FAIL.getMsg(),data,ResCode.FAIL.getCode(),false);\n    &#125;\n\n    public static R fail(ResCode code) &#123;\n        return new R(code.getMsg(),null,code.getCode(),false);\n    &#125;\n\n    public static R fail(String info,Object data)&#123;\n        return new R(info,data,ResCode.FAIL.getCode(),false);\n    &#125;\n\n    public static R fail(Object data,ResCode code) &#123;\n        return new R(code.getMsg(),data,code.getCode(),false);\n    &#125;\n\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n    &#x2F;&#x2F; TODO 异常\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n\n    public static R error() &#123;\n        return new R(ResCode.ERROR.getMsg(),null,ResCode.ERROR.getCode(),false);\n    &#125;\n\n    public static R error(String info) &#123;\n        return new R(info,null,ResCode.ERROR.getCode(),false);\n    &#125;\n\n    public static R error(ResCode code) &#123;\n        return new R(code.getMsg(),null,code.getCode(),false);\n    &#125;\n\n    public static R error(Object data,ResCode code) &#123;\n        return new R(code.getMsg(),data,code.getCode(),false);\n    &#125;\n&#125;\n</code></pre>\n\n<h2 id=\"状态码：\"><a href=\"#状态码：\" class=\"headerlink\" title=\"状态码：\"></a>状态码：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.clewm.lcss.res;\n\n\npublic enum ResCode &#123;\n    &#x2F;&#x2F;基础类型\n    SUCCESS(200,&quot;成功！&quot;),\n    FAIL(500,&quot;失败！&quot;),\n    ERROR(400,&quot;出现异常！&quot;),\n\n    &#x2F;&#x2F;自定义类型\n    NOT_LOGIN(435,&quot;用户未登录！&quot;);\n\n    private Integer code;\n    private String msg;\n\n    ResCode(Integer code,String msg)&#123;\n        this.code &#x3D; code;\n        this.msg &#x3D; msg;\n    &#125;\n\n    public Integer getCode() &#123;\n        return code;\n    &#125;\n\n    public String getMsg() &#123;\n        return msg;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return code + &quot;-&quot; + msg;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"控制层的基本增删改查代码：\"><a href=\"#控制层的基本增删改查代码：\" class=\"headerlink\" title=\"控制层的基本增删改查代码：\"></a>控制层的基本增删改查代码：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Resource\nprivate DetailService detailService;\n\n@GetMapping(&quot;&#x2F;test&quot;)\npublic R test() &#123;\n    return R.error(ResCode.NOT_LOGIN);\n&#125;\n\n@GetMapping(&quot;&#x2F;&#123;detailId&#125;&quot;)\n@Cacheable(value &#x3D; &quot;detailInfo&quot;,key &#x3D; &quot;#detailId&quot;)\npublic R getDetailInfo(@PathVariable String detailId) &#123;\n    Detail detail &#x3D; detailService.getById(detailId);\n    DetailVO detailVO &#x3D; DetailConvert.INSTANCE.po2vo(detail);\n    return R.ok(detailVO);\n&#125;\n\n@GetMapping(&quot;&#x2F;del&#x2F;&#123;detailId&#125;&quot;)\n@CacheEvict(value &#x3D; &quot;detailInfo&quot;,key &#x3D; &quot;#detailId&quot;)\npublic R delDetail(@PathVariable String detailId) &#123;\n    boolean res &#x3D; detailService.removeById(detailId);\n    return res ? R.ok(&quot;删除成功！&quot;) : R.fail(&quot;删除失败！&quot;);\n&#125;\n\n@PostMapping(&quot;&#x2F;update&#x2F;&quot;)\n@CachePut(value &#x3D; &quot;detailInfo&quot;,key &#x3D; &quot;#detailDTO.getId()&quot;)\npublic R updateDetail(@RequestBody @Validated DetailDTO detailDTO) &#123;\n    Detail detail &#x3D; DetailConvert.INSTANCE.dto2po(detailDTO);\n    boolean res &#x3D; detailService.update(detail, null);\n    return res ? R.ok(&quot;更新成功！&quot;,detail) : R.fail(&quot;更新失败！&quot;);\n&#125;\n\n@PostMapping\npublic R add(@RequestBody @Validated DetailDTO detailDTO) &#123;\n    Detail detail &#x3D; detailService.add(detailDTO);\n    log.info(detail.toString());\n    DetailVO detailVO &#x3D; DetailConvert.INSTANCE.po2vo(detail);\n    return ObjectUtils.isEmpty(detailVO.getId()) ? R.fail() : R.ok(detailVO);\n&#125;</code></pre>\n\n<p><strong>只需把detail换成业务实体名即可</strong></p>\n<p>业务层的基本增删改查代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Autowired\nprivate DetailMapper detailMapper;\n\n@Override\npublic Detail add(DetailDTO detailDTO) &#123;\n    return Optional.ofNullable(detailDTO).map(d -&gt; &#123;\n        Detail detail &#x3D; DetailConvert.INSTANCE.dto2po(d);\n        detailMapper.insert(detail);\n        return detail;\n    &#125;).orElse(null);\n&#125;</code></pre>\n\n<h2 id=\"转换类：\"><a href=\"#转换类：\" class=\"headerlink\" title=\"转换类：\"></a>转换类：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import com.clewm.lcss.dto.DetailDTO;\nimport com.clewm.lcss.pojo.Detail;\nimport com.clewm.lcss.vo.DetailVO;\nimport org.mapstruct.Mapper;\nimport org.mapstruct.factory.Mappers;\n\n@Mapper\npublic interface DetailConvert&#123;\n\n    DetailConvert INSTANCE &#x3D; Mappers.getMapper(DetailConvert.class);\n\n    Detail dto2po(DetailDTO detailDTO);\n\n    DetailVO po2vo(Detail detail);\n&#125;</code></pre>\n\n<h2 id=\"MyBatis分页插件：\"><a href=\"#MyBatis分页插件：\" class=\"headerlink\" title=\"MyBatis分页插件：\"></a>MyBatis分页插件：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * @author clewm\n *&#x2F;\n@Configuration\npublic class MyBatisPlusPaginationInnerConfig &#123;\n\n    &#x2F;**\n     * 分页插件\n     *&#x2F;\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;\n        MybatisPlusInterceptor interceptor &#x3D; new MybatisPlusInterceptor();\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));\n        return interceptor;\n    &#125;\n\n&#125;</code></pre>\n\n\n\n<h2 id=\"Druid数据源配置：\"><a href=\"#Druid数据源配置：\" class=\"headerlink\" title=\"Druid数据源配置：\"></a>Druid数据源配置：</h2><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;lcss_person?characterEncoding&#x3D;UTF-8&amp;zeroDateTimeBehavior&#x3D;convertToNull&amp;useSSL&#x3D;false&amp;useJDBCCompliantTimezoneShift&#x3D;true&amp;useLegacyDatetimeCode&#x3D;false&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai\n    username: root\n    password: 123567\n    druid:\n      min-idle: 10\n      max-active: 100\n      test-while-idle: true\n      test-on-borrow: true\n      time-between-eviction-runs-millis: 3000000 #设置创建的连接等待时长，单位毫秒</code></pre>\n\n<h2 id=\"Minio配置类：\"><a href=\"#Minio配置类：\" class=\"headerlink\" title=\"Minio配置类：\"></a>Minio配置类：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class MinioConfig &#123;\n\n    @Resource\n    private MinioProperties minioProperties;\n\n    @Bean\n    public MinioClient minioClient() &#123;\n        return MinioClient.builder()\n                .endpoint(minioProperties.getIp(),minioProperties.getPort(),false)\n                .credentials(minioProperties.getAccessKey(), minioProperties.getSecretKey())\n                .build();\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\n@Data\n@Component\n@ConfigurationProperties(prefix &#x3D; &quot;minio&quot;)\npublic class MinioProperties &#123;\n\n    &#x2F;**\n     * minio服务器地址\n     *&#x2F;\n    private String ip;\n\n    &#x2F;**\n     * minio端口\n     *&#x2F;\n    private Integer port;\n\n    &#x2F;**\n     * 用户名\n     *&#x2F;\n    private String accessKey;\n\n    &#x2F;**\n     * 密码\n     *&#x2F;\n    private String secretKey;\n&#125;</code></pre>\n","site":{"data":{}},"excerpt":"<p>记录了一些可复用的代码，避免重复编写浪费精力。</p>","more":"<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/%E5%8F%A4%E9%A3%8E%20%E5%B1%85%E5%A3%AB%20%E9%BB%91%E7%99%BD%20%E7%BE%8E%E5%A5%B3%20%E5%A3%81%E7%BA%B8%204k_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg\" alt=\"古风 居士 黑白 美女 壁纸 4k_彼岸图网\"></p>\n<h1 id=\"可复用代码\"><a href=\"#可复用代码\" class=\"headerlink\" title=\"可复用代码\"></a>可复用代码</h1><h2 id=\"结果类：\"><a href=\"#结果类：\" class=\"headerlink\" title=\"结果类：\"></a>结果类：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.clewm.lcss.res;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class R implements Serializable&#123;\n\n    public String info;\n\n    public Object data;\n\n    public Integer code;\n\n    public Boolean flag;\n\n\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n    &#x2F;&#x2F; TODO 成功\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n    public static R ok()&#123;\n        return new R(ResCode.SUCCESS.getMsg(),null,ResCode.SUCCESS.getCode(),true);\n    &#125;\n\n    public static R ok(String info)&#123;\n        return new R(info,null,ResCode.SUCCESS.getCode(),true);\n    &#125;\n\n    public static R ok(Object data)&#123;\n        return new R(ResCode.SUCCESS.getMsg(),data,ResCode.SUCCESS.getCode(),true);\n    &#125;\n\n    public static R ok(String info,Object data)&#123;\n        return new R(info,data,ResCode.SUCCESS.getCode(),true);\n    &#125;\n\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n    &#x2F;&#x2F; TODO 失败\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n\n    public static R fail()&#123;\n        return new R(ResCode.FAIL.getMsg(),null,ResCode.FAIL.getCode(),false);\n    &#125;\n\n    public static R fail(String info)&#123;\n        return new R(info,null,ResCode.FAIL.getCode(),false);\n    &#125;\n\n    public static R fail(Object data)&#123;\n        return new R(ResCode.FAIL.getMsg(),data,ResCode.FAIL.getCode(),false);\n    &#125;\n\n    public static R fail(ResCode code) &#123;\n        return new R(code.getMsg(),null,code.getCode(),false);\n    &#125;\n\n    public static R fail(String info,Object data)&#123;\n        return new R(info,data,ResCode.FAIL.getCode(),false);\n    &#125;\n\n    public static R fail(Object data,ResCode code) &#123;\n        return new R(code.getMsg(),data,code.getCode(),false);\n    &#125;\n\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n    &#x2F;&#x2F; TODO 异常\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n\n    public static R error() &#123;\n        return new R(ResCode.ERROR.getMsg(),null,ResCode.ERROR.getCode(),false);\n    &#125;\n\n    public static R error(String info) &#123;\n        return new R(info,null,ResCode.ERROR.getCode(),false);\n    &#125;\n\n    public static R error(ResCode code) &#123;\n        return new R(code.getMsg(),null,code.getCode(),false);\n    &#125;\n\n    public static R error(Object data,ResCode code) &#123;\n        return new R(code.getMsg(),data,code.getCode(),false);\n    &#125;\n&#125;\n</code></pre>\n\n<h2 id=\"状态码：\"><a href=\"#状态码：\" class=\"headerlink\" title=\"状态码：\"></a>状态码：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.clewm.lcss.res;\n\n\npublic enum ResCode &#123;\n    &#x2F;&#x2F;基础类型\n    SUCCESS(200,&quot;成功！&quot;),\n    FAIL(500,&quot;失败！&quot;),\n    ERROR(400,&quot;出现异常！&quot;),\n\n    &#x2F;&#x2F;自定义类型\n    NOT_LOGIN(435,&quot;用户未登录！&quot;);\n\n    private Integer code;\n    private String msg;\n\n    ResCode(Integer code,String msg)&#123;\n        this.code &#x3D; code;\n        this.msg &#x3D; msg;\n    &#125;\n\n    public Integer getCode() &#123;\n        return code;\n    &#125;\n\n    public String getMsg() &#123;\n        return msg;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return code + &quot;-&quot; + msg;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"控制层的基本增删改查代码：\"><a href=\"#控制层的基本增删改查代码：\" class=\"headerlink\" title=\"控制层的基本增删改查代码：\"></a>控制层的基本增删改查代码：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Resource\nprivate DetailService detailService;\n\n@GetMapping(&quot;&#x2F;test&quot;)\npublic R test() &#123;\n    return R.error(ResCode.NOT_LOGIN);\n&#125;\n\n@GetMapping(&quot;&#x2F;&#123;detailId&#125;&quot;)\n@Cacheable(value &#x3D; &quot;detailInfo&quot;,key &#x3D; &quot;#detailId&quot;)\npublic R getDetailInfo(@PathVariable String detailId) &#123;\n    Detail detail &#x3D; detailService.getById(detailId);\n    DetailVO detailVO &#x3D; DetailConvert.INSTANCE.po2vo(detail);\n    return R.ok(detailVO);\n&#125;\n\n@GetMapping(&quot;&#x2F;del&#x2F;&#123;detailId&#125;&quot;)\n@CacheEvict(value &#x3D; &quot;detailInfo&quot;,key &#x3D; &quot;#detailId&quot;)\npublic R delDetail(@PathVariable String detailId) &#123;\n    boolean res &#x3D; detailService.removeById(detailId);\n    return res ? R.ok(&quot;删除成功！&quot;) : R.fail(&quot;删除失败！&quot;);\n&#125;\n\n@PostMapping(&quot;&#x2F;update&#x2F;&quot;)\n@CachePut(value &#x3D; &quot;detailInfo&quot;,key &#x3D; &quot;#detailDTO.getId()&quot;)\npublic R updateDetail(@RequestBody @Validated DetailDTO detailDTO) &#123;\n    Detail detail &#x3D; DetailConvert.INSTANCE.dto2po(detailDTO);\n    boolean res &#x3D; detailService.update(detail, null);\n    return res ? R.ok(&quot;更新成功！&quot;,detail) : R.fail(&quot;更新失败！&quot;);\n&#125;\n\n@PostMapping\npublic R add(@RequestBody @Validated DetailDTO detailDTO) &#123;\n    Detail detail &#x3D; detailService.add(detailDTO);\n    log.info(detail.toString());\n    DetailVO detailVO &#x3D; DetailConvert.INSTANCE.po2vo(detail);\n    return ObjectUtils.isEmpty(detailVO.getId()) ? R.fail() : R.ok(detailVO);\n&#125;</code></pre>\n\n<p><strong>只需把detail换成业务实体名即可</strong></p>\n<p>业务层的基本增删改查代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Autowired\nprivate DetailMapper detailMapper;\n\n@Override\npublic Detail add(DetailDTO detailDTO) &#123;\n    return Optional.ofNullable(detailDTO).map(d -&gt; &#123;\n        Detail detail &#x3D; DetailConvert.INSTANCE.dto2po(d);\n        detailMapper.insert(detail);\n        return detail;\n    &#125;).orElse(null);\n&#125;</code></pre>\n\n<h2 id=\"转换类：\"><a href=\"#转换类：\" class=\"headerlink\" title=\"转换类：\"></a>转换类：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import com.clewm.lcss.dto.DetailDTO;\nimport com.clewm.lcss.pojo.Detail;\nimport com.clewm.lcss.vo.DetailVO;\nimport org.mapstruct.Mapper;\nimport org.mapstruct.factory.Mappers;\n\n@Mapper\npublic interface DetailConvert&#123;\n\n    DetailConvert INSTANCE &#x3D; Mappers.getMapper(DetailConvert.class);\n\n    Detail dto2po(DetailDTO detailDTO);\n\n    DetailVO po2vo(Detail detail);\n&#125;</code></pre>\n\n<h2 id=\"MyBatis分页插件：\"><a href=\"#MyBatis分页插件：\" class=\"headerlink\" title=\"MyBatis分页插件：\"></a>MyBatis分页插件：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * @author clewm\n *&#x2F;\n@Configuration\npublic class MyBatisPlusPaginationInnerConfig &#123;\n\n    &#x2F;**\n     * 分页插件\n     *&#x2F;\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;\n        MybatisPlusInterceptor interceptor &#x3D; new MybatisPlusInterceptor();\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));\n        return interceptor;\n    &#125;\n\n&#125;</code></pre>\n\n\n\n<h2 id=\"Druid数据源配置：\"><a href=\"#Druid数据源配置：\" class=\"headerlink\" title=\"Druid数据源配置：\"></a>Druid数据源配置：</h2><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;lcss_person?characterEncoding&#x3D;UTF-8&amp;zeroDateTimeBehavior&#x3D;convertToNull&amp;useSSL&#x3D;false&amp;useJDBCCompliantTimezoneShift&#x3D;true&amp;useLegacyDatetimeCode&#x3D;false&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai\n    username: root\n    password: 123567\n    druid:\n      min-idle: 10\n      max-active: 100\n      test-while-idle: true\n      test-on-borrow: true\n      time-between-eviction-runs-millis: 3000000 #设置创建的连接等待时长，单位毫秒</code></pre>\n\n<h2 id=\"Minio配置类：\"><a href=\"#Minio配置类：\" class=\"headerlink\" title=\"Minio配置类：\"></a>Minio配置类：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class MinioConfig &#123;\n\n    @Resource\n    private MinioProperties minioProperties;\n\n    @Bean\n    public MinioClient minioClient() &#123;\n        return MinioClient.builder()\n                .endpoint(minioProperties.getIp(),minioProperties.getPort(),false)\n                .credentials(minioProperties.getAccessKey(), minioProperties.getSecretKey())\n                .build();\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\n@Data\n@Component\n@ConfigurationProperties(prefix &#x3D; &quot;minio&quot;)\npublic class MinioProperties &#123;\n\n    &#x2F;**\n     * minio服务器地址\n     *&#x2F;\n    private String ip;\n\n    &#x2F;**\n     * minio端口\n     *&#x2F;\n    private Integer port;\n\n    &#x2F;**\n     * 用户名\n     *&#x2F;\n    private String accessKey;\n\n    &#x2F;**\n     * 密码\n     *&#x2F;\n    private String secretKey;\n&#125;</code></pre>"},{"title":"25种设计模式代码示例","description":"25种设计模式代码示例","_content":"\n# 设计模式\n\n菜鸟设计模式：\n\nhttps://www.runoob.com/design-pattern/design-pattern-tutorial.html\n\n\n\nUML类图教程：\n\nhttps://blog.csdn.net/weixin_57504000/article/details/124218420\n\n创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。\n\n结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。\n\n行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n\n# 一、创建型模式\n\n## 1.工厂模式\n\n获得**复杂对象**实例（简单对象只需要new即可），而无须关心其具体的实现细节。\n\n**实现：**\n\n定义一个接口\n\n```java\npublic interface Phone {\n\n    public String use();\n}\n```\n\n定义实体，并继承该接口\n\n```java\npublic class Oppo implements Phone {\n\n    @Override\n    public String use() {\n        return \"我是oppo  \";\n    }\n}\n```\n\n```java\npublic class Xiaomi implements Phone {\n\n    @Override\n    public String use() {\n        return \"我是小米\";\n    }\n}\n```\n\n定义工厂类：\n\n```java\npublic class PhoneFactory {\n\n    public static class Type{\n        public static final String TYPE_XIAOMI = \"xiaomi\";\n        public static final String TYPE_OPPO = \"oppo\";\n    }\n\n    public Phone getPhoneByType(String type) {\n        if(type.equalsIgnoreCase(Type.TYPE_XIAOMI)){\n            return new Xiaomi();\n        }else if(type.equalsIgnoreCase(Type.TYPE_OPPO)){\n            return new Oppo();\n        }\n        return null;\n    }\n}\n```\n\n使用：\n\n```java\npublic class Test {\n\n    public static void main(String[] args) {\n        PhoneFactory phoneFactory = new PhoneFactory();\n        Phone xiaomi = phoneFactory.getPhoneByType(PhoneFactory.Type.TYPE_XIAOMI);\n        System.out.println(xiaomi.use());\n    }\n}\n```\n\n**结果**\n\n![image-20221214080627939](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214080627939.png)\n\n## 2.抽象工厂模式\n\n抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。\n\n\n\n定义一个抽象工厂类：\n\n```java\npublic abstract class AbstractFactory {\n\n    public abstract Phone getPhoneByType(String phoneType);\n\n    public abstract Color getColorByType(String phoneType);\n}\n```\n\n具体的工厂类继承该抽象工厂类：\n\n手机工厂：\n\n```java\npublic class PhoneFactory extends AbstractFactory {\n\n    public static class Type{\n        public static final String TYPE_XIAOMI = \"xiaomi\";\n        public static final String TYPE_OPPO = \"oppo\";\n    }\n\n    public Phone getPhoneByType(String type) {\n        if(type.equalsIgnoreCase(Type.TYPE_XIAOMI)){\n            return new Xiaomi();\n        }else if(type.equalsIgnoreCase(Type.TYPE_OPPO)){\n            return new Oppo();\n        }\n        return null;\n    }\n\n    @Override\n    public Color getColorByType(String phoneType) {\n        return null;\n    }\n}\n```\n\n颜色工厂：\n\n```java\npublic class ColorFactory extends AbstractFactory {\n\n    public static class TYPE{\n        public static final String TYPE_RED = \"red\";\n\n        public static final String TYPE_YELLOW = \"yellow\";\n    }\n\n    @Override\n    public Phone getPhoneByType(String phoneType) {\n\n        return null;\n    }\n\n    @Override\n    public Color getColorByType(String phoneType) {\n        if (TYPE.TYPE_RED.equalsIgnoreCase(phoneType)) {\n            return new Red();\n        }else if (TYPE.TYPE_YELLOW.equalsIgnoreCase(phoneType)){\n            return new Yellow();\n        }\n        return null;\n    }\n}\n```\n\n定义一个超级工厂类，用于获得具体的工厂：\n\n```java\npublic class RootFactory {\n\n    public static class TYPE{\n        public static final String TYPE_PHONE = \"phone\";\n        public static final String TYPE_COLOR = \"color\";\n    }\n\n    public static AbstractFactory getFactoryByType(String factoryType) {\n        if (TYPE.TYPE_PHONE.equalsIgnoreCase(factoryType)){\n            return new PhoneFactory();\n        }else if(TYPE.TYPE_COLOR.equals(factoryType)){\n            return new ColorFactory();\n        }\n        return null;\n    }\n}\n```\n\n使用：\n\n```java\npublic static void main(String[] args) {\n    //获得工厂\n    AbstractFactory factoryByType = RootFactory.getFactoryByType(RootFactory.TYPE.TYPE_COLOR);\n    //从工厂获得对象\n    Color colorByType = factoryByType.getColorByType(ColorFactory.TYPE.TYPE_RED);\n    System.out.println(colorByType.show());\n}\n```\n\n**结果**\n\n![image-20221214080715116](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214080715116.png)\n\n## 3.构造器模式\n\n参考：https://www.dandelioncloud.cn/article/details/1523275053169147905\n\n传统的构造对象方式：\n\n```java\nPerson person = new Person();\nperson.setId(1);\nperson.setName(\"张小毛\");\nperson.setAge(22);\nperson.setSex(\"男\");\nperson.setPhone(\"19999999999\");\nperson.setAddress(\"beijing\");\nperson.setDesc(\"JavaBeans模式\");\n```\n\n- 优点：易于阅读，并且可以只对有用的成员变量赋值\n- 缺点：成员变量不可以是 final 类型，失去了不可变对象的很多好处，对象状态不连续，你必须调用7次setter方法才能得到一个具备7个属性值得变量，在这期间用户可能拿到不完整状态的对象。如果有N个属性，岂不是要`person.setXXX`调用N次？此种方式不优雅\n\n构造器模式演示：\n\n```java\nPrivateKeyDecryptParam param = new PrivateKeyDecryptParam.Builder()\n                                              .uAppId(uAppId)\n                                              .containerId(containerId)\n                                              .cipher(cipher)\n                                              .signFlag(signFlag)\n                                              .build();\n```\n\n示例：\n\n```java\n@Data\n@ToString\npublic class User {\n\n    private String name;\n\n    private Integer age;\n\n    private Integer sex;\n\n    private User(Builder builder){\n        this.name = builder.name;\n        this.age = builder.age;\n        this.sex = builder.sex;\n    }\n\n    public static class Builder {\n\n        //必要参数\n        private final String name;\n\n        //可选参数\n        private Integer age;\n        private Integer sex;\n\n        public Builder(String name){\n            this.name = name;\n        }\n\n        public Builder age(Integer age) {\n            this.age = age;\n            return this;\n        }\n\n        public Builder sex(Integer sex) {\n            this.sex = sex;\n            return this;\n        }\n\n        public User build() {\n            return new User(this);\n        }\n    }\n}\n```\n\n使用：\n\n```java\n        User cleWm = new User.Builder(\"CleWm\")\n                .age(21)\n                .sex(0)\n                .build();\n```\n\n要点：\n\n- 外部类的构造函数私有，且参数为静态内部类；\n- 静态内部类拥有外部类相同的属；\n- 为每一个属性，写一个方法，返回的是Builer；\n- 最后一个方法是build方法，用于构建一个外部类；\n\n优点：降低复杂性，优雅\n\n缺点：代码量提高了\n\n\n\n## 4.单例模式\n\n一个类确保只有单个对象被创建\n\n**饿汉式：**\n\n```java\npublic class HungrySingleton {\n\n    private static HungrySingleton instance = new HungrySingleton();\n\n    private HungrySingleton(){}\n\n    public static HungrySingleton getInstance(){\n        return instance;\n    }\n}\n```\n\n**懒汉式：**\n\n双重检查锁：\n\n```java\npublic class LazySingleton {\n\n    private static LazySingleton instance;\n\n    private LazySingleton() {}\n\n    public static LazySingleton getInstance() {\n        if(instance == null){\n            synchronized (LazySingleton.class){\n                if (instance == null){\n                    instance = new LazySingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n静态内部类：\n\n```java\npublic class LazySingleton2 {\n\n    private LazySingleton2(){}\n\n    /**\n     * 静态内部类和非静态内部类都是在被调用的时候才会进行加载，和外部类没有关系，从而实现了延迟加载\n     */\n    private static class SingletonHolder{\n        private static final LazySingleton2 instance = new LazySingleton2();\n    }\n\n    public static LazySingleton2 getInstance() {\n        return SingletonHolder.instance;\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        LazySingleton instance1 = LazySingleton.getInstance();\n        LazySingleton instance2 = LazySingleton.getInstance();\n        System.out.println(instance1 == instance2);\n\n        LazySingleton2 instance3 = LazySingleton2.getInstance();\n        LazySingleton2 instance4 = LazySingleton2.getInstance();\n        System.out.println(instance3 == instance4);\n    }\n}\n```\n\n**结果**\n\n![image-20221214081317951](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214081317951.png)\n\n## 5.原型模式\n\n原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。一般会配合工厂模式一起使用。\n\n与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。\n\n定义一个抽象父类，并实现Cloneable接口：\n\n```java\n/**\n * Cloneable是一个标识接口，clone方法是Object提供的方法，\n * 只有实现了Cloneable接口，同时重写clone方法才不会报错\n */\n@Getter\n@ToString\npublic abstract class Book implements Cloneable{\n\n    protected String name;\n\n    protected Integer type;\n\n    @Override\n    protected Book clone(){\n        Object clone = null;\n        try{\n            clone = super.clone();\n        }catch (CloneNotSupportedException e){\n            e.printStackTrace();\n        }\n        return (Book)clone;\n    }\n}\n```\n\n定义具体实现类：\n\n```java\npublic class BookOne extends Book{\n\n    BookOne() {\n        name = \"《第一本书》\";\n        type = 1;\n    }\n}\n```\n\n```java\npublic class BookTwo extends Book{\n\n    BookTwo() {\n        name = \"《第二本书》\";\n        type = 2;\n    }\n}\n```\n\n定义一个Factory来获得克隆对象：\n\n```java\npublic class BookFactory {\n\n    /**\n     * 用于存储我们的原始对象，克隆对象以此为基础进行复制\n     */\n    private static final Map<Integer,Book> cache;\n\n    static {\n        cache = new HashMap<>();\n        cache.put(Type.TYPE_ONE,new BookOne());\n        cache.put(Type.TYPE_TWO,new BookTwo());\n    }\n\n    public static class Type{\n        public static final Integer TYPE_ONE = 1;\n        public static final Integer TYPE_TWO = 2;\n    }\n\n    /**\n     * 返回的是克隆对象\n     * @param type\n     * @return\n     */\n    public static Book getBookByType(Integer type) {\n        return cache.get(type).clone();\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n    @org.junit.Test\n    public void test1() {\n        Book book1 = BookFactory.getBookByType(BookFactory.Type.TYPE_ONE);\n        Book book2 = BookFactory.getBookByType(BookFactory.Type.TYPE_ONE);\n        System.out.println(book1 == book2);\n        System.out.println(book1);\n        System.out.println(book2);\n    }\n}\n```\n\n**结果**\n\n![image-20221214081502987](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214081502987.png)\n\n# 二、结构型模式\n\n## 6.适配器模式\n\n适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁\n\n比如220V的电源，使用电源适配器给手机提供12V的电压充电。\n\n**定义一个目标接口，该接口属于一般情况**\n\n```java\npublic interface Target {\n\n    public void get();\n}\n```\n\n**定义一个不兼容的，需要被适配的实现**\n\n```java\npublic class SpecialStatus {\n\n    public void specialGet() {\n        System.out.println(\"这是特殊情况的get实现\");\n    }\n}\n```\n\n**定义适配器，实现Target接口**\n\n```java\npublic class Adapter implements Target {\n\n    private SpecialStatus specialStatus;\n\n    public Adapter(SpecialStatus specialStatus){\n        this.specialStatus = specialStatus;\n    }\n\n    @Override\n    public void get() {\n        specialStatus.specialGet();\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        SpecialStatus specialStatus = new SpecialStatus();\n        Adapter adapter = new Adapter(specialStatus);\n        adapter.get();\n    }\n}\n```\n\n**结果**\n\n![image-20221217093732742](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217093732742.png)\n\n## 7.桥接模式\n\nBridge，它的作用是将抽象部分和它的实现部分分离，从而可以让它们独立地变化。\n\n就好比有一个武器槽，放不同的武器进去就是不同的功能。s\n\n**先定义抽象部分，比如武器槽**\n\n```java\npublic abstract class WeaponSlot {\n\n    protected Weapon weapon;\n\n    abstract void shoot();\n\n    public void setWeapon(Weapon weapon){\n        this.weapon = weapon;\n    }\n\n    public abstract void opreation();\n}\n```\n\n**定义实现的接口**\n\n```java\npublic interface Weapon {\n\n    void shoot();\n}\n```\n\n**定义抽象部分的实现**\n\n```java\npublic class LeftSlot extends WeaponSlot{\n\n    @Override\n    void shoot() {\n        weapon.shoot();\n    }\n\n    @Override\n    public void opreation() {\n        weapon.shoot();\n    }\n}\n```\n\n**定义实现接口的实现**\n\n```java\npublic class AK47 implements Weapon {\n    @Override\n    public void shoot() {\n        System.out.println(\"AK开枪了！\");\n    }\n}\n```\n\n```java\npublic class M4 implements Weapon {\n    @Override\n    public void shoot() {\n        System.out.println(\"m4开枪！\");\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n\n        M4 m4 = new M4();\n        AK47 ak47 = new AK47();\n\n        LeftSlot leftSlot = new LeftSlot();\n        leftSlot.setWeapon(m4);\n        leftSlot.opreation();\n\n        leftSlot.setWeapon(ak47);\n        leftSlot.opreation();\n    }\n}\n```\n\n**结果**\n\n![image-20221217103542571](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103542571.png)\n\n## 8.过滤器模式\n\nFilter ，它的作用是过滤序列中的特定元素。\n\n**定义一个过滤器的接口**\n\n```java\npublic interface Filter <T>{\n\n    List<T> doFilter(List<T> lists);\n}\n```\n\n**定义要过滤的实体类**\n\n```java\n@Data\npublic class User {\n\n    private String name;\n\n    private Integer age;\n\n    private Integer sex;\n}\n```\n\n**定义过滤器的具体实现**\n\n年龄过滤器：\n\n```java\npublic class AgeFilter implements Filter<User> {\n\n    @Override\n    public List<User> doFilter(List<User> lists) {\n        ArrayList<User> res = new ArrayList<>();\n        for (User user : lists) {\n            if(user.getAge() >= 18){\n                res.add(user);\n            }\n        }\n        return res;\n    }\n}\n```\n\n性别过滤器：\n\n```java\npublic class SexFilter implements Filter<User> {\n    @Override\n    public List<User> doFilter(List<User> lists) {\n        ArrayList<User> res = new ArrayList<>();\n        for (User user : lists) {\n            if (user.getSex() == 1){\n                res.add(user);\n            }\n        }\n        return res;\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        AgeFilter ageFilter = new AgeFilter();\n        SexFilter sexFilter = new SexFilter();\n        ArrayList<User> userArrayList = new ArrayList<>();\n        for (int i = 1; i < 10; i++) {\n            User user = new User();\n            user.setAge(RandomUtil.randomInt(10,35));\n            user.setName(\"张\" + i);\n            user.setSex(RandomUtil.randomEle(new Integer[]{0,1}));\n            userArrayList.add(user);\n        }\n        List<User> users1 = ageFilter.doFilter(userArrayList);\n        System.out.println(\"第一次过滤后的结果：\" + users1);\n\n        List<User> users2 = sexFilter.doFilter(users1);\n        System.out.println(\"第二次过滤后的结果：\" + users2);\n    }\n}\n```\n\n**结果**\n\n![image-20221217103713100](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103713100.png)\n\n## 9.组合模式\n\nComposite，是用于把一组相似的对象当作一个单一的对象。组合模式依据**树形结构**来组合对象，用来表示部分以及整体层次。\n\n例如：在可视化开发中，容器和按钮等组件之间的关系。又或者是公司、学校的组织架构等。\n\n以学校为例：\n\n**定义一个员工类：**\n\n```java\n@Data\n@ToString(exclude = \"subordinates\")\npublic class Employee {\n\n    private String name;\n\n    private String dept;\n\n    private Integer salary;\n\n    private List<Employee> subordinates;\n\n    public Employee(String name, String dept, Integer salary) {\n        this.name = name;\n        this.dept = dept;\n        this.salary = salary;\n        this.subordinates = new ArrayList<>();\n    }\n\n    public void addSubordinate(Employee subordinate) {\n        subordinates.add(subordinate);\n    }\n\n    public void removeSubordinate(Employee subordinate) {\n        subordinates.remove(subordinate);\n    }\n}\n```\n\n**测试：**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        Employee 张昌平 = new Employee(\"张昌平\", \"校长\", 30000);\n\n        Employee 张雪迎 = new Employee(\"张雪迎\", \"7班班主任\", 10000);\n        Employee 刘静 = new Employee(\"刘静\", \"8班班主任\", 9000);\n\n        Employee 胡伟明 = new Employee(\"胡伟明\", \"7班学生\", 0);\n        Employee 李冠杰 = new Employee(\"李冠杰\", \"7班学生\", 0);\n        Employee 田继睿 = new Employee(\"田继睿\", \"7班学生\", 0);\n        Employee 冯毅力 = new Employee(\"冯毅力\", \"7班学生\", 0);\n\n        Employee 冯跟源 = new Employee(\"冯跟源\", \"8班学生\", 0);\n        Employee 施冰清 = new Employee(\"施冰清\", \"8班学生\", 0);\n\n\n\n        张昌平.addSubordinate(张雪迎);\n        张昌平.addSubordinate(刘静);\n\n\n        张雪迎.addSubordinate(胡伟明);\n        张雪迎.addSubordinate(李冠杰);\n        张雪迎.addSubordinate(田继睿);\n        张雪迎.addSubordinate(冯毅力);\n\n        刘静.addSubordinate(冯跟源);\n        刘静.addSubordinate(施冰清);\n\n        /**\n         * 二叉树如下:\n         *                      张昌平\n         *                    /      \\\n         *                   /        \\\n         *                张雪迎        刘静\n         *                / | | \\      / \\\n         *               /  | |  \\    /   \\\n         *             胡   李 冯 田   冯   施\n         */\n        System.out.println(张昌平);\n        for (Employee sub1 : 张昌平.getSubordinates()){\n            System.out.println(sub1);\n            for (Employee sub2 : sub1.getSubordinates()){\n                System.out.println(sub2);\n            }\n        }\n    }\n}\n```\n\n**结果**\n\n![image-20221217103845510](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103845510.png)\n\n## 10.装饰器模式\n\nDecorator，允许向一个现有的对象添加新的功能，同时又不改变其结构。\n\n**定义一个接口**\n\n```java\npublic interface Person {\n\n    void eat();\n}\n```\n\n**定义一个接口的实现**\n\n```java\npublic class CleWm implements Person {\n    @Override\n    public void eat() {\n        System.out.println(\"吃了一碗饭...\");\n    }\n}\n```\n\n**定义一个装饰器，实现接口**\n\n```java\npublic class Decorator implements Person {\n\n    private Person person;\n\n    @Override\n    public void eat() {\n        person.eat();\n        System.out.println(\"person又吃了一碗...\");\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        CleWm cleWm = new CleWm();\n        Decorator decorator = new Decorator();\n        decorator.setPerson(cleWm);\n        decorator.eat();\n    }\n}\n```\n\n**结果**\n\n![image-20221217103941837](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103941837.png)\n\n## 11.外观模式\n\nFacade，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。\n\n```java\n// 外观类\npublic class Facade {\n   private Subsystem1 subsystem1;\n   private Subsystem2 subsystem2;\n\n   public Facade() {\n      subsystem1 = new Subsystem1();\n      subsystem2 = new Subsystem2();\n   }\n\n   // 提供一个简化的接口，用于客户端访问子系统\n   public void operation() {\n      subsystem1.operation1();\n      subsystem2.operation1();\n   }\n}\n\n// 子系统1\npublic class Subsystem1 {\n   public void operation1() {\n      // 实现子系统1的相关操作\n   }\n}\n\n// 子系统2\npublic class Subsystem2 {\n   public void operation1() {\n      // 实现子系统2的相关操作\n   }\n}\n```\n\n## 12.享元模式\n\nFlyweight，主要用于减少创建对象的数量，以减少内存占用和提高性能。\n\n说白了就是在工厂模式的工厂类中，缓存一个Map，每次创建对象的时候就进行一个判断，若指定对象存在，则直接从map中取出并返回，若没有，则新建，然后缓存进入Map当中。\n\n**创建一个颜色**\n\n```java\npublic class Color {\n\n    public String colorName;\n\n    public Color(String colorName){\n        this.colorName = colorName;\n    }\n}\n```\n\n**创建一个颜色工厂**\n\n```java\npublic class ColorFactory {\n\n    private Map<String, Color> map = new HashMap<>();\n\n    public Color getColor(String colorName) {\n        return Optional.ofNullable(map.get(colorName)).orElseGet(()->{\n            Color color = new Color(colorName);\n            map.put(colorName,color);\n            return color;\n        });\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        ColorFactory colorFactory = new ColorFactory();\n        Color red1 = colorFactory.getColor(\"red\");\n        Color red2 = colorFactory.getColor(\"red\");\n        Color red3 = colorFactory.getColor(\"blue\");\n        System.out.println(red1 == red2);\n    }\n}\n```\n\n**结果**\n\n![image-20221217104139185](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104139185.png)\n\n## 13.代理模式\n\nProxy，它通过引入一个新的类来控制对另一个对象的访问。这有助于控制对原始对象的访问，并且可以在访问原始对象时执行其他附加操作。\n\n**定义一个接口，包含被代理的方法**\n\n```java\npublic interface Image {\n\n    public void show();\n}\n```\n\n**定义原始类**\n\n```java\npublic class Realimage implements Image {\n\n    private String path;\n\n    public Realimage(String path) {\n        this.path = path;\n        loadFromDisk();\n    }\n\n    @Override\n    public void show() {\n        System.out.println(\"展示\" + path + \"的图片\");\n    }\n\n    void loadFromDisk() {\n        System.out.println(\"正在从磁盘中加载图片:\" + path);\n    }\n}\n```\n\n**定义代理对象**\n\n```java\npublic class ProxyImage implements Image {\n\n    private String path;\n\n    private Realimage realimage;\n\n    public ProxyImage(String path) {\n        this.path = path;\n    }\n\n    @Override\n    public void show() {\n        if(realimage == null){\n            realimage = new Realimage(path);\n        }\n        realimage.show();\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        ProxyImage proxyImage = new ProxyImage(\"C:\\\\test.jpg\");\n        proxyImage.show();\n    }\n}\n```\n\n**结果**\n\n![image-20221217104158303](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104158303.png)\n\n# 三、行为型模式\n\n## 14.责任链模式\n\nChain of Responsibility，为请求创建了一个接收者对象的链。\n\n通常每个接收者都包含对另一个接收者的引用。**如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者**，依此类推。\n\n**定义一个实体**\n\n```java\n@Data\n@AllArgsConstructor\npublic class Package {\n\n    private String loc;\n}\n```\n\n**定义一个处理器的抽象父类**\n\n```java\npublic abstract class PackageHandler {\n\n    private PackageHandler next;\n\n    public void next(PackageHandler next){\n        this.next = next;\n    }\n\n    public void handler(Package p){\n        if(next != null){\n            next.handler(p);\n        }else {\n            System.out.println(\"接收到一个未知地点的包裹....\");\n        }\n    }\n}\n```\n\n**定义处理器的实现**\n\n```java\npublic class KunmingPackageHandler extends PackageHandler{\n    @Override\n    public void handler(Package p) {\n        if(\"昆明\".equals(p.getLoc())){\n            System.out.println(\"处理了一个昆明的包裹...[\" + this + \"]\");\n            return;\n        }else {\n            super.handler(p);\n        }\n    }\n}\n```\n\n```java\npublic class TianJinPackageHandler extends PackageHandler{\n\n    @Override\n    public void handler(Package p) {\n        if(\"天津\".equals(p.getLoc())){\n            System.out.println(\"处理了一个天津的包裹...[\" + this + \"]\");\n            return;\n        }else {\n            super.handler(p);\n        }\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        KunmingPackageHandler kunmingPackageHandler = new KunmingPackageHandler();\n        TianJinPackageHandler tianJinPackageHandler = new TianJinPackageHandler();\n\n        // |kunmingPackageHandler| ------ |tianJinPackageHandler| ------ null\n        kunmingPackageHandler.next(tianJinPackageHandler);\n\n\n        Package package1 = new Package(\"天津\");\n        Package package2 = new Package(\"昆明\");\n        Package package3 = new Package(\"四川\");\n\n        List<Package> packageList = ListUtil.of(package1, package2, package3);\n        for (Package aPackage : packageList) {\n            kunmingPackageHandler.handler(aPackage);\n        }\n    }\n}\n```\n\n**结果**\n\n![image-20221217104231704](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104231704.png)\n\n## 15.命令模式\n\nCommand，**命令模式允许请求的一方和接收的一方独立开来**，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。\n\n![image-20221211094616223](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221211094616223.png)\n\n简单理解就是，封装一条命令，为该命令设置一个接收者，然后将该命令set进一个调用者对象（Invoker）中，最后调用Invoker的runCommand方法来执行命令。\n\n**创建命令接口**\n\n```java\npublic interface Command {\n\n    void run();\n}\n```\n\n**创建接收者(可以理解为被隐藏的具体功能实现的部分)**\n\n```java\npublic class Receiver {\n\n    private Integer stock = 100;\n\n    /**\n     * 接收者的增加库存接口，命令调用者无须关心这些接口。\n     */\n    public void increase() {\n        stock++;\n        System.out.println(\"[库存剩余]:\" + stock);\n    }\n\n    /**\n     * 接收者的减少库存接口，命令调用者无须关心这些接口。\n     */\n    public void decrease() {\n        stock--;\n        System.out.println(\"[库存剩余]:\" + stock);\n    }\n}\n```\n\n**创建命令实现**\n\n```java\npublic class AddStockCommand implements Command {\n\n    private Receiver receiver;\n\n    public AddStockCommand(Receiver receiver) {\n        this.receiver = receiver;\n    }\n\n    @Override\n    public void run() {\n        receiver.increase();\n        System.out.println(\"添加了1个库存...\");\n    }\n}\n```\n\n```java\npublic class SubStockCommand implements Command {\n\n    private Receiver receiver;\n\n    public SubStockCommand(Receiver receiver){\n        this.receiver = receiver;\n    }\n\n    @Override\n    public void run() {\n        receiver.decrease();\n        System.out.println(\"减少了1个库存...\");\n    }\n}\n```\n\n**创建调用者**\n\n```java\npublic class Invoker{\n\n    // 这里也可用一个List来存储命令，在调用时使用for循环命令依次执行。\n    private Command command;\n\n    public Invoker(Command command){\n        this.command = command;\n    }\n\n    public void invokeCommand() {\n        if(command != null){\n            command.run();\n            System.out.println(\"命令执行完毕...\");\n        }else {\n            System.out.println(\"未设置命令！\");\n        }\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        // 创建一个接收者\n        Receiver receiver = new Receiver();\n\n        // 库存增加命令\n        AddStockCommand addStockCommand = new AddStockCommand(receiver);\n        // 库存减少命令\n        SubStockCommand subStockCommand = new SubStockCommand(receiver);\n\n        // 创建一个调用者\n        Invoker invoker1 = new Invoker(addStockCommand);\n        // 让调用者执行命令。\n        invoker1.invokeCommand();\n\n        // 创建一个调用者\n        Invoker invoker2 = new Invoker(subStockCommand);\n        // 让调用者执行命令。\n        invoker2.invokeCommand();\n    }\n}\n```\n\n**结果**\n\n![image-20221217104253518](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104253518.png)\n\n## 16.解释器模式\n\nInterpreter，它允许你定义一个语言的文法，并且基于该文法解释语言中的句子。\n\n**定义表达式接口**\n\n```java\npublic interface Expression {\n\n    boolean interpret(String content);\n}\n```\n\n**定义表达式**\n\n**关键词表达式，若内容中包含指定data内容，则为true**\n\n```java\npublic class KeyWordExpression implements Expression {\n\n    private String data;\n\n    public KeyWordExpression(String data){\n        this.data = data;\n    }\n\n\n    @Override\n    public boolean interpret(String content) {\n        if (data != null){\n            return content.contains(data);\n        }\n        else {\n            throw new RuntimeException(\"未设置表达式data内容\");\n        }\n    }\n}\n```\n\n**或表达式**\n\n```java\npublic class OrExpression implements Expression {\n\n    private Expression exp1;\n    private Expression exp2;\n\n    public OrExpression(Expression exp1,Expression exp2) {\n        this.exp1 = exp1;\n        this.exp2 = exp2;\n    }\n\n    @Override\n    public boolean interpret(String content) {\n        return exp1.interpret(content) || exp2.interpret(content);\n    }\n}\n```\n\n**与表达式**\n\n```java\npublic class AndExpression implements Expression {\n\n    private Expression exp1;\n    private Expression exp2;\n\n    public AndExpression(Expression exp1, Expression exp2) {\n        this.exp1 = exp1;\n        this.exp2 = exp2;\n    }\n\n    @Override\n    public boolean interpret(String content) {\n        return exp1.interpret(content) && exp2.interpret(content);\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        KeyWordExpression exp1 = new KeyWordExpression(\"CleWm\");\n        boolean res1 = exp1.interpret(\"I am CleWm\");\n\n        KeyWordExpression exp2 = new KeyWordExpression(\"CleWm\");\n        KeyWordExpression exp3 = new KeyWordExpression(\"clewm\");\n\n        OrExpression exp4 = new OrExpression(exp2, exp3);\n        boolean res2 = exp4.interpret(\"CleWm\");\n        AndExpression exp5 = new AndExpression(exp2, exp3);\n        boolean res3 = exp5.interpret(\"CleWm\");\n        System.out.println(res1);\n        System.out.println(res2);\n        System.out.println(res3);\n    }\n}\n```\n\n**结果**\n\n![image-20221217104357944](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104357944.png)\n\n## 17.迭代器模式\n\nIterator，这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。\n\n**创建迭代器接口**\n\n```java\npublic interface Container {\n\n    MyIterator getIterator();\n}\n```\n\n**创建容器接口，该接口用于使得容器能够返回一个迭代器**\n\n```java\npublic interface Container {\n\n    MyIterator getIterator();\n}\n```\n\n**创建容器的实现**\n\n```java\npublic class PersonRepository implements Container {\n\n    private static final List<String> personList;\n    private int index;\n\n    static {\n        personList = ListUtil.of(\"张三\",\"李四\",\"王五\",\"赵六\");\n    }\n\n    @Override\n    public MyIterator getIterator() {\n        index = 0;\n        return new PersonIterator();\n    }\n\n    private class PersonIterator implements MyIterator<String>{\n\n        @Override\n        public boolean hasNext() {\n            return personList.size() > 0 && index < personList.size();\n        }\n\n        @Override\n        public String next() {\n            return personList.get(index++);\n        }\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1(){\n        PersonRepository personRepository = new PersonRepository();\n        MyIterator iterator = personRepository.getIterator();\n        while (iterator.hasNext()){\n            System.out.println(iterator.next());\n        }\n    }\n}\n```\n\n**结果**\n\n![image-20221217104416848](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104416848.png)\n\n## 18.中介者模式\n\nMediator，这种模式提供了一个中介类，该类通常处理不同类之间的通信。\n\n聊天室为例\n\n**定义用户**\n\n```java\n@Data\npublic class User {\n\n    private String name;\n    private ChatRoom chatRoom;\n\n    public User(String name){\n        this.name = name;\n    }\n\n    public void sendMessage(String content) {\n        System.out.println(name + \" 发送一条消息:\" + content);\n        Message message = new Message(name, content);\n        if(chatRoom == null){\n            throw new RuntimeException(\"未加入任何聊天室\");\n        }\n        chatRoom.send(message);\n    }\n\n    public void receiveMessage(Message message) {\n        System.out.println(name + \" 收到一条消息: \" + message);\n    }\n}\n```\n\n**定义消息**\n\n```java\n@Data\n@AllArgsConstructor\npublic class Message {\n\n    private String from;\n    private String content;\n}\n```\n\n**定义聊天室**\n\n```java\npublic class ChatRoom {\n\n    private List<User> userList = new ArrayList<>();\n\n    public void send(Message message){\n        for (User user : userList){\n            if(message.getFrom().equals(user.getName())) continue;\n            user.receiveMessage(message);\n        }\n    }\n\n    public void register(User user) {\n        user.setChatRoom(this);\n        userList.add(user);\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        ChatRoom chatRoom = new ChatRoom();\n\n        User 张三 = new User(\"张三\");\n        User 李四 = new User(\"李四\");\n        User 王五 = new User(\"王五\");\n        chatRoom.register(张三);\n        chatRoom.register(李四);\n        chatRoom.register(王五);\n\n        张三.sendMessage(\"你好，我是张三\");\n    }\n}\n```\n\n**结果**\n\n![image-20221217104510201](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104510201.png)\n\n## 19.备忘录模式\n\nMemento，保存（备份）一个对象的某个状态，以便在适当的时候恢复对象。\n\n**Memento ： 备忘录对象,负责 保存好记录，即Originator内部 状态**\n\n```java\n@Data\npublic class Memento {\n\n    private String state;\n\n    public Memento(String state){\n        this.state = state;\n    }\n}\n```\n\n**originator : 对象(需要保存 状态的对象)**\n\n```java\n@Data\npublic class Originator {\n\n    private String state;\n\n    public Memento saveStateToMemento() {\n        return new Memento(state);\n    }\n\n    public void restoreStateFromMemento(Memento memento) {\n        this.state = memento.getState();\n    }\n}\n```\n\n**Caretaker: 备忘录管理者,负责保存多个备忘录对象， 使用集合管理，提高效率**\n\n```java\npublic class MementoManager {\n\n    private static List<Memento> mementoList;\n\n    static {\n        mementoList = new ArrayList<>();\n    }\n\n    public static boolean add(Memento memento){\n        return mementoList.add(memento);\n    }\n\n    public static Memento remove(int index) {\n        return mementoList.remove(index);\n    }\n\n    public static Memento get(int index){\n        return mementoList.get(index);\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        Originator originator = new Originator();\n        originator.setState(\"初始状态\");\n        boolean add = MementoManager.add(originator.saveStateToMemento());\n        if(!add) throw new RuntimeException(\"保存状态失败！\");\n        originator.setState(\"第一状态\");\n        System.out.println(\"origin的状态为:\" + originator.getState());\n        originator.restoreStateFromMemento(MementoManager.get(0));\n        System.out.println(\"origin的状态为:\" + originator.getState());\n    }\n}\n```\n\n**结果**\n\n**![image-20221217104545873](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104545873.png)**\n\n## 20.观察者模式\n\nObserver，当一个对象被修改时，则会自动通知依赖它的对象。\n\n**创建一个被订阅的（Up主）**\n\n```java\npublic class Up {\n\n    private String latestVideo;\n\n    private List<Follower> followers = new ArrayList<>();\n\n    public void submitVideo(String video) {\n        this.latestVideo = video;\n        notifyAllFollowers();\n    }\n\n    public void addFollower(Follower follower) {\n        followers.add(follower);\n    }\n\n    public void notifyAllFollowers() {\n        for (Follower follower : followers) {\n            follower.update(latestVideo);\n        }\n    }\n}\n```\n\n**创建一个订阅者（粉丝）**\n\n```java\npublic class Follower{\n\n    private String name;\n    private String video;\n    private Up up;\n\n    public Follower(String name,Up up) {\n        this.name = name;\n        this.up = up;\n        this.up.addFollower(this);\n    }\n\n    public void update(String video) {\n        this.video = video;\n        System.out.println(name + \" 收到up主 \" + up + \" 的最新视频 \" + video);\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        Up up = new Up();\n        Follower 张三 = new Follower(\"张三\", up);\n        Follower 李四 = new Follower(\"李四\", up);\n\n        up.submitVideo(\"第1个视频\");\n        System.out.println(\"-------------\");\n        up.submitVideo(\"第2个视频\");\n    }\n}\n```\n\n**结果**\n\n![image-20221217104623464](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104623464.png)\n\n## 21.状态模式\n\nState，类的行为是基于它的状态改变的。\n\n**定义状态接口**\n\n```java\npublic interface State {\n\n    void doAction(Context context);\n}\n```\n\n**定义一个随着状态改变而做出不同行为的Context上下文**\n\n```java\n@Data\npublic class Context {\n\n    private State state;\n\n}\n```\n\n**定义状态的实现**\n\n```java\npublic class StartState implements State {\n\n    @Override\n    public void doAction(Context context) {\n        System.out.println(\"当前是开始状态...\");\n        context.setState(this);\n    }\n}\n```\n\n```java\npublic class EndState implements State {\n    @Override\n    public void doAction(Context context) {\n        System.out.println(\"当前是结束状态...\");\n        context.setState(this);\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        Context context = new Context();\n\n        StartState startState = new StartState();\n        startState.doAction(context);\n\n        EndState endState = new EndState();\n        endState.doAction(context);\n    }\n}\n```\n\n**结果**\n\n![image-20221217104706915](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104706915.png)\n\n## 22.空对象模式\n\nNull Object，一个空对象取代 NULL 对象。\n\n**定义实体类抽象父类**\n\n```java\n@Data\npublic abstract class AbstractUser {\n\n    protected String name;\n\n    public abstract boolean isNull();\n}\n```\n\n**定义正常的存在的用户对象**\n\n```java\npublic class User extends AbstractUser{\n    public User(String name){\n        this.name = name;\n    }\n\n    @Override\n    public boolean isNull() {\n        return false;\n    }\n}\n```\n\n**空对象**\n\n```java\npublic class EmptyUser extends AbstractUser{\n\n    public EmptyUser() {\n        this.name = \"空用户对象...\";\n    }\n\n    @Override\n    public boolean isNull() {\n        return true;\n    }\n}\n```\n\n**创建一个测试用的工厂**\n\n```java\npublic class UserFactory {\n\n    private static List<String> nameList;\n\n    static {\n        nameList = ListUtil.of(\"张三\",\"李四\",\"王五\");\n    }\n\n    public static AbstractUser getUser(String name) {\n        for (String n : nameList) {\n            if(n.equalsIgnoreCase(name)){\n                return new User(name);\n            }\n        }\n        return new EmptyUser();\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        AbstractUser 张三 = UserFactory.getUser(\"张三\");\n        AbstractUser 赵六 = UserFactory.getUser(\"赵六\");\n\n        System.out.println(张三);\n        System.out.println(赵六);\n    }\n}\n```\n\n**结果**\n\n![image-20221214080526276](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214080526276.png)\n\n## 23.策略模式\n\nStrategy，一个类的行为或其算法可以在运行时更改。\n\n**定义策略的接口**\n\n```java\npublic interface Strategy {\n\n    public int doStrategy(int a,int b);\n}\n```\n\n**定义策略实现**\n\n```java\npublic class AddStrategy implements Strategy {\n\n    @Override\n    public int doStrategy(int a, int b) {\n        return a + b;\n    }\n}\n```\n\n```java\npublic class SubStrategy implements Strategy {\n    @Override\n    public int doStrategy(int a, int b) {\n        return a - b;\n    }\n}\n```\n\n**定义一个可更改策略的上下文**\n\n```java\n@Data\npublic class Context {\n\n    private Strategy strategy;\n\n    public int executeStrategy(int a,int b){\n        if(strategy != null){\n            return strategy.doStrategy(a,b);\n        }else {\n            throw new RuntimeException(\"尚未设置策略！\");\n        }\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        Context context = new Context();\n        AddStrategy addStrategy = new AddStrategy();\n        SubStrategy subStrategy = new SubStrategy();\n\n        context.setStrategy(addStrategy);\n        int i1 = context.executeStrategy(1, 2);\n        System.out.println(i1);\n\n        context.setStrategy(subStrategy);\n        int i2 = context.executeStrategy(5, 2);\n        System.out.println(i2);\n    }\n}\n```\n\n**结果**\n\n两个3\n\n## 24.模板模式\n\nTemplate，在抽象类中提前定义了某个操作的一系列流程的模板，用户只需要实现具体细节即可。\n\n**定义抽象模板父类**\n\n```java\npublic abstract class MyGame {\n\n    protected String name;\n\n    abstract void downloadGame();\n    abstract void installGame();\n    abstract void openGame();\n\n    public void playGame() {\n        downloadGame();\n        installGame();\n        openGame();\n        System.out.println(\"开始游戏:[\" + name + \"]\");\n    }\n}\n```\n\n**创建抽象父类的实现**\n\n```java\npublic class LOL extends MyGame{\n\n    public LOL(){\n        this.name = \"LOL\";\n    }\n\n    @Override\n    void downloadGame() {\n        System.out.println(\"正在下载游戏:\" + name);\n    }\n\n    @Override\n    void installGame() {\n        System.out.println(\"正在安装游戏:\" + name);\n    }\n\n    @Override\n    void openGame() {\n        System.out.println(\"正在打开游戏:\" + name);\n    }\n}\n```\n\n```java\npublic class CSGO extends MyGame{\n\n    public CSGO() {\n        this.name = \"CSGO\";\n    }\n\n    @Override\n    void downloadGame() {\n        System.out.println(\"正在下载游戏:\" + name);\n    }\n\n    @Override\n    void installGame() {\n        System.out.println(\"正在安装游戏:\" + name);\n    }\n\n    @Override\n    void openGame() {\n        System.out.println(\"正在打开游戏:\" + name);\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        LOL lol = new LOL();\n        CSGO csgo = new CSGO();\n\n        lol.playGame();\n        csgo.playGame();\n    }\n}\n```\n\n**结果**\n\n![image-20221215170923686](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221215170923686.png)\n\n## 25.访问者模式\n\nVisitor，封装一些作用于某些数据结构中的各元素的操作，它可以在不改变数据结构的前提下赋予这些元素新的操作。\n\n**定义被访问者的统一接口**\n\n```java\npublic interface Person{\n\n    public void accept(Visitor visitor);\n}\n```\n\n**定义被访问者实例**\n\n```java\n@Data\n@AllArgsConstructor\npublic class Student implements Person {\n\n    private String name;\n    private Integer rank;\n\n    @Override\n    public void accept(Visitor visitor) {\n        visitor.visit(this);\n    }\n}\n```\n\n```java\n@Data\n@AllArgsConstructor\npublic class Teacher implements Person {\n\n    private String name;\n    private Integer salary;\n\n    @Override\n    public void accept(Visitor visitor) {\n        visitor.visit(this);\n    }\n}\n```\n\n**定义访问者接口**\n\n```java\npublic interface Visitor {\n\n    public void visit(Student student);\n\n    public void visit(Teacher teacher);\n}\n```\n\n**定义访问者实例**\n\n```java\npublic class Headmaster implements Visitor {\n    @Override\n    public void visit(Student student) {\n        System.out.println(\"访问学生:\" + student.getName() + \",排名为:\" + student.getRank());\n    }\n\n    @Override\n    public void visit(Teacher teacher) {\n        System.out.println(\"访问老师:\" + teacher.getName() + \",月薪为:\" + teacher.getSalary());\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        Student student = new Student(\"张三\",21);\n        Teacher teacher = new Teacher(\"张雪迎\",8000);\n        Headmaster headmaster = new Headmaster();\n\n        student.accept(headmaster);\n        teacher.accept(headmaster);\n    }\n}\n```\n\n**结果**\n\n![image-20221216100457969](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221216100457969.png)\n","source":"_posts/Java/设计模式.md","raw":"---\ntitle: 25种设计模式代码示例\n\ncategories: \n- 技术\n- 设计模式\n- 开发常用\n\ntags:\n- Java\n- 设计模式\n\ndescription: 25种设计模式代码示例\n---\n\n# 设计模式\n\n菜鸟设计模式：\n\nhttps://www.runoob.com/design-pattern/design-pattern-tutorial.html\n\n\n\nUML类图教程：\n\nhttps://blog.csdn.net/weixin_57504000/article/details/124218420\n\n创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。\n\n结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。\n\n行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n\n# 一、创建型模式\n\n## 1.工厂模式\n\n获得**复杂对象**实例（简单对象只需要new即可），而无须关心其具体的实现细节。\n\n**实现：**\n\n定义一个接口\n\n```java\npublic interface Phone {\n\n    public String use();\n}\n```\n\n定义实体，并继承该接口\n\n```java\npublic class Oppo implements Phone {\n\n    @Override\n    public String use() {\n        return \"我是oppo  \";\n    }\n}\n```\n\n```java\npublic class Xiaomi implements Phone {\n\n    @Override\n    public String use() {\n        return \"我是小米\";\n    }\n}\n```\n\n定义工厂类：\n\n```java\npublic class PhoneFactory {\n\n    public static class Type{\n        public static final String TYPE_XIAOMI = \"xiaomi\";\n        public static final String TYPE_OPPO = \"oppo\";\n    }\n\n    public Phone getPhoneByType(String type) {\n        if(type.equalsIgnoreCase(Type.TYPE_XIAOMI)){\n            return new Xiaomi();\n        }else if(type.equalsIgnoreCase(Type.TYPE_OPPO)){\n            return new Oppo();\n        }\n        return null;\n    }\n}\n```\n\n使用：\n\n```java\npublic class Test {\n\n    public static void main(String[] args) {\n        PhoneFactory phoneFactory = new PhoneFactory();\n        Phone xiaomi = phoneFactory.getPhoneByType(PhoneFactory.Type.TYPE_XIAOMI);\n        System.out.println(xiaomi.use());\n    }\n}\n```\n\n**结果**\n\n![image-20221214080627939](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214080627939.png)\n\n## 2.抽象工厂模式\n\n抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。\n\n\n\n定义一个抽象工厂类：\n\n```java\npublic abstract class AbstractFactory {\n\n    public abstract Phone getPhoneByType(String phoneType);\n\n    public abstract Color getColorByType(String phoneType);\n}\n```\n\n具体的工厂类继承该抽象工厂类：\n\n手机工厂：\n\n```java\npublic class PhoneFactory extends AbstractFactory {\n\n    public static class Type{\n        public static final String TYPE_XIAOMI = \"xiaomi\";\n        public static final String TYPE_OPPO = \"oppo\";\n    }\n\n    public Phone getPhoneByType(String type) {\n        if(type.equalsIgnoreCase(Type.TYPE_XIAOMI)){\n            return new Xiaomi();\n        }else if(type.equalsIgnoreCase(Type.TYPE_OPPO)){\n            return new Oppo();\n        }\n        return null;\n    }\n\n    @Override\n    public Color getColorByType(String phoneType) {\n        return null;\n    }\n}\n```\n\n颜色工厂：\n\n```java\npublic class ColorFactory extends AbstractFactory {\n\n    public static class TYPE{\n        public static final String TYPE_RED = \"red\";\n\n        public static final String TYPE_YELLOW = \"yellow\";\n    }\n\n    @Override\n    public Phone getPhoneByType(String phoneType) {\n\n        return null;\n    }\n\n    @Override\n    public Color getColorByType(String phoneType) {\n        if (TYPE.TYPE_RED.equalsIgnoreCase(phoneType)) {\n            return new Red();\n        }else if (TYPE.TYPE_YELLOW.equalsIgnoreCase(phoneType)){\n            return new Yellow();\n        }\n        return null;\n    }\n}\n```\n\n定义一个超级工厂类，用于获得具体的工厂：\n\n```java\npublic class RootFactory {\n\n    public static class TYPE{\n        public static final String TYPE_PHONE = \"phone\";\n        public static final String TYPE_COLOR = \"color\";\n    }\n\n    public static AbstractFactory getFactoryByType(String factoryType) {\n        if (TYPE.TYPE_PHONE.equalsIgnoreCase(factoryType)){\n            return new PhoneFactory();\n        }else if(TYPE.TYPE_COLOR.equals(factoryType)){\n            return new ColorFactory();\n        }\n        return null;\n    }\n}\n```\n\n使用：\n\n```java\npublic static void main(String[] args) {\n    //获得工厂\n    AbstractFactory factoryByType = RootFactory.getFactoryByType(RootFactory.TYPE.TYPE_COLOR);\n    //从工厂获得对象\n    Color colorByType = factoryByType.getColorByType(ColorFactory.TYPE.TYPE_RED);\n    System.out.println(colorByType.show());\n}\n```\n\n**结果**\n\n![image-20221214080715116](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214080715116.png)\n\n## 3.构造器模式\n\n参考：https://www.dandelioncloud.cn/article/details/1523275053169147905\n\n传统的构造对象方式：\n\n```java\nPerson person = new Person();\nperson.setId(1);\nperson.setName(\"张小毛\");\nperson.setAge(22);\nperson.setSex(\"男\");\nperson.setPhone(\"19999999999\");\nperson.setAddress(\"beijing\");\nperson.setDesc(\"JavaBeans模式\");\n```\n\n- 优点：易于阅读，并且可以只对有用的成员变量赋值\n- 缺点：成员变量不可以是 final 类型，失去了不可变对象的很多好处，对象状态不连续，你必须调用7次setter方法才能得到一个具备7个属性值得变量，在这期间用户可能拿到不完整状态的对象。如果有N个属性，岂不是要`person.setXXX`调用N次？此种方式不优雅\n\n构造器模式演示：\n\n```java\nPrivateKeyDecryptParam param = new PrivateKeyDecryptParam.Builder()\n                                              .uAppId(uAppId)\n                                              .containerId(containerId)\n                                              .cipher(cipher)\n                                              .signFlag(signFlag)\n                                              .build();\n```\n\n示例：\n\n```java\n@Data\n@ToString\npublic class User {\n\n    private String name;\n\n    private Integer age;\n\n    private Integer sex;\n\n    private User(Builder builder){\n        this.name = builder.name;\n        this.age = builder.age;\n        this.sex = builder.sex;\n    }\n\n    public static class Builder {\n\n        //必要参数\n        private final String name;\n\n        //可选参数\n        private Integer age;\n        private Integer sex;\n\n        public Builder(String name){\n            this.name = name;\n        }\n\n        public Builder age(Integer age) {\n            this.age = age;\n            return this;\n        }\n\n        public Builder sex(Integer sex) {\n            this.sex = sex;\n            return this;\n        }\n\n        public User build() {\n            return new User(this);\n        }\n    }\n}\n```\n\n使用：\n\n```java\n        User cleWm = new User.Builder(\"CleWm\")\n                .age(21)\n                .sex(0)\n                .build();\n```\n\n要点：\n\n- 外部类的构造函数私有，且参数为静态内部类；\n- 静态内部类拥有外部类相同的属；\n- 为每一个属性，写一个方法，返回的是Builer；\n- 最后一个方法是build方法，用于构建一个外部类；\n\n优点：降低复杂性，优雅\n\n缺点：代码量提高了\n\n\n\n## 4.单例模式\n\n一个类确保只有单个对象被创建\n\n**饿汉式：**\n\n```java\npublic class HungrySingleton {\n\n    private static HungrySingleton instance = new HungrySingleton();\n\n    private HungrySingleton(){}\n\n    public static HungrySingleton getInstance(){\n        return instance;\n    }\n}\n```\n\n**懒汉式：**\n\n双重检查锁：\n\n```java\npublic class LazySingleton {\n\n    private static LazySingleton instance;\n\n    private LazySingleton() {}\n\n    public static LazySingleton getInstance() {\n        if(instance == null){\n            synchronized (LazySingleton.class){\n                if (instance == null){\n                    instance = new LazySingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n静态内部类：\n\n```java\npublic class LazySingleton2 {\n\n    private LazySingleton2(){}\n\n    /**\n     * 静态内部类和非静态内部类都是在被调用的时候才会进行加载，和外部类没有关系，从而实现了延迟加载\n     */\n    private static class SingletonHolder{\n        private static final LazySingleton2 instance = new LazySingleton2();\n    }\n\n    public static LazySingleton2 getInstance() {\n        return SingletonHolder.instance;\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        LazySingleton instance1 = LazySingleton.getInstance();\n        LazySingleton instance2 = LazySingleton.getInstance();\n        System.out.println(instance1 == instance2);\n\n        LazySingleton2 instance3 = LazySingleton2.getInstance();\n        LazySingleton2 instance4 = LazySingleton2.getInstance();\n        System.out.println(instance3 == instance4);\n    }\n}\n```\n\n**结果**\n\n![image-20221214081317951](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214081317951.png)\n\n## 5.原型模式\n\n原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。一般会配合工厂模式一起使用。\n\n与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。\n\n定义一个抽象父类，并实现Cloneable接口：\n\n```java\n/**\n * Cloneable是一个标识接口，clone方法是Object提供的方法，\n * 只有实现了Cloneable接口，同时重写clone方法才不会报错\n */\n@Getter\n@ToString\npublic abstract class Book implements Cloneable{\n\n    protected String name;\n\n    protected Integer type;\n\n    @Override\n    protected Book clone(){\n        Object clone = null;\n        try{\n            clone = super.clone();\n        }catch (CloneNotSupportedException e){\n            e.printStackTrace();\n        }\n        return (Book)clone;\n    }\n}\n```\n\n定义具体实现类：\n\n```java\npublic class BookOne extends Book{\n\n    BookOne() {\n        name = \"《第一本书》\";\n        type = 1;\n    }\n}\n```\n\n```java\npublic class BookTwo extends Book{\n\n    BookTwo() {\n        name = \"《第二本书》\";\n        type = 2;\n    }\n}\n```\n\n定义一个Factory来获得克隆对象：\n\n```java\npublic class BookFactory {\n\n    /**\n     * 用于存储我们的原始对象，克隆对象以此为基础进行复制\n     */\n    private static final Map<Integer,Book> cache;\n\n    static {\n        cache = new HashMap<>();\n        cache.put(Type.TYPE_ONE,new BookOne());\n        cache.put(Type.TYPE_TWO,new BookTwo());\n    }\n\n    public static class Type{\n        public static final Integer TYPE_ONE = 1;\n        public static final Integer TYPE_TWO = 2;\n    }\n\n    /**\n     * 返回的是克隆对象\n     * @param type\n     * @return\n     */\n    public static Book getBookByType(Integer type) {\n        return cache.get(type).clone();\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n    @org.junit.Test\n    public void test1() {\n        Book book1 = BookFactory.getBookByType(BookFactory.Type.TYPE_ONE);\n        Book book2 = BookFactory.getBookByType(BookFactory.Type.TYPE_ONE);\n        System.out.println(book1 == book2);\n        System.out.println(book1);\n        System.out.println(book2);\n    }\n}\n```\n\n**结果**\n\n![image-20221214081502987](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214081502987.png)\n\n# 二、结构型模式\n\n## 6.适配器模式\n\n适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁\n\n比如220V的电源，使用电源适配器给手机提供12V的电压充电。\n\n**定义一个目标接口，该接口属于一般情况**\n\n```java\npublic interface Target {\n\n    public void get();\n}\n```\n\n**定义一个不兼容的，需要被适配的实现**\n\n```java\npublic class SpecialStatus {\n\n    public void specialGet() {\n        System.out.println(\"这是特殊情况的get实现\");\n    }\n}\n```\n\n**定义适配器，实现Target接口**\n\n```java\npublic class Adapter implements Target {\n\n    private SpecialStatus specialStatus;\n\n    public Adapter(SpecialStatus specialStatus){\n        this.specialStatus = specialStatus;\n    }\n\n    @Override\n    public void get() {\n        specialStatus.specialGet();\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        SpecialStatus specialStatus = new SpecialStatus();\n        Adapter adapter = new Adapter(specialStatus);\n        adapter.get();\n    }\n}\n```\n\n**结果**\n\n![image-20221217093732742](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217093732742.png)\n\n## 7.桥接模式\n\nBridge，它的作用是将抽象部分和它的实现部分分离，从而可以让它们独立地变化。\n\n就好比有一个武器槽，放不同的武器进去就是不同的功能。s\n\n**先定义抽象部分，比如武器槽**\n\n```java\npublic abstract class WeaponSlot {\n\n    protected Weapon weapon;\n\n    abstract void shoot();\n\n    public void setWeapon(Weapon weapon){\n        this.weapon = weapon;\n    }\n\n    public abstract void opreation();\n}\n```\n\n**定义实现的接口**\n\n```java\npublic interface Weapon {\n\n    void shoot();\n}\n```\n\n**定义抽象部分的实现**\n\n```java\npublic class LeftSlot extends WeaponSlot{\n\n    @Override\n    void shoot() {\n        weapon.shoot();\n    }\n\n    @Override\n    public void opreation() {\n        weapon.shoot();\n    }\n}\n```\n\n**定义实现接口的实现**\n\n```java\npublic class AK47 implements Weapon {\n    @Override\n    public void shoot() {\n        System.out.println(\"AK开枪了！\");\n    }\n}\n```\n\n```java\npublic class M4 implements Weapon {\n    @Override\n    public void shoot() {\n        System.out.println(\"m4开枪！\");\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n\n        M4 m4 = new M4();\n        AK47 ak47 = new AK47();\n\n        LeftSlot leftSlot = new LeftSlot();\n        leftSlot.setWeapon(m4);\n        leftSlot.opreation();\n\n        leftSlot.setWeapon(ak47);\n        leftSlot.opreation();\n    }\n}\n```\n\n**结果**\n\n![image-20221217103542571](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103542571.png)\n\n## 8.过滤器模式\n\nFilter ，它的作用是过滤序列中的特定元素。\n\n**定义一个过滤器的接口**\n\n```java\npublic interface Filter <T>{\n\n    List<T> doFilter(List<T> lists);\n}\n```\n\n**定义要过滤的实体类**\n\n```java\n@Data\npublic class User {\n\n    private String name;\n\n    private Integer age;\n\n    private Integer sex;\n}\n```\n\n**定义过滤器的具体实现**\n\n年龄过滤器：\n\n```java\npublic class AgeFilter implements Filter<User> {\n\n    @Override\n    public List<User> doFilter(List<User> lists) {\n        ArrayList<User> res = new ArrayList<>();\n        for (User user : lists) {\n            if(user.getAge() >= 18){\n                res.add(user);\n            }\n        }\n        return res;\n    }\n}\n```\n\n性别过滤器：\n\n```java\npublic class SexFilter implements Filter<User> {\n    @Override\n    public List<User> doFilter(List<User> lists) {\n        ArrayList<User> res = new ArrayList<>();\n        for (User user : lists) {\n            if (user.getSex() == 1){\n                res.add(user);\n            }\n        }\n        return res;\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        AgeFilter ageFilter = new AgeFilter();\n        SexFilter sexFilter = new SexFilter();\n        ArrayList<User> userArrayList = new ArrayList<>();\n        for (int i = 1; i < 10; i++) {\n            User user = new User();\n            user.setAge(RandomUtil.randomInt(10,35));\n            user.setName(\"张\" + i);\n            user.setSex(RandomUtil.randomEle(new Integer[]{0,1}));\n            userArrayList.add(user);\n        }\n        List<User> users1 = ageFilter.doFilter(userArrayList);\n        System.out.println(\"第一次过滤后的结果：\" + users1);\n\n        List<User> users2 = sexFilter.doFilter(users1);\n        System.out.println(\"第二次过滤后的结果：\" + users2);\n    }\n}\n```\n\n**结果**\n\n![image-20221217103713100](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103713100.png)\n\n## 9.组合模式\n\nComposite，是用于把一组相似的对象当作一个单一的对象。组合模式依据**树形结构**来组合对象，用来表示部分以及整体层次。\n\n例如：在可视化开发中，容器和按钮等组件之间的关系。又或者是公司、学校的组织架构等。\n\n以学校为例：\n\n**定义一个员工类：**\n\n```java\n@Data\n@ToString(exclude = \"subordinates\")\npublic class Employee {\n\n    private String name;\n\n    private String dept;\n\n    private Integer salary;\n\n    private List<Employee> subordinates;\n\n    public Employee(String name, String dept, Integer salary) {\n        this.name = name;\n        this.dept = dept;\n        this.salary = salary;\n        this.subordinates = new ArrayList<>();\n    }\n\n    public void addSubordinate(Employee subordinate) {\n        subordinates.add(subordinate);\n    }\n\n    public void removeSubordinate(Employee subordinate) {\n        subordinates.remove(subordinate);\n    }\n}\n```\n\n**测试：**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        Employee 张昌平 = new Employee(\"张昌平\", \"校长\", 30000);\n\n        Employee 张雪迎 = new Employee(\"张雪迎\", \"7班班主任\", 10000);\n        Employee 刘静 = new Employee(\"刘静\", \"8班班主任\", 9000);\n\n        Employee 胡伟明 = new Employee(\"胡伟明\", \"7班学生\", 0);\n        Employee 李冠杰 = new Employee(\"李冠杰\", \"7班学生\", 0);\n        Employee 田继睿 = new Employee(\"田继睿\", \"7班学生\", 0);\n        Employee 冯毅力 = new Employee(\"冯毅力\", \"7班学生\", 0);\n\n        Employee 冯跟源 = new Employee(\"冯跟源\", \"8班学生\", 0);\n        Employee 施冰清 = new Employee(\"施冰清\", \"8班学生\", 0);\n\n\n\n        张昌平.addSubordinate(张雪迎);\n        张昌平.addSubordinate(刘静);\n\n\n        张雪迎.addSubordinate(胡伟明);\n        张雪迎.addSubordinate(李冠杰);\n        张雪迎.addSubordinate(田继睿);\n        张雪迎.addSubordinate(冯毅力);\n\n        刘静.addSubordinate(冯跟源);\n        刘静.addSubordinate(施冰清);\n\n        /**\n         * 二叉树如下:\n         *                      张昌平\n         *                    /      \\\n         *                   /        \\\n         *                张雪迎        刘静\n         *                / | | \\      / \\\n         *               /  | |  \\    /   \\\n         *             胡   李 冯 田   冯   施\n         */\n        System.out.println(张昌平);\n        for (Employee sub1 : 张昌平.getSubordinates()){\n            System.out.println(sub1);\n            for (Employee sub2 : sub1.getSubordinates()){\n                System.out.println(sub2);\n            }\n        }\n    }\n}\n```\n\n**结果**\n\n![image-20221217103845510](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103845510.png)\n\n## 10.装饰器模式\n\nDecorator，允许向一个现有的对象添加新的功能，同时又不改变其结构。\n\n**定义一个接口**\n\n```java\npublic interface Person {\n\n    void eat();\n}\n```\n\n**定义一个接口的实现**\n\n```java\npublic class CleWm implements Person {\n    @Override\n    public void eat() {\n        System.out.println(\"吃了一碗饭...\");\n    }\n}\n```\n\n**定义一个装饰器，实现接口**\n\n```java\npublic class Decorator implements Person {\n\n    private Person person;\n\n    @Override\n    public void eat() {\n        person.eat();\n        System.out.println(\"person又吃了一碗...\");\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        CleWm cleWm = new CleWm();\n        Decorator decorator = new Decorator();\n        decorator.setPerson(cleWm);\n        decorator.eat();\n    }\n}\n```\n\n**结果**\n\n![image-20221217103941837](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103941837.png)\n\n## 11.外观模式\n\nFacade，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。\n\n```java\n// 外观类\npublic class Facade {\n   private Subsystem1 subsystem1;\n   private Subsystem2 subsystem2;\n\n   public Facade() {\n      subsystem1 = new Subsystem1();\n      subsystem2 = new Subsystem2();\n   }\n\n   // 提供一个简化的接口，用于客户端访问子系统\n   public void operation() {\n      subsystem1.operation1();\n      subsystem2.operation1();\n   }\n}\n\n// 子系统1\npublic class Subsystem1 {\n   public void operation1() {\n      // 实现子系统1的相关操作\n   }\n}\n\n// 子系统2\npublic class Subsystem2 {\n   public void operation1() {\n      // 实现子系统2的相关操作\n   }\n}\n```\n\n## 12.享元模式\n\nFlyweight，主要用于减少创建对象的数量，以减少内存占用和提高性能。\n\n说白了就是在工厂模式的工厂类中，缓存一个Map，每次创建对象的时候就进行一个判断，若指定对象存在，则直接从map中取出并返回，若没有，则新建，然后缓存进入Map当中。\n\n**创建一个颜色**\n\n```java\npublic class Color {\n\n    public String colorName;\n\n    public Color(String colorName){\n        this.colorName = colorName;\n    }\n}\n```\n\n**创建一个颜色工厂**\n\n```java\npublic class ColorFactory {\n\n    private Map<String, Color> map = new HashMap<>();\n\n    public Color getColor(String colorName) {\n        return Optional.ofNullable(map.get(colorName)).orElseGet(()->{\n            Color color = new Color(colorName);\n            map.put(colorName,color);\n            return color;\n        });\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        ColorFactory colorFactory = new ColorFactory();\n        Color red1 = colorFactory.getColor(\"red\");\n        Color red2 = colorFactory.getColor(\"red\");\n        Color red3 = colorFactory.getColor(\"blue\");\n        System.out.println(red1 == red2);\n    }\n}\n```\n\n**结果**\n\n![image-20221217104139185](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104139185.png)\n\n## 13.代理模式\n\nProxy，它通过引入一个新的类来控制对另一个对象的访问。这有助于控制对原始对象的访问，并且可以在访问原始对象时执行其他附加操作。\n\n**定义一个接口，包含被代理的方法**\n\n```java\npublic interface Image {\n\n    public void show();\n}\n```\n\n**定义原始类**\n\n```java\npublic class Realimage implements Image {\n\n    private String path;\n\n    public Realimage(String path) {\n        this.path = path;\n        loadFromDisk();\n    }\n\n    @Override\n    public void show() {\n        System.out.println(\"展示\" + path + \"的图片\");\n    }\n\n    void loadFromDisk() {\n        System.out.println(\"正在从磁盘中加载图片:\" + path);\n    }\n}\n```\n\n**定义代理对象**\n\n```java\npublic class ProxyImage implements Image {\n\n    private String path;\n\n    private Realimage realimage;\n\n    public ProxyImage(String path) {\n        this.path = path;\n    }\n\n    @Override\n    public void show() {\n        if(realimage == null){\n            realimage = new Realimage(path);\n        }\n        realimage.show();\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        ProxyImage proxyImage = new ProxyImage(\"C:\\\\test.jpg\");\n        proxyImage.show();\n    }\n}\n```\n\n**结果**\n\n![image-20221217104158303](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104158303.png)\n\n# 三、行为型模式\n\n## 14.责任链模式\n\nChain of Responsibility，为请求创建了一个接收者对象的链。\n\n通常每个接收者都包含对另一个接收者的引用。**如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者**，依此类推。\n\n**定义一个实体**\n\n```java\n@Data\n@AllArgsConstructor\npublic class Package {\n\n    private String loc;\n}\n```\n\n**定义一个处理器的抽象父类**\n\n```java\npublic abstract class PackageHandler {\n\n    private PackageHandler next;\n\n    public void next(PackageHandler next){\n        this.next = next;\n    }\n\n    public void handler(Package p){\n        if(next != null){\n            next.handler(p);\n        }else {\n            System.out.println(\"接收到一个未知地点的包裹....\");\n        }\n    }\n}\n```\n\n**定义处理器的实现**\n\n```java\npublic class KunmingPackageHandler extends PackageHandler{\n    @Override\n    public void handler(Package p) {\n        if(\"昆明\".equals(p.getLoc())){\n            System.out.println(\"处理了一个昆明的包裹...[\" + this + \"]\");\n            return;\n        }else {\n            super.handler(p);\n        }\n    }\n}\n```\n\n```java\npublic class TianJinPackageHandler extends PackageHandler{\n\n    @Override\n    public void handler(Package p) {\n        if(\"天津\".equals(p.getLoc())){\n            System.out.println(\"处理了一个天津的包裹...[\" + this + \"]\");\n            return;\n        }else {\n            super.handler(p);\n        }\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        KunmingPackageHandler kunmingPackageHandler = new KunmingPackageHandler();\n        TianJinPackageHandler tianJinPackageHandler = new TianJinPackageHandler();\n\n        // |kunmingPackageHandler| ------ |tianJinPackageHandler| ------ null\n        kunmingPackageHandler.next(tianJinPackageHandler);\n\n\n        Package package1 = new Package(\"天津\");\n        Package package2 = new Package(\"昆明\");\n        Package package3 = new Package(\"四川\");\n\n        List<Package> packageList = ListUtil.of(package1, package2, package3);\n        for (Package aPackage : packageList) {\n            kunmingPackageHandler.handler(aPackage);\n        }\n    }\n}\n```\n\n**结果**\n\n![image-20221217104231704](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104231704.png)\n\n## 15.命令模式\n\nCommand，**命令模式允许请求的一方和接收的一方独立开来**，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。\n\n![image-20221211094616223](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221211094616223.png)\n\n简单理解就是，封装一条命令，为该命令设置一个接收者，然后将该命令set进一个调用者对象（Invoker）中，最后调用Invoker的runCommand方法来执行命令。\n\n**创建命令接口**\n\n```java\npublic interface Command {\n\n    void run();\n}\n```\n\n**创建接收者(可以理解为被隐藏的具体功能实现的部分)**\n\n```java\npublic class Receiver {\n\n    private Integer stock = 100;\n\n    /**\n     * 接收者的增加库存接口，命令调用者无须关心这些接口。\n     */\n    public void increase() {\n        stock++;\n        System.out.println(\"[库存剩余]:\" + stock);\n    }\n\n    /**\n     * 接收者的减少库存接口，命令调用者无须关心这些接口。\n     */\n    public void decrease() {\n        stock--;\n        System.out.println(\"[库存剩余]:\" + stock);\n    }\n}\n```\n\n**创建命令实现**\n\n```java\npublic class AddStockCommand implements Command {\n\n    private Receiver receiver;\n\n    public AddStockCommand(Receiver receiver) {\n        this.receiver = receiver;\n    }\n\n    @Override\n    public void run() {\n        receiver.increase();\n        System.out.println(\"添加了1个库存...\");\n    }\n}\n```\n\n```java\npublic class SubStockCommand implements Command {\n\n    private Receiver receiver;\n\n    public SubStockCommand(Receiver receiver){\n        this.receiver = receiver;\n    }\n\n    @Override\n    public void run() {\n        receiver.decrease();\n        System.out.println(\"减少了1个库存...\");\n    }\n}\n```\n\n**创建调用者**\n\n```java\npublic class Invoker{\n\n    // 这里也可用一个List来存储命令，在调用时使用for循环命令依次执行。\n    private Command command;\n\n    public Invoker(Command command){\n        this.command = command;\n    }\n\n    public void invokeCommand() {\n        if(command != null){\n            command.run();\n            System.out.println(\"命令执行完毕...\");\n        }else {\n            System.out.println(\"未设置命令！\");\n        }\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        // 创建一个接收者\n        Receiver receiver = new Receiver();\n\n        // 库存增加命令\n        AddStockCommand addStockCommand = new AddStockCommand(receiver);\n        // 库存减少命令\n        SubStockCommand subStockCommand = new SubStockCommand(receiver);\n\n        // 创建一个调用者\n        Invoker invoker1 = new Invoker(addStockCommand);\n        // 让调用者执行命令。\n        invoker1.invokeCommand();\n\n        // 创建一个调用者\n        Invoker invoker2 = new Invoker(subStockCommand);\n        // 让调用者执行命令。\n        invoker2.invokeCommand();\n    }\n}\n```\n\n**结果**\n\n![image-20221217104253518](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104253518.png)\n\n## 16.解释器模式\n\nInterpreter，它允许你定义一个语言的文法，并且基于该文法解释语言中的句子。\n\n**定义表达式接口**\n\n```java\npublic interface Expression {\n\n    boolean interpret(String content);\n}\n```\n\n**定义表达式**\n\n**关键词表达式，若内容中包含指定data内容，则为true**\n\n```java\npublic class KeyWordExpression implements Expression {\n\n    private String data;\n\n    public KeyWordExpression(String data){\n        this.data = data;\n    }\n\n\n    @Override\n    public boolean interpret(String content) {\n        if (data != null){\n            return content.contains(data);\n        }\n        else {\n            throw new RuntimeException(\"未设置表达式data内容\");\n        }\n    }\n}\n```\n\n**或表达式**\n\n```java\npublic class OrExpression implements Expression {\n\n    private Expression exp1;\n    private Expression exp2;\n\n    public OrExpression(Expression exp1,Expression exp2) {\n        this.exp1 = exp1;\n        this.exp2 = exp2;\n    }\n\n    @Override\n    public boolean interpret(String content) {\n        return exp1.interpret(content) || exp2.interpret(content);\n    }\n}\n```\n\n**与表达式**\n\n```java\npublic class AndExpression implements Expression {\n\n    private Expression exp1;\n    private Expression exp2;\n\n    public AndExpression(Expression exp1, Expression exp2) {\n        this.exp1 = exp1;\n        this.exp2 = exp2;\n    }\n\n    @Override\n    public boolean interpret(String content) {\n        return exp1.interpret(content) && exp2.interpret(content);\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        KeyWordExpression exp1 = new KeyWordExpression(\"CleWm\");\n        boolean res1 = exp1.interpret(\"I am CleWm\");\n\n        KeyWordExpression exp2 = new KeyWordExpression(\"CleWm\");\n        KeyWordExpression exp3 = new KeyWordExpression(\"clewm\");\n\n        OrExpression exp4 = new OrExpression(exp2, exp3);\n        boolean res2 = exp4.interpret(\"CleWm\");\n        AndExpression exp5 = new AndExpression(exp2, exp3);\n        boolean res3 = exp5.interpret(\"CleWm\");\n        System.out.println(res1);\n        System.out.println(res2);\n        System.out.println(res3);\n    }\n}\n```\n\n**结果**\n\n![image-20221217104357944](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104357944.png)\n\n## 17.迭代器模式\n\nIterator，这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。\n\n**创建迭代器接口**\n\n```java\npublic interface Container {\n\n    MyIterator getIterator();\n}\n```\n\n**创建容器接口，该接口用于使得容器能够返回一个迭代器**\n\n```java\npublic interface Container {\n\n    MyIterator getIterator();\n}\n```\n\n**创建容器的实现**\n\n```java\npublic class PersonRepository implements Container {\n\n    private static final List<String> personList;\n    private int index;\n\n    static {\n        personList = ListUtil.of(\"张三\",\"李四\",\"王五\",\"赵六\");\n    }\n\n    @Override\n    public MyIterator getIterator() {\n        index = 0;\n        return new PersonIterator();\n    }\n\n    private class PersonIterator implements MyIterator<String>{\n\n        @Override\n        public boolean hasNext() {\n            return personList.size() > 0 && index < personList.size();\n        }\n\n        @Override\n        public String next() {\n            return personList.get(index++);\n        }\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1(){\n        PersonRepository personRepository = new PersonRepository();\n        MyIterator iterator = personRepository.getIterator();\n        while (iterator.hasNext()){\n            System.out.println(iterator.next());\n        }\n    }\n}\n```\n\n**结果**\n\n![image-20221217104416848](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104416848.png)\n\n## 18.中介者模式\n\nMediator，这种模式提供了一个中介类，该类通常处理不同类之间的通信。\n\n聊天室为例\n\n**定义用户**\n\n```java\n@Data\npublic class User {\n\n    private String name;\n    private ChatRoom chatRoom;\n\n    public User(String name){\n        this.name = name;\n    }\n\n    public void sendMessage(String content) {\n        System.out.println(name + \" 发送一条消息:\" + content);\n        Message message = new Message(name, content);\n        if(chatRoom == null){\n            throw new RuntimeException(\"未加入任何聊天室\");\n        }\n        chatRoom.send(message);\n    }\n\n    public void receiveMessage(Message message) {\n        System.out.println(name + \" 收到一条消息: \" + message);\n    }\n}\n```\n\n**定义消息**\n\n```java\n@Data\n@AllArgsConstructor\npublic class Message {\n\n    private String from;\n    private String content;\n}\n```\n\n**定义聊天室**\n\n```java\npublic class ChatRoom {\n\n    private List<User> userList = new ArrayList<>();\n\n    public void send(Message message){\n        for (User user : userList){\n            if(message.getFrom().equals(user.getName())) continue;\n            user.receiveMessage(message);\n        }\n    }\n\n    public void register(User user) {\n        user.setChatRoom(this);\n        userList.add(user);\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        ChatRoom chatRoom = new ChatRoom();\n\n        User 张三 = new User(\"张三\");\n        User 李四 = new User(\"李四\");\n        User 王五 = new User(\"王五\");\n        chatRoom.register(张三);\n        chatRoom.register(李四);\n        chatRoom.register(王五);\n\n        张三.sendMessage(\"你好，我是张三\");\n    }\n}\n```\n\n**结果**\n\n![image-20221217104510201](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104510201.png)\n\n## 19.备忘录模式\n\nMemento，保存（备份）一个对象的某个状态，以便在适当的时候恢复对象。\n\n**Memento ： 备忘录对象,负责 保存好记录，即Originator内部 状态**\n\n```java\n@Data\npublic class Memento {\n\n    private String state;\n\n    public Memento(String state){\n        this.state = state;\n    }\n}\n```\n\n**originator : 对象(需要保存 状态的对象)**\n\n```java\n@Data\npublic class Originator {\n\n    private String state;\n\n    public Memento saveStateToMemento() {\n        return new Memento(state);\n    }\n\n    public void restoreStateFromMemento(Memento memento) {\n        this.state = memento.getState();\n    }\n}\n```\n\n**Caretaker: 备忘录管理者,负责保存多个备忘录对象， 使用集合管理，提高效率**\n\n```java\npublic class MementoManager {\n\n    private static List<Memento> mementoList;\n\n    static {\n        mementoList = new ArrayList<>();\n    }\n\n    public static boolean add(Memento memento){\n        return mementoList.add(memento);\n    }\n\n    public static Memento remove(int index) {\n        return mementoList.remove(index);\n    }\n\n    public static Memento get(int index){\n        return mementoList.get(index);\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        Originator originator = new Originator();\n        originator.setState(\"初始状态\");\n        boolean add = MementoManager.add(originator.saveStateToMemento());\n        if(!add) throw new RuntimeException(\"保存状态失败！\");\n        originator.setState(\"第一状态\");\n        System.out.println(\"origin的状态为:\" + originator.getState());\n        originator.restoreStateFromMemento(MementoManager.get(0));\n        System.out.println(\"origin的状态为:\" + originator.getState());\n    }\n}\n```\n\n**结果**\n\n**![image-20221217104545873](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104545873.png)**\n\n## 20.观察者模式\n\nObserver，当一个对象被修改时，则会自动通知依赖它的对象。\n\n**创建一个被订阅的（Up主）**\n\n```java\npublic class Up {\n\n    private String latestVideo;\n\n    private List<Follower> followers = new ArrayList<>();\n\n    public void submitVideo(String video) {\n        this.latestVideo = video;\n        notifyAllFollowers();\n    }\n\n    public void addFollower(Follower follower) {\n        followers.add(follower);\n    }\n\n    public void notifyAllFollowers() {\n        for (Follower follower : followers) {\n            follower.update(latestVideo);\n        }\n    }\n}\n```\n\n**创建一个订阅者（粉丝）**\n\n```java\npublic class Follower{\n\n    private String name;\n    private String video;\n    private Up up;\n\n    public Follower(String name,Up up) {\n        this.name = name;\n        this.up = up;\n        this.up.addFollower(this);\n    }\n\n    public void update(String video) {\n        this.video = video;\n        System.out.println(name + \" 收到up主 \" + up + \" 的最新视频 \" + video);\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        Up up = new Up();\n        Follower 张三 = new Follower(\"张三\", up);\n        Follower 李四 = new Follower(\"李四\", up);\n\n        up.submitVideo(\"第1个视频\");\n        System.out.println(\"-------------\");\n        up.submitVideo(\"第2个视频\");\n    }\n}\n```\n\n**结果**\n\n![image-20221217104623464](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104623464.png)\n\n## 21.状态模式\n\nState，类的行为是基于它的状态改变的。\n\n**定义状态接口**\n\n```java\npublic interface State {\n\n    void doAction(Context context);\n}\n```\n\n**定义一个随着状态改变而做出不同行为的Context上下文**\n\n```java\n@Data\npublic class Context {\n\n    private State state;\n\n}\n```\n\n**定义状态的实现**\n\n```java\npublic class StartState implements State {\n\n    @Override\n    public void doAction(Context context) {\n        System.out.println(\"当前是开始状态...\");\n        context.setState(this);\n    }\n}\n```\n\n```java\npublic class EndState implements State {\n    @Override\n    public void doAction(Context context) {\n        System.out.println(\"当前是结束状态...\");\n        context.setState(this);\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        Context context = new Context();\n\n        StartState startState = new StartState();\n        startState.doAction(context);\n\n        EndState endState = new EndState();\n        endState.doAction(context);\n    }\n}\n```\n\n**结果**\n\n![image-20221217104706915](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104706915.png)\n\n## 22.空对象模式\n\nNull Object，一个空对象取代 NULL 对象。\n\n**定义实体类抽象父类**\n\n```java\n@Data\npublic abstract class AbstractUser {\n\n    protected String name;\n\n    public abstract boolean isNull();\n}\n```\n\n**定义正常的存在的用户对象**\n\n```java\npublic class User extends AbstractUser{\n    public User(String name){\n        this.name = name;\n    }\n\n    @Override\n    public boolean isNull() {\n        return false;\n    }\n}\n```\n\n**空对象**\n\n```java\npublic class EmptyUser extends AbstractUser{\n\n    public EmptyUser() {\n        this.name = \"空用户对象...\";\n    }\n\n    @Override\n    public boolean isNull() {\n        return true;\n    }\n}\n```\n\n**创建一个测试用的工厂**\n\n```java\npublic class UserFactory {\n\n    private static List<String> nameList;\n\n    static {\n        nameList = ListUtil.of(\"张三\",\"李四\",\"王五\");\n    }\n\n    public static AbstractUser getUser(String name) {\n        for (String n : nameList) {\n            if(n.equalsIgnoreCase(name)){\n                return new User(name);\n            }\n        }\n        return new EmptyUser();\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        AbstractUser 张三 = UserFactory.getUser(\"张三\");\n        AbstractUser 赵六 = UserFactory.getUser(\"赵六\");\n\n        System.out.println(张三);\n        System.out.println(赵六);\n    }\n}\n```\n\n**结果**\n\n![image-20221214080526276](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214080526276.png)\n\n## 23.策略模式\n\nStrategy，一个类的行为或其算法可以在运行时更改。\n\n**定义策略的接口**\n\n```java\npublic interface Strategy {\n\n    public int doStrategy(int a,int b);\n}\n```\n\n**定义策略实现**\n\n```java\npublic class AddStrategy implements Strategy {\n\n    @Override\n    public int doStrategy(int a, int b) {\n        return a + b;\n    }\n}\n```\n\n```java\npublic class SubStrategy implements Strategy {\n    @Override\n    public int doStrategy(int a, int b) {\n        return a - b;\n    }\n}\n```\n\n**定义一个可更改策略的上下文**\n\n```java\n@Data\npublic class Context {\n\n    private Strategy strategy;\n\n    public int executeStrategy(int a,int b){\n        if(strategy != null){\n            return strategy.doStrategy(a,b);\n        }else {\n            throw new RuntimeException(\"尚未设置策略！\");\n        }\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        Context context = new Context();\n        AddStrategy addStrategy = new AddStrategy();\n        SubStrategy subStrategy = new SubStrategy();\n\n        context.setStrategy(addStrategy);\n        int i1 = context.executeStrategy(1, 2);\n        System.out.println(i1);\n\n        context.setStrategy(subStrategy);\n        int i2 = context.executeStrategy(5, 2);\n        System.out.println(i2);\n    }\n}\n```\n\n**结果**\n\n两个3\n\n## 24.模板模式\n\nTemplate，在抽象类中提前定义了某个操作的一系列流程的模板，用户只需要实现具体细节即可。\n\n**定义抽象模板父类**\n\n```java\npublic abstract class MyGame {\n\n    protected String name;\n\n    abstract void downloadGame();\n    abstract void installGame();\n    abstract void openGame();\n\n    public void playGame() {\n        downloadGame();\n        installGame();\n        openGame();\n        System.out.println(\"开始游戏:[\" + name + \"]\");\n    }\n}\n```\n\n**创建抽象父类的实现**\n\n```java\npublic class LOL extends MyGame{\n\n    public LOL(){\n        this.name = \"LOL\";\n    }\n\n    @Override\n    void downloadGame() {\n        System.out.println(\"正在下载游戏:\" + name);\n    }\n\n    @Override\n    void installGame() {\n        System.out.println(\"正在安装游戏:\" + name);\n    }\n\n    @Override\n    void openGame() {\n        System.out.println(\"正在打开游戏:\" + name);\n    }\n}\n```\n\n```java\npublic class CSGO extends MyGame{\n\n    public CSGO() {\n        this.name = \"CSGO\";\n    }\n\n    @Override\n    void downloadGame() {\n        System.out.println(\"正在下载游戏:\" + name);\n    }\n\n    @Override\n    void installGame() {\n        System.out.println(\"正在安装游戏:\" + name);\n    }\n\n    @Override\n    void openGame() {\n        System.out.println(\"正在打开游戏:\" + name);\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        LOL lol = new LOL();\n        CSGO csgo = new CSGO();\n\n        lol.playGame();\n        csgo.playGame();\n    }\n}\n```\n\n**结果**\n\n![image-20221215170923686](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221215170923686.png)\n\n## 25.访问者模式\n\nVisitor，封装一些作用于某些数据结构中的各元素的操作，它可以在不改变数据结构的前提下赋予这些元素新的操作。\n\n**定义被访问者的统一接口**\n\n```java\npublic interface Person{\n\n    public void accept(Visitor visitor);\n}\n```\n\n**定义被访问者实例**\n\n```java\n@Data\n@AllArgsConstructor\npublic class Student implements Person {\n\n    private String name;\n    private Integer rank;\n\n    @Override\n    public void accept(Visitor visitor) {\n        visitor.visit(this);\n    }\n}\n```\n\n```java\n@Data\n@AllArgsConstructor\npublic class Teacher implements Person {\n\n    private String name;\n    private Integer salary;\n\n    @Override\n    public void accept(Visitor visitor) {\n        visitor.visit(this);\n    }\n}\n```\n\n**定义访问者接口**\n\n```java\npublic interface Visitor {\n\n    public void visit(Student student);\n\n    public void visit(Teacher teacher);\n}\n```\n\n**定义访问者实例**\n\n```java\npublic class Headmaster implements Visitor {\n    @Override\n    public void visit(Student student) {\n        System.out.println(\"访问学生:\" + student.getName() + \",排名为:\" + student.getRank());\n    }\n\n    @Override\n    public void visit(Teacher teacher) {\n        System.out.println(\"访问老师:\" + teacher.getName() + \",月薪为:\" + teacher.getSalary());\n    }\n}\n```\n\n**测试**\n\n```java\npublic class Test {\n\n    @org.junit.Test\n    public void test1() {\n        Student student = new Student(\"张三\",21);\n        Teacher teacher = new Teacher(\"张雪迎\",8000);\n        Headmaster headmaster = new Headmaster();\n\n        student.accept(headmaster);\n        teacher.accept(headmaster);\n    }\n}\n```\n\n**结果**\n\n![image-20221216100457969](https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221216100457969.png)\n","slug":"Java/设计模式","published":1,"date":"2022-12-17T02:49:17.450Z","updated":"2022-12-17T02:49:14.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbrcchlb000aqkiq8khte6c3","content":"<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><p>菜鸟设计模式：</p>\n<p><a href=\"https://www.runoob.com/design-pattern/design-pattern-tutorial.html\">https://www.runoob.com/design-pattern/design-pattern-tutorial.html</a></p>\n<p>UML类图教程：</p>\n<p><a href=\"https://blog.csdn.net/weixin_57504000/article/details/124218420\">https://blog.csdn.net/weixin_57504000/article/details/124218420</a></p>\n<p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>\n<p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>\n<p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>\n<h1 id=\"一、创建型模式\"><a href=\"#一、创建型模式\" class=\"headerlink\" title=\"一、创建型模式\"></a>一、创建型模式</h1><h2 id=\"1-工厂模式\"><a href=\"#1-工厂模式\" class=\"headerlink\" title=\"1.工厂模式\"></a>1.工厂模式</h2><p>获得<strong>复杂对象</strong>实例（简单对象只需要new即可），而无须关心其具体的实现细节。</p>\n<p><strong>实现：</strong></p>\n<p>定义一个接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Phone &#123;\n\n    public String use();\n&#125;</code></pre>\n\n<p>定义实体，并继承该接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Oppo implements Phone &#123;\n\n    @Override\n    public String use() &#123;\n        return &quot;我是oppo  &quot;;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Xiaomi implements Phone &#123;\n\n    @Override\n    public String use() &#123;\n        return &quot;我是小米&quot;;\n    &#125;\n&#125;</code></pre>\n\n<p>定义工厂类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class PhoneFactory &#123;\n\n    public static class Type&#123;\n        public static final String TYPE_XIAOMI &#x3D; &quot;xiaomi&quot;;\n        public static final String TYPE_OPPO &#x3D; &quot;oppo&quot;;\n    &#125;\n\n    public Phone getPhoneByType(String type) &#123;\n        if(type.equalsIgnoreCase(Type.TYPE_XIAOMI))&#123;\n            return new Xiaomi();\n        &#125;else if(type.equalsIgnoreCase(Type.TYPE_OPPO))&#123;\n            return new Oppo();\n        &#125;\n        return null;\n    &#125;\n&#125;</code></pre>\n\n<p>使用：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    public static void main(String[] args) &#123;\n        PhoneFactory phoneFactory &#x3D; new PhoneFactory();\n        Phone xiaomi &#x3D; phoneFactory.getPhoneByType(PhoneFactory.Type.TYPE_XIAOMI);\n        System.out.println(xiaomi.use());\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214080627939.png\" alt=\"image-20221214080627939\"></p>\n<h2 id=\"2-抽象工厂模式\"><a href=\"#2-抽象工厂模式\" class=\"headerlink\" title=\"2.抽象工厂模式\"></a>2.抽象工厂模式</h2><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。</p>\n<p>定义一个抽象工厂类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class AbstractFactory &#123;\n\n    public abstract Phone getPhoneByType(String phoneType);\n\n    public abstract Color getColorByType(String phoneType);\n&#125;</code></pre>\n\n<p>具体的工厂类继承该抽象工厂类：</p>\n<p>手机工厂：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class PhoneFactory extends AbstractFactory &#123;\n\n    public static class Type&#123;\n        public static final String TYPE_XIAOMI &#x3D; &quot;xiaomi&quot;;\n        public static final String TYPE_OPPO &#x3D; &quot;oppo&quot;;\n    &#125;\n\n    public Phone getPhoneByType(String type) &#123;\n        if(type.equalsIgnoreCase(Type.TYPE_XIAOMI))&#123;\n            return new Xiaomi();\n        &#125;else if(type.equalsIgnoreCase(Type.TYPE_OPPO))&#123;\n            return new Oppo();\n        &#125;\n        return null;\n    &#125;\n\n    @Override\n    public Color getColorByType(String phoneType) &#123;\n        return null;\n    &#125;\n&#125;</code></pre>\n\n<p>颜色工厂：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ColorFactory extends AbstractFactory &#123;\n\n    public static class TYPE&#123;\n        public static final String TYPE_RED &#x3D; &quot;red&quot;;\n\n        public static final String TYPE_YELLOW &#x3D; &quot;yellow&quot;;\n    &#125;\n\n    @Override\n    public Phone getPhoneByType(String phoneType) &#123;\n\n        return null;\n    &#125;\n\n    @Override\n    public Color getColorByType(String phoneType) &#123;\n        if (TYPE.TYPE_RED.equalsIgnoreCase(phoneType)) &#123;\n            return new Red();\n        &#125;else if (TYPE.TYPE_YELLOW.equalsIgnoreCase(phoneType))&#123;\n            return new Yellow();\n        &#125;\n        return null;\n    &#125;\n&#125;</code></pre>\n\n<p>定义一个超级工厂类，用于获得具体的工厂：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RootFactory &#123;\n\n    public static class TYPE&#123;\n        public static final String TYPE_PHONE &#x3D; &quot;phone&quot;;\n        public static final String TYPE_COLOR &#x3D; &quot;color&quot;;\n    &#125;\n\n    public static AbstractFactory getFactoryByType(String factoryType) &#123;\n        if (TYPE.TYPE_PHONE.equalsIgnoreCase(factoryType))&#123;\n            return new PhoneFactory();\n        &#125;else if(TYPE.TYPE_COLOR.equals(factoryType))&#123;\n            return new ColorFactory();\n        &#125;\n        return null;\n    &#125;\n&#125;</code></pre>\n\n<p>使用：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    &#x2F;&#x2F;获得工厂\n    AbstractFactory factoryByType &#x3D; RootFactory.getFactoryByType(RootFactory.TYPE.TYPE_COLOR);\n    &#x2F;&#x2F;从工厂获得对象\n    Color colorByType &#x3D; factoryByType.getColorByType(ColorFactory.TYPE.TYPE_RED);\n    System.out.println(colorByType.show());\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214080715116.png\" alt=\"image-20221214080715116\"></p>\n<h2 id=\"3-构造器模式\"><a href=\"#3-构造器模式\" class=\"headerlink\" title=\"3.构造器模式\"></a>3.构造器模式</h2><p>参考：<a href=\"https://www.dandelioncloud.cn/article/details/1523275053169147905\">https://www.dandelioncloud.cn/article/details/1523275053169147905</a></p>\n<p>传统的构造对象方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Person person &#x3D; new Person();\nperson.setId(1);\nperson.setName(&quot;张小毛&quot;);\nperson.setAge(22);\nperson.setSex(&quot;男&quot;);\nperson.setPhone(&quot;19999999999&quot;);\nperson.setAddress(&quot;beijing&quot;);\nperson.setDesc(&quot;JavaBeans模式&quot;);</code></pre>\n\n<ul>\n<li>优点：易于阅读，并且可以只对有用的成员变量赋值</li>\n<li>缺点：成员变量不可以是 final 类型，失去了不可变对象的很多好处，对象状态不连续，你必须调用7次setter方法才能得到一个具备7个属性值得变量，在这期间用户可能拿到不完整状态的对象。如果有N个属性，岂不是要<code>person.setXXX</code>调用N次？此种方式不优雅</li>\n</ul>\n<p>构造器模式演示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">PrivateKeyDecryptParam param &#x3D; new PrivateKeyDecryptParam.Builder()\n                                              .uAppId(uAppId)\n                                              .containerId(containerId)\n                                              .cipher(cipher)\n                                              .signFlag(signFlag)\n                                              .build();</code></pre>\n\n<p>示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@ToString\npublic class User &#123;\n\n    private String name;\n\n    private Integer age;\n\n    private Integer sex;\n\n    private User(Builder builder)&#123;\n        this.name &#x3D; builder.name;\n        this.age &#x3D; builder.age;\n        this.sex &#x3D; builder.sex;\n    &#125;\n\n    public static class Builder &#123;\n\n        &#x2F;&#x2F;必要参数\n        private final String name;\n\n        &#x2F;&#x2F;可选参数\n        private Integer age;\n        private Integer sex;\n\n        public Builder(String name)&#123;\n            this.name &#x3D; name;\n        &#125;\n\n        public Builder age(Integer age) &#123;\n            this.age &#x3D; age;\n            return this;\n        &#125;\n\n        public Builder sex(Integer sex) &#123;\n            this.sex &#x3D; sex;\n            return this;\n        &#125;\n\n        public User build() &#123;\n            return new User(this);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>使用：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">User cleWm &#x3D; new User.Builder(&quot;CleWm&quot;)\n        .age(21)\n        .sex(0)\n        .build();</code></pre>\n\n<p>要点：</p>\n<ul>\n<li>外部类的构造函数私有，且参数为静态内部类；</li>\n<li>静态内部类拥有外部类相同的属；</li>\n<li>为每一个属性，写一个方法，返回的是Builer；</li>\n<li>最后一个方法是build方法，用于构建一个外部类；</li>\n</ul>\n<p>优点：降低复杂性，优雅</p>\n<p>缺点：代码量提高了</p>\n<h2 id=\"4-单例模式\"><a href=\"#4-单例模式\" class=\"headerlink\" title=\"4.单例模式\"></a>4.单例模式</h2><p>一个类确保只有单个对象被创建</p>\n<p><strong>饿汉式：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HungrySingleton &#123;\n\n    private static HungrySingleton instance &#x3D; new HungrySingleton();\n\n    private HungrySingleton()&#123;&#125;\n\n    public static HungrySingleton getInstance()&#123;\n        return instance;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>懒汉式：</strong></p>\n<p>双重检查锁：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LazySingleton &#123;\n\n    private static LazySingleton instance;\n\n    private LazySingleton() &#123;&#125;\n\n    public static LazySingleton getInstance() &#123;\n        if(instance &#x3D;&#x3D; null)&#123;\n            synchronized (LazySingleton.class)&#123;\n                if (instance &#x3D;&#x3D; null)&#123;\n                    instance &#x3D; new LazySingleton();\n                &#125;\n            &#125;\n        &#125;\n        return instance;\n    &#125;\n&#125;</code></pre>\n\n<p>静态内部类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LazySingleton2 &#123;\n\n    private LazySingleton2()&#123;&#125;\n\n    &#x2F;**\n     * 静态内部类和非静态内部类都是在被调用的时候才会进行加载，和外部类没有关系，从而实现了延迟加载\n     *&#x2F;\n    private static class SingletonHolder&#123;\n        private static final LazySingleton2 instance &#x3D; new LazySingleton2();\n    &#125;\n\n    public static LazySingleton2 getInstance() &#123;\n        return SingletonHolder.instance;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        LazySingleton instance1 &#x3D; LazySingleton.getInstance();\n        LazySingleton instance2 &#x3D; LazySingleton.getInstance();\n        System.out.println(instance1 &#x3D;&#x3D; instance2);\n\n        LazySingleton2 instance3 &#x3D; LazySingleton2.getInstance();\n        LazySingleton2 instance4 &#x3D; LazySingleton2.getInstance();\n        System.out.println(instance3 &#x3D;&#x3D; instance4);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214081317951.png\" alt=\"image-20221214081317951\"></p>\n<h2 id=\"5-原型模式\"><a href=\"#5-原型模式\" class=\"headerlink\" title=\"5.原型模式\"></a>5.原型模式</h2><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。一般会配合工厂模式一起使用。</p>\n<p>与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p>\n<p>定义一个抽象父类，并实现Cloneable接口：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Cloneable是一个标识接口，clone方法是Object提供的方法，\n * 只有实现了Cloneable接口，同时重写clone方法才不会报错\n *&#x2F;\n@Getter\n@ToString\npublic abstract class Book implements Cloneable&#123;\n\n    protected String name;\n\n    protected Integer type;\n\n    @Override\n    protected Book clone()&#123;\n        Object clone &#x3D; null;\n        try&#123;\n            clone &#x3D; super.clone();\n        &#125;catch (CloneNotSupportedException e)&#123;\n            e.printStackTrace();\n        &#125;\n        return (Book)clone;\n    &#125;\n&#125;</code></pre>\n\n<p>定义具体实现类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BookOne extends Book&#123;\n\n    BookOne() &#123;\n        name &#x3D; &quot;《第一本书》&quot;;\n        type &#x3D; 1;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BookTwo extends Book&#123;\n\n    BookTwo() &#123;\n        name &#x3D; &quot;《第二本书》&quot;;\n        type &#x3D; 2;\n    &#125;\n&#125;</code></pre>\n\n<p>定义一个Factory来获得克隆对象：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BookFactory &#123;\n\n    &#x2F;**\n     * 用于存储我们的原始对象，克隆对象以此为基础进行复制\n     *&#x2F;\n    private static final Map&lt;Integer,Book&gt; cache;\n\n    static &#123;\n        cache &#x3D; new HashMap&lt;&gt;();\n        cache.put(Type.TYPE_ONE,new BookOne());\n        cache.put(Type.TYPE_TWO,new BookTwo());\n    &#125;\n\n    public static class Type&#123;\n        public static final Integer TYPE_ONE &#x3D; 1;\n        public static final Integer TYPE_TWO &#x3D; 2;\n    &#125;\n\n    &#x2F;**\n     * 返回的是克隆对象\n     * @param type\n     * @return\n     *&#x2F;\n    public static Book getBookByType(Integer type) &#123;\n        return cache.get(type).clone();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n    @org.junit.Test\n    public void test1() &#123;\n        Book book1 &#x3D; BookFactory.getBookByType(BookFactory.Type.TYPE_ONE);\n        Book book2 &#x3D; BookFactory.getBookByType(BookFactory.Type.TYPE_ONE);\n        System.out.println(book1 &#x3D;&#x3D; book2);\n        System.out.println(book1);\n        System.out.println(book2);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214081502987.png\" alt=\"image-20221214081502987\"></p>\n<h1 id=\"二、结构型模式\"><a href=\"#二、结构型模式\" class=\"headerlink\" title=\"二、结构型模式\"></a>二、结构型模式</h1><h2 id=\"6-适配器模式\"><a href=\"#6-适配器模式\" class=\"headerlink\" title=\"6.适配器模式\"></a>6.适配器模式</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁</p>\n<p>比如220V的电源，使用电源适配器给手机提供12V的电压充电。</p>\n<p><strong>定义一个目标接口，该接口属于一般情况</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Target &#123;\n\n    public void get();\n&#125;</code></pre>\n\n<p><strong>定义一个不兼容的，需要被适配的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SpecialStatus &#123;\n\n    public void specialGet() &#123;\n        System.out.println(&quot;这是特殊情况的get实现&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义适配器，实现Target接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Adapter implements Target &#123;\n\n    private SpecialStatus specialStatus;\n\n    public Adapter(SpecialStatus specialStatus)&#123;\n        this.specialStatus &#x3D; specialStatus;\n    &#125;\n\n    @Override\n    public void get() &#123;\n        specialStatus.specialGet();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        SpecialStatus specialStatus &#x3D; new SpecialStatus();\n        Adapter adapter &#x3D; new Adapter(specialStatus);\n        adapter.get();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217093732742.png\" alt=\"image-20221217093732742\"></p>\n<h2 id=\"7-桥接模式\"><a href=\"#7-桥接模式\" class=\"headerlink\" title=\"7.桥接模式\"></a>7.桥接模式</h2><p>Bridge，它的作用是将抽象部分和它的实现部分分离，从而可以让它们独立地变化。</p>\n<p>就好比有一个武器槽，放不同的武器进去就是不同的功能。s</p>\n<p><strong>先定义抽象部分，比如武器槽</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class WeaponSlot &#123;\n\n    protected Weapon weapon;\n\n    abstract void shoot();\n\n    public void setWeapon(Weapon weapon)&#123;\n        this.weapon &#x3D; weapon;\n    &#125;\n\n    public abstract void opreation();\n&#125;</code></pre>\n\n<p><strong>定义实现的接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Weapon &#123;\n\n    void shoot();\n&#125;</code></pre>\n\n<p><strong>定义抽象部分的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LeftSlot extends WeaponSlot&#123;\n\n    @Override\n    void shoot() &#123;\n        weapon.shoot();\n    &#125;\n\n    @Override\n    public void opreation() &#123;\n        weapon.shoot();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义实现接口的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AK47 implements Weapon &#123;\n    @Override\n    public void shoot() &#123;\n        System.out.println(&quot;AK开枪了！&quot;);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class M4 implements Weapon &#123;\n    @Override\n    public void shoot() &#123;\n        System.out.println(&quot;m4开枪！&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n\n        M4 m4 &#x3D; new M4();\n        AK47 ak47 &#x3D; new AK47();\n\n        LeftSlot leftSlot &#x3D; new LeftSlot();\n        leftSlot.setWeapon(m4);\n        leftSlot.opreation();\n\n        leftSlot.setWeapon(ak47);\n        leftSlot.opreation();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103542571.png\" alt=\"image-20221217103542571\"></p>\n<h2 id=\"8-过滤器模式\"><a href=\"#8-过滤器模式\" class=\"headerlink\" title=\"8.过滤器模式\"></a>8.过滤器模式</h2><p>Filter ，它的作用是过滤序列中的特定元素。</p>\n<p><strong>定义一个过滤器的接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Filter &lt;T&gt;&#123;\n\n    List&lt;T&gt; doFilter(List&lt;T&gt; lists);\n&#125;</code></pre>\n\n<p><strong>定义要过滤的实体类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class User &#123;\n\n    private String name;\n\n    private Integer age;\n\n    private Integer sex;\n&#125;</code></pre>\n\n<p><strong>定义过滤器的具体实现</strong></p>\n<p>年龄过滤器：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AgeFilter implements Filter&lt;User&gt; &#123;\n\n    @Override\n    public List&lt;User&gt; doFilter(List&lt;User&gt; lists) &#123;\n        ArrayList&lt;User&gt; res &#x3D; new ArrayList&lt;&gt;();\n        for (User user : lists) &#123;\n            if(user.getAge() &gt;&#x3D; 18)&#123;\n                res.add(user);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;</code></pre>\n\n<p>性别过滤器：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SexFilter implements Filter&lt;User&gt; &#123;\n    @Override\n    public List&lt;User&gt; doFilter(List&lt;User&gt; lists) &#123;\n        ArrayList&lt;User&gt; res &#x3D; new ArrayList&lt;&gt;();\n        for (User user : lists) &#123;\n            if (user.getSex() &#x3D;&#x3D; 1)&#123;\n                res.add(user);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        AgeFilter ageFilter &#x3D; new AgeFilter();\n        SexFilter sexFilter &#x3D; new SexFilter();\n        ArrayList&lt;User&gt; userArrayList &#x3D; new ArrayList&lt;&gt;();\n        for (int i &#x3D; 1; i &lt; 10; i++) &#123;\n            User user &#x3D; new User();\n            user.setAge(RandomUtil.randomInt(10,35));\n            user.setName(&quot;张&quot; + i);\n            user.setSex(RandomUtil.randomEle(new Integer[]&#123;0,1&#125;));\n            userArrayList.add(user);\n        &#125;\n        List&lt;User&gt; users1 &#x3D; ageFilter.doFilter(userArrayList);\n        System.out.println(&quot;第一次过滤后的结果：&quot; + users1);\n\n        List&lt;User&gt; users2 &#x3D; sexFilter.doFilter(users1);\n        System.out.println(&quot;第二次过滤后的结果：&quot; + users2);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103713100.png\" alt=\"image-20221217103713100\"></p>\n<h2 id=\"9-组合模式\"><a href=\"#9-组合模式\" class=\"headerlink\" title=\"9.组合模式\"></a>9.组合模式</h2><p>Composite，是用于把一组相似的对象当作一个单一的对象。组合模式依据<strong>树形结构</strong>来组合对象，用来表示部分以及整体层次。</p>\n<p>例如：在可视化开发中，容器和按钮等组件之间的关系。又或者是公司、学校的组织架构等。</p>\n<p>以学校为例：</p>\n<p><strong>定义一个员工类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@ToString(exclude &#x3D; &quot;subordinates&quot;)\npublic class Employee &#123;\n\n    private String name;\n\n    private String dept;\n\n    private Integer salary;\n\n    private List&lt;Employee&gt; subordinates;\n\n    public Employee(String name, String dept, Integer salary) &#123;\n        this.name &#x3D; name;\n        this.dept &#x3D; dept;\n        this.salary &#x3D; salary;\n        this.subordinates &#x3D; new ArrayList&lt;&gt;();\n    &#125;\n\n    public void addSubordinate(Employee subordinate) &#123;\n        subordinates.add(subordinate);\n    &#125;\n\n    public void removeSubordinate(Employee subordinate) &#123;\n        subordinates.remove(subordinate);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Employee 张昌平 &#x3D; new Employee(&quot;张昌平&quot;, &quot;校长&quot;, 30000);\n\n        Employee 张雪迎 &#x3D; new Employee(&quot;张雪迎&quot;, &quot;7班班主任&quot;, 10000);\n        Employee 刘静 &#x3D; new Employee(&quot;刘静&quot;, &quot;8班班主任&quot;, 9000);\n\n        Employee 胡伟明 &#x3D; new Employee(&quot;胡伟明&quot;, &quot;7班学生&quot;, 0);\n        Employee 李冠杰 &#x3D; new Employee(&quot;李冠杰&quot;, &quot;7班学生&quot;, 0);\n        Employee 田继睿 &#x3D; new Employee(&quot;田继睿&quot;, &quot;7班学生&quot;, 0);\n        Employee 冯毅力 &#x3D; new Employee(&quot;冯毅力&quot;, &quot;7班学生&quot;, 0);\n\n        Employee 冯跟源 &#x3D; new Employee(&quot;冯跟源&quot;, &quot;8班学生&quot;, 0);\n        Employee 施冰清 &#x3D; new Employee(&quot;施冰清&quot;, &quot;8班学生&quot;, 0);\n\n\n\n        张昌平.addSubordinate(张雪迎);\n        张昌平.addSubordinate(刘静);\n\n\n        张雪迎.addSubordinate(胡伟明);\n        张雪迎.addSubordinate(李冠杰);\n        张雪迎.addSubordinate(田继睿);\n        张雪迎.addSubordinate(冯毅力);\n\n        刘静.addSubordinate(冯跟源);\n        刘静.addSubordinate(施冰清);\n\n        &#x2F;**\n         * 二叉树如下:\n         *                      张昌平\n         *                    &#x2F;      \\\n         *                   &#x2F;        \\\n         *                张雪迎        刘静\n         *                &#x2F; | | \\      &#x2F; \\\n         *               &#x2F;  | |  \\    &#x2F;   \\\n         *             胡   李 冯 田   冯   施\n         *&#x2F;\n        System.out.println(张昌平);\n        for (Employee sub1 : 张昌平.getSubordinates())&#123;\n            System.out.println(sub1);\n            for (Employee sub2 : sub1.getSubordinates())&#123;\n                System.out.println(sub2);\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103845510.png\" alt=\"image-20221217103845510\"></p>\n<h2 id=\"10-装饰器模式\"><a href=\"#10-装饰器模式\" class=\"headerlink\" title=\"10.装饰器模式\"></a>10.装饰器模式</h2><p>Decorator，允许向一个现有的对象添加新的功能，同时又不改变其结构。</p>\n<p><strong>定义一个接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Person &#123;\n\n    void eat();\n&#125;</code></pre>\n\n<p><strong>定义一个接口的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CleWm implements Person &#123;\n    @Override\n    public void eat() &#123;\n        System.out.println(&quot;吃了一碗饭...&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义一个装饰器，实现接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Decorator implements Person &#123;\n\n    private Person person;\n\n    @Override\n    public void eat() &#123;\n        person.eat();\n        System.out.println(&quot;person又吃了一碗...&quot;);\n    &#125;\n\n    public void setPerson(Person person) &#123;\n        this.person &#x3D; person;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        CleWm cleWm &#x3D; new CleWm();\n        Decorator decorator &#x3D; new Decorator();\n        decorator.setPerson(cleWm);\n        decorator.eat();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103941837.png\" alt=\"image-20221217103941837\"></p>\n<h2 id=\"11-外观模式\"><a href=\"#11-外观模式\" class=\"headerlink\" title=\"11.外观模式\"></a>11.外观模式</h2><p>Facade，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 外观类\npublic class Facade &#123;\n   private Subsystem1 subsystem1;\n   private Subsystem2 subsystem2;\n\n   public Facade() &#123;\n      subsystem1 &#x3D; new Subsystem1();\n      subsystem2 &#x3D; new Subsystem2();\n   &#125;\n\n   &#x2F;&#x2F; 提供一个简化的接口，用于客户端访问子系统\n   public void operation() &#123;\n      subsystem1.operation1();\n      subsystem2.operation1();\n   &#125;\n&#125;\n\n&#x2F;&#x2F; 子系统1\npublic class Subsystem1 &#123;\n   public void operation1() &#123;\n      &#x2F;&#x2F; 实现子系统1的相关操作\n   &#125;\n&#125;\n\n&#x2F;&#x2F; 子系统2\npublic class Subsystem2 &#123;\n   public void operation1() &#123;\n      &#x2F;&#x2F; 实现子系统2的相关操作\n   &#125;\n&#125;</code></pre>\n\n<h2 id=\"12-享元模式\"><a href=\"#12-享元模式\" class=\"headerlink\" title=\"12.享元模式\"></a>12.享元模式</h2><p>Flyweight，主要用于减少创建对象的数量，以减少内存占用和提高性能。</p>\n<p>说白了就是在工厂模式的工厂类中，缓存一个Map，每次创建对象的时候就进行一个判断，若指定对象存在，则直接从map中取出并返回，若没有，则新建，然后缓存进入Map当中。</p>\n<p><strong>创建一个颜色</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Color &#123;\n\n    public String colorName;\n\n    public Color(String colorName)&#123;\n        this.colorName &#x3D; colorName;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>创建一个颜色工厂</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ColorFactory &#123;\n\n    private Map&lt;String, Color&gt; map &#x3D; new HashMap&lt;&gt;();\n\n    public Color getColor(String colorName) &#123;\n        return Optional.ofNullable(map.get(colorName)).orElseGet(()-&gt;&#123;\n            Color color &#x3D; new Color(colorName);\n            map.put(colorName,color);\n            return color;\n        &#125;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        ColorFactory colorFactory &#x3D; new ColorFactory();\n        Color red1 &#x3D; colorFactory.getColor(&quot;red&quot;);\n        Color red2 &#x3D; colorFactory.getColor(&quot;red&quot;);\n        Color red3 &#x3D; colorFactory.getColor(&quot;blue&quot;);\n        System.out.println(red1 &#x3D;&#x3D; red2);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104139185.png\" alt=\"image-20221217104139185\"></p>\n<h2 id=\"13-代理模式\"><a href=\"#13-代理模式\" class=\"headerlink\" title=\"13.代理模式\"></a>13.代理模式</h2><p>Proxy，它通过引入一个新的类来控制对另一个对象的访问。这有助于控制对原始对象的访问，并且可以在访问原始对象时执行其他附加操作。</p>\n<p><strong>定义一个接口，包含被代理的方法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Image &#123;\n\n    public void show();\n&#125;</code></pre>\n\n<p><strong>定义原始类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Realimage implements Image &#123;\n\n    private String path;\n\n    public Realimage(String path) &#123;\n        this.path &#x3D; path;\n        loadFromDisk();\n    &#125;\n\n    @Override\n    public void show() &#123;\n        System.out.println(&quot;展示&quot; + path + &quot;的图片&quot;);\n    &#125;\n\n    void loadFromDisk() &#123;\n        System.out.println(&quot;正在从磁盘中加载图片:&quot; + path);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义代理对象</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ProxyImage implements Image &#123;\n\n    private String path;\n\n    private Realimage realimage;\n\n    public ProxyImage(String path) &#123;\n        this.path &#x3D; path;\n    &#125;\n\n    @Override\n    public void show() &#123;\n        if(realimage &#x3D;&#x3D; null)&#123;\n            realimage &#x3D; new Realimage(path);\n        &#125;\n        realimage.show();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        ProxyImage proxyImage &#x3D; new ProxyImage(&quot;C:\\\\test.jpg&quot;);\n        proxyImage.show();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104158303.png\" alt=\"image-20221217104158303\"></p>\n<h1 id=\"三、行为型模式\"><a href=\"#三、行为型模式\" class=\"headerlink\" title=\"三、行为型模式\"></a>三、行为型模式</h1><h2 id=\"14-责任链模式\"><a href=\"#14-责任链模式\" class=\"headerlink\" title=\"14.责任链模式\"></a>14.责任链模式</h2><p>Chain of Responsibility，为请求创建了一个接收者对象的链。</p>\n<p>通常每个接收者都包含对另一个接收者的引用。<strong>如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者</strong>，依此类推。</p>\n<p><strong>定义一个实体</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@AllArgsConstructor\npublic class Package &#123;\n\n    private String loc;\n&#125;</code></pre>\n\n<p><strong>定义一个处理器的抽象父类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class PackageHandler &#123;\n\n    private PackageHandler next;\n\n    public void next(PackageHandler next)&#123;\n        this.next &#x3D; next;\n    &#125;\n\n    public void handler(Package p)&#123;\n        if(next !&#x3D; null)&#123;\n            next.handler(p);\n        &#125;else &#123;\n            System.out.println(&quot;接收到一个未知地点的包裹....&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义处理器的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class KunmingPackageHandler extends PackageHandler&#123;\n    @Override\n    public void handler(Package p) &#123;\n        if(&quot;昆明&quot;.equals(p.getLoc()))&#123;\n            System.out.println(&quot;处理了一个昆明的包裹...[&quot; + this + &quot;]&quot;);\n            return;\n        &#125;else &#123;\n            super.handler(p);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TianJinPackageHandler extends PackageHandler&#123;\n\n    @Override\n    public void handler(Package p) &#123;\n        if(&quot;天津&quot;.equals(p.getLoc()))&#123;\n            System.out.println(&quot;处理了一个天津的包裹...[&quot; + this + &quot;]&quot;);\n            return;\n        &#125;else &#123;\n            super.handler(p);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        KunmingPackageHandler kunmingPackageHandler &#x3D; new KunmingPackageHandler();\n        TianJinPackageHandler tianJinPackageHandler &#x3D; new TianJinPackageHandler();\n\n        &#x2F;&#x2F; |kunmingPackageHandler| ------ |tianJinPackageHandler| ------ null\n        kunmingPackageHandler.next(tianJinPackageHandler);\n\n\n        Package package1 &#x3D; new Package(&quot;天津&quot;);\n        Package package2 &#x3D; new Package(&quot;昆明&quot;);\n        Package package3 &#x3D; new Package(&quot;四川&quot;);\n\n        List&lt;Package&gt; packageList &#x3D; ListUtil.of(package1, package2, package3);\n        for (Package aPackage : packageList) &#123;\n            kunmingPackageHandler.handler(aPackage);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104231704.png\" alt=\"image-20221217104231704\"></p>\n<h2 id=\"15-命令模式\"><a href=\"#15-命令模式\" class=\"headerlink\" title=\"15.命令模式\"></a>15.命令模式</h2><p>Command，<strong>命令模式允许请求的一方和接收的一方独立开来</strong>，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221211094616223.png\" alt=\"image-20221211094616223\"></p>\n<p>简单理解就是，封装一条命令，为该命令设置一个接收者，然后将该命令set进一个调用者对象（Invoker）中，最后调用Invoker的runCommand方法来执行命令。</p>\n<p><strong>创建命令接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Command &#123;\n\n    void run();\n&#125;</code></pre>\n\n<p><strong>创建接收者(可以理解为被隐藏的具体功能实现的部分)</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Receiver &#123;\n\n    private Integer stock &#x3D; 100;\n\n    &#x2F;**\n     * 接收者的增加库存接口，命令调用者无须关心这些接口。\n     *&#x2F;\n    public void increase() &#123;\n        stock++;\n        System.out.println(&quot;[库存剩余]:&quot; + stock);\n    &#125;\n\n    &#x2F;**\n     * 接收者的减少库存接口，命令调用者无须关心这些接口。\n     *&#x2F;\n    public void decrease() &#123;\n        stock--;\n        System.out.println(&quot;[库存剩余]:&quot; + stock);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>创建命令实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AddStockCommand implements Command &#123;\n\n    private Receiver receiver;\n\n    public AddStockCommand(Receiver receiver) &#123;\n        this.receiver &#x3D; receiver;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        receiver.increase();\n        System.out.println(&quot;添加了1个库存...&quot;);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SubStockCommand implements Command &#123;\n\n    private Receiver receiver;\n\n    public SubStockCommand(Receiver receiver)&#123;\n        this.receiver &#x3D; receiver;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        receiver.decrease();\n        System.out.println(&quot;减少了1个库存...&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>创建调用者</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Invoker&#123;\n\n    &#x2F;&#x2F; 这里也可用一个List来存储命令，在调用时使用for循环命令依次执行。\n    private Command command;\n\n    public Invoker(Command command)&#123;\n        this.command &#x3D; command;\n    &#125;\n\n    public void invokeCommand() &#123;\n        if(command !&#x3D; null)&#123;\n            command.run();\n            System.out.println(&quot;命令执行完毕...&quot;);\n        &#125;else &#123;\n            System.out.println(&quot;未设置命令！&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        &#x2F;&#x2F; 创建一个接收者\n        Receiver receiver &#x3D; new Receiver();\n\n        &#x2F;&#x2F; 库存增加命令\n        AddStockCommand addStockCommand &#x3D; new AddStockCommand(receiver);\n        &#x2F;&#x2F; 库存减少命令\n        SubStockCommand subStockCommand &#x3D; new SubStockCommand(receiver);\n\n        &#x2F;&#x2F; 创建一个调用者\n        Invoker invoker1 &#x3D; new Invoker(addStockCommand);\n        &#x2F;&#x2F; 让调用者执行命令。\n        invoker1.invokeCommand();\n\n        &#x2F;&#x2F; 创建一个调用者\n        Invoker invoker2 &#x3D; new Invoker(subStockCommand);\n        &#x2F;&#x2F; 让调用者执行命令。\n        invoker2.invokeCommand();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104253518.png\" alt=\"image-20221217104253518\"></p>\n<h2 id=\"16-解释器模式\"><a href=\"#16-解释器模式\" class=\"headerlink\" title=\"16.解释器模式\"></a>16.解释器模式</h2><p>Interpreter，它允许你定义一个语言的文法，并且基于该文法解释语言中的句子。</p>\n<p><strong>定义表达式接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Expression &#123;\n\n    boolean interpret(String content);\n&#125;</code></pre>\n\n<p><strong>定义表达式</strong></p>\n<p><strong>关键词表达式，若内容中包含指定data内容，则为true</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class KeyWordExpression implements Expression &#123;\n\n    private String data;\n\n    public KeyWordExpression(String data)&#123;\n        this.data &#x3D; data;\n    &#125;\n\n\n    @Override\n    public boolean interpret(String content) &#123;\n        if (data !&#x3D; null)&#123;\n            return content.contains(data);\n        &#125;\n        else &#123;\n            throw new RuntimeException(&quot;未设置表达式data内容&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>或表达式</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class OrExpression implements Expression &#123;\n\n    private Expression exp1;\n    private Expression exp2;\n\n    public OrExpression(Expression exp1,Expression exp2) &#123;\n        this.exp1 &#x3D; exp1;\n        this.exp2 &#x3D; exp2;\n    &#125;\n\n    @Override\n    public boolean interpret(String content) &#123;\n        return exp1.interpret(content) || exp2.interpret(content);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>与表达式</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AndExpression implements Expression &#123;\n\n    private Expression exp1;\n    private Expression exp2;\n\n    public AndExpression(Expression exp1, Expression exp2) &#123;\n        this.exp1 &#x3D; exp1;\n        this.exp2 &#x3D; exp2;\n    &#125;\n\n    @Override\n    public boolean interpret(String content) &#123;\n        return exp1.interpret(content) &amp;&amp; exp2.interpret(content);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        KeyWordExpression exp1 &#x3D; new KeyWordExpression(&quot;CleWm&quot;);\n        boolean res1 &#x3D; exp1.interpret(&quot;I am CleWm&quot;);\n\n        KeyWordExpression exp2 &#x3D; new KeyWordExpression(&quot;CleWm&quot;);\n        KeyWordExpression exp3 &#x3D; new KeyWordExpression(&quot;clewm&quot;);\n\n        OrExpression exp4 &#x3D; new OrExpression(exp2, exp3);\n        boolean res2 &#x3D; exp4.interpret(&quot;CleWm&quot;);\n        AndExpression exp5 &#x3D; new AndExpression(exp2, exp3);\n        boolean res3 &#x3D; exp5.interpret(&quot;CleWm&quot;);\n        System.out.println(res1);\n        System.out.println(res2);\n        System.out.println(res3);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104357944.png\" alt=\"image-20221217104357944\"></p>\n<h2 id=\"17-迭代器模式\"><a href=\"#17-迭代器模式\" class=\"headerlink\" title=\"17.迭代器模式\"></a>17.迭代器模式</h2><p>Iterator，这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p>\n<p><strong>创建迭代器接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Container &#123;\n\n    MyIterator getIterator();\n&#125;</code></pre>\n\n<p><strong>创建容器接口，该接口用于使得容器能够返回一个迭代器</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Container &#123;\n\n    MyIterator getIterator();\n&#125;</code></pre>\n\n<p><strong>创建容器的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class PersonRepository implements Container &#123;\n\n    private static final List&lt;String&gt; personList;\n    private int index;\n\n    static &#123;\n        personList &#x3D; ListUtil.of(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;赵六&quot;);\n    &#125;\n\n    @Override\n    public MyIterator getIterator() &#123;\n        index &#x3D; 0;\n        return new PersonIterator();\n    &#125;\n\n    private class PersonIterator implements MyIterator&lt;String&gt;&#123;\n\n        @Override\n        public boolean hasNext() &#123;\n            return personList.size() &gt; 0 &amp;&amp; index &lt; personList.size();\n        &#125;\n\n        @Override\n        public String next() &#123;\n            return personList.get(index++);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1()&#123;\n        PersonRepository personRepository &#x3D; new PersonRepository();\n        MyIterator iterator &#x3D; personRepository.getIterator();\n        while (iterator.hasNext())&#123;\n            System.out.println(iterator.next());\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104416848.png\" alt=\"image-20221217104416848\"></p>\n<h2 id=\"18-中介者模式\"><a href=\"#18-中介者模式\" class=\"headerlink\" title=\"18.中介者模式\"></a>18.中介者模式</h2><p>Mediator，这种模式提供了一个中介类，该类通常处理不同类之间的通信。</p>\n<p>聊天室为例</p>\n<p><strong>定义用户</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class User &#123;\n\n    private String name;\n    private ChatRoom chatRoom;\n\n    public User(String name)&#123;\n        this.name &#x3D; name;\n    &#125;\n\n    public void sendMessage(String content) &#123;\n        System.out.println(name + &quot; 发送一条消息:&quot; + content);\n        Message message &#x3D; new Message(name, content);\n        if(chatRoom &#x3D;&#x3D; null)&#123;\n            throw new RuntimeException(&quot;未加入任何聊天室&quot;);\n        &#125;\n        chatRoom.send(message);\n    &#125;\n\n    public void receiveMessage(Message message) &#123;\n        System.out.println(name + &quot; 收到一条消息: &quot; + message);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义消息</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@AllArgsConstructor\npublic class Message &#123;\n\n    private String from;\n    private String content;\n&#125;</code></pre>\n\n<p><strong>定义聊天室</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ChatRoom &#123;\n\n    private List&lt;User&gt; userList &#x3D; new ArrayList&lt;&gt;();\n\n    public void send(Message message)&#123;\n        for (User user : userList)&#123;\n            if(message.getFrom().equals(user.getName())) continue;\n            user.receiveMessage(message);\n        &#125;\n    &#125;\n\n    public void register(User user) &#123;\n        user.setChatRoom(this);\n        userList.add(user);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        ChatRoom chatRoom &#x3D; new ChatRoom();\n\n        User 张三 &#x3D; new User(&quot;张三&quot;);\n        User 李四 &#x3D; new User(&quot;李四&quot;);\n        User 王五 &#x3D; new User(&quot;王五&quot;);\n        chatRoom.register(张三);\n        chatRoom.register(李四);\n        chatRoom.register(王五);\n\n        张三.sendMessage(&quot;你好，我是张三&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104510201.png\" alt=\"image-20221217104510201\"></p>\n<h2 id=\"19-备忘录模式\"><a href=\"#19-备忘录模式\" class=\"headerlink\" title=\"19.备忘录模式\"></a>19.备忘录模式</h2><p>Memento，保存（备份）一个对象的某个状态，以便在适当的时候恢复对象。</p>\n<p><strong>Memento ： 备忘录对象,负责 保存好记录，即Originator内部 状态</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class Memento &#123;\n\n    private String state;\n\n    public Memento(String state)&#123;\n        this.state &#x3D; state;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>originator : 对象(需要保存 状态的对象)</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class Originator &#123;\n\n    private String state;\n\n    public Memento saveStateToMemento() &#123;\n        return new Memento(state);\n    &#125;\n\n    public void restoreStateFromMemento(Memento memento) &#123;\n        this.state &#x3D; memento.getState();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>Caretaker: 备忘录管理者,负责保存多个备忘录对象， 使用集合管理，提高效率</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MementoManager &#123;\n\n    private static List&lt;Memento&gt; mementoList;\n\n    static &#123;\n        mementoList &#x3D; new ArrayList&lt;&gt;();\n    &#125;\n\n    public static boolean add(Memento memento)&#123;\n        return mementoList.add(memento);\n    &#125;\n\n    public static Memento remove(int index) &#123;\n        return mementoList.remove(index);\n    &#125;\n\n    public static Memento get(int index)&#123;\n        return mementoList.get(index);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Originator originator &#x3D; new Originator();\n        originator.setState(&quot;初始状态&quot;);\n        boolean add &#x3D; MementoManager.add(originator.saveStateToMemento());\n        if(!add) throw new RuntimeException(&quot;保存状态失败！&quot;);\n        originator.setState(&quot;第一状态&quot;);\n        System.out.println(&quot;origin的状态为:&quot; + originator.getState());\n        originator.restoreStateFromMemento(MementoManager.get(0));\n        System.out.println(&quot;origin的状态为:&quot; + originator.getState());\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><strong><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104545873.png\" alt=\"image-20221217104545873\"></strong></p>\n<h2 id=\"20-观察者模式\"><a href=\"#20-观察者模式\" class=\"headerlink\" title=\"20.观察者模式\"></a>20.观察者模式</h2><p>Observer，当一个对象被修改时，则会自动通知依赖它的对象。</p>\n<p><strong>创建一个被订阅的（Up主）</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Up &#123;\n\n    private String latestVideo;\n\n    private List&lt;Follower&gt; followers &#x3D; new ArrayList&lt;&gt;();\n\n    public void submitVideo(String video) &#123;\n        this.latestVideo &#x3D; video;\n        notifyAllFollowers();\n    &#125;\n\n    public void addFollower(Follower follower) &#123;\n        followers.add(follower);\n    &#125;\n\n    public void notifyAllFollowers() &#123;\n        for (Follower follower : followers) &#123;\n            follower.update(latestVideo);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>创建一个订阅者（粉丝）</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Follower&#123;\n\n    private String name;\n    private String video;\n    private Up up;\n\n    public Follower(String name,Up up) &#123;\n        this.name &#x3D; name;\n        this.up &#x3D; up;\n        this.up.addFollower(this);\n    &#125;\n\n    public void update(String video) &#123;\n        this.video &#x3D; video;\n        System.out.println(name + &quot; 收到up主 &quot; + up + &quot; 的最新视频 &quot; + video);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Up up &#x3D; new Up();\n        Follower 张三 &#x3D; new Follower(&quot;张三&quot;, up);\n        Follower 李四 &#x3D; new Follower(&quot;李四&quot;, up);\n\n        up.submitVideo(&quot;第1个视频&quot;);\n        System.out.println(&quot;-------------&quot;);\n        up.submitVideo(&quot;第2个视频&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104623464.png\" alt=\"image-20221217104623464\"></p>\n<h2 id=\"21-状态模式\"><a href=\"#21-状态模式\" class=\"headerlink\" title=\"21.状态模式\"></a>21.状态模式</h2><p>State，类的行为是基于它的状态改变的。</p>\n<p><strong>定义状态接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface State &#123;\n\n    void doAction(Context context);\n&#125;</code></pre>\n\n<p><strong>定义一个随着状态改变而做出不同行为的Context上下文</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class Context &#123;\n\n    private State state;\n\n&#125;</code></pre>\n\n<p><strong>定义状态的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class StartState implements State &#123;\n\n    @Override\n    public void doAction(Context context) &#123;\n        System.out.println(&quot;当前是开始状态...&quot;);\n        context.setState(this);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class EndState implements State &#123;\n    @Override\n    public void doAction(Context context) &#123;\n        System.out.println(&quot;当前是结束状态...&quot;);\n        context.setState(this);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Context context &#x3D; new Context();\n\n        StartState startState &#x3D; new StartState();\n        startState.doAction(context);\n\n        EndState endState &#x3D; new EndState();\n        endState.doAction(context);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104706915.png\" alt=\"image-20221217104706915\"></p>\n<h2 id=\"22-空对象模式\"><a href=\"#22-空对象模式\" class=\"headerlink\" title=\"22.空对象模式\"></a>22.空对象模式</h2><p>Null Object，一个空对象取代 NULL 对象。</p>\n<p><strong>定义实体类抽象父类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic abstract class AbstractUser &#123;\n\n    protected String name;\n\n    public abstract boolean isNull();\n&#125;</code></pre>\n\n<p><strong>定义正常的存在的用户对象</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class User extends AbstractUser&#123;\n    public User(String name)&#123;\n        this.name &#x3D; name;\n    &#125;\n\n    @Override\n    public boolean isNull() &#123;\n        return false;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>空对象</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class EmptyUser extends AbstractUser&#123;\n\n    public EmptyUser() &#123;\n        this.name &#x3D; &quot;空用户对象...&quot;;\n    &#125;\n\n    @Override\n    public boolean isNull() &#123;\n        return true;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>创建一个测试用的工厂</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserFactory &#123;\n\n    private static List&lt;String&gt; nameList;\n\n    static &#123;\n        nameList &#x3D; ListUtil.of(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;);\n    &#125;\n\n    public static AbstractUser getUser(String name) &#123;\n        for (String n : nameList) &#123;\n            if(n.equalsIgnoreCase(name))&#123;\n                return new User(name);\n            &#125;\n        &#125;\n        return new EmptyUser();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        AbstractUser 张三 &#x3D; UserFactory.getUser(&quot;张三&quot;);\n        AbstractUser 赵六 &#x3D; UserFactory.getUser(&quot;赵六&quot;);\n\n        System.out.println(张三);\n        System.out.println(赵六);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214080526276.png\" alt=\"image-20221214080526276\"></p>\n<h2 id=\"23-策略模式\"><a href=\"#23-策略模式\" class=\"headerlink\" title=\"23.策略模式\"></a>23.策略模式</h2><p>Strategy，一个类的行为或其算法可以在运行时更改。</p>\n<p><strong>定义策略的接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Strategy &#123;\n\n    public int doStrategy(int a,int b);\n&#125;</code></pre>\n\n<p><strong>定义策略实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AddStrategy implements Strategy &#123;\n\n    @Override\n    public int doStrategy(int a, int b) &#123;\n        return a + b;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SubStrategy implements Strategy &#123;\n    @Override\n    public int doStrategy(int a, int b) &#123;\n        return a - b;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义一个可更改策略的上下文</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class Context &#123;\n\n    private Strategy strategy;\n\n    public int executeStrategy(int a,int b)&#123;\n        if(strategy !&#x3D; null)&#123;\n            return strategy.doStrategy(a,b);\n        &#125;else &#123;\n            throw new RuntimeException(&quot;尚未设置策略！&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Context context &#x3D; new Context();\n        AddStrategy addStrategy &#x3D; new AddStrategy();\n        SubStrategy subStrategy &#x3D; new SubStrategy();\n\n        context.setStrategy(addStrategy);\n        int i1 &#x3D; context.executeStrategy(1, 2);\n        System.out.println(i1);\n\n        context.setStrategy(subStrategy);\n        int i2 &#x3D; context.executeStrategy(5, 2);\n        System.out.println(i2);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p>两个3</p>\n<h2 id=\"24-模板模式\"><a href=\"#24-模板模式\" class=\"headerlink\" title=\"24.模板模式\"></a>24.模板模式</h2><p>Template，在抽象类中提前定义了某个操作的一系列流程的模板，用户只需要实现具体细节即可。</p>\n<p><strong>定义抽象模板父类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class MyGame &#123;\n\n    protected String name;\n\n    abstract void downloadGame();\n    abstract void installGame();\n    abstract void openGame();\n\n    public void playGame() &#123;\n        downloadGame();\n        installGame();\n        openGame();\n        System.out.println(&quot;开始游戏:[&quot; + name + &quot;]&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>创建抽象父类的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LOL extends MyGame&#123;\n\n    public LOL()&#123;\n        this.name &#x3D; &quot;LOL&quot;;\n    &#125;\n\n    @Override\n    void downloadGame() &#123;\n        System.out.println(&quot;正在下载游戏:&quot; + name);\n    &#125;\n\n    @Override\n    void installGame() &#123;\n        System.out.println(&quot;正在安装游戏:&quot; + name);\n    &#125;\n\n    @Override\n    void openGame() &#123;\n        System.out.println(&quot;正在打开游戏:&quot; + name);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CSGO extends MyGame&#123;\n\n    public CSGO() &#123;\n        this.name &#x3D; &quot;CSGO&quot;;\n    &#125;\n\n    @Override\n    void downloadGame() &#123;\n        System.out.println(&quot;正在下载游戏:&quot; + name);\n    &#125;\n\n    @Override\n    void installGame() &#123;\n        System.out.println(&quot;正在安装游戏:&quot; + name);\n    &#125;\n\n    @Override\n    void openGame() &#123;\n        System.out.println(&quot;正在打开游戏:&quot; + name);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        LOL lol &#x3D; new LOL();\n        CSGO csgo &#x3D; new CSGO();\n\n        lol.playGame();\n        csgo.playGame();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221215170923686.png\" alt=\"image-20221215170923686\"></p>\n<h2 id=\"25-访问者模式\"><a href=\"#25-访问者模式\" class=\"headerlink\" title=\"25.访问者模式\"></a>25.访问者模式</h2><p>Visitor，封装一些作用于某些数据结构中的各元素的操作，它可以在不改变数据结构的前提下赋予这些元素新的操作。</p>\n<p><strong>定义被访问者的统一接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Person&#123;\n\n    public void accept(Visitor visitor);\n&#125;</code></pre>\n\n<p><strong>定义被访问者实例</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@AllArgsConstructor\npublic class Student implements Person &#123;\n\n    private String name;\n    private Integer rank;\n\n    @Override\n    public void accept(Visitor visitor) &#123;\n        visitor.visit(this);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@AllArgsConstructor\npublic class Teacher implements Person &#123;\n\n    private String name;\n    private Integer salary;\n\n    @Override\n    public void accept(Visitor visitor) &#123;\n        visitor.visit(this);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义访问者接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Visitor &#123;\n\n    public void visit(Student student);\n\n    public void visit(Teacher teacher);\n&#125;</code></pre>\n\n<p><strong>定义访问者实例</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Headmaster implements Visitor &#123;\n    @Override\n    public void visit(Student student) &#123;\n        System.out.println(&quot;访问学生:&quot; + student.getName() + &quot;,排名为:&quot; + student.getRank());\n    &#125;\n\n    @Override\n    public void visit(Teacher teacher) &#123;\n        System.out.println(&quot;访问老师:&quot; + teacher.getName() + &quot;,月薪为:&quot; + teacher.getSalary());\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Student student &#x3D; new Student(&quot;张三&quot;,21);\n        Teacher teacher &#x3D; new Teacher(&quot;张雪迎&quot;,8000);\n        Headmaster headmaster &#x3D; new Headmaster();\n\n        student.accept(headmaster);\n        teacher.accept(headmaster);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221216100457969.png\" alt=\"image-20221216100457969\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><p>菜鸟设计模式：</p>\n<p><a href=\"https://www.runoob.com/design-pattern/design-pattern-tutorial.html\">https://www.runoob.com/design-pattern/design-pattern-tutorial.html</a></p>\n<p>UML类图教程：</p>\n<p><a href=\"https://blog.csdn.net/weixin_57504000/article/details/124218420\">https://blog.csdn.net/weixin_57504000/article/details/124218420</a></p>\n<p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>\n<p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>\n<p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>\n<h1 id=\"一、创建型模式\"><a href=\"#一、创建型模式\" class=\"headerlink\" title=\"一、创建型模式\"></a>一、创建型模式</h1><h2 id=\"1-工厂模式\"><a href=\"#1-工厂模式\" class=\"headerlink\" title=\"1.工厂模式\"></a>1.工厂模式</h2><p>获得<strong>复杂对象</strong>实例（简单对象只需要new即可），而无须关心其具体的实现细节。</p>\n<p><strong>实现：</strong></p>\n<p>定义一个接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Phone &#123;\n\n    public String use();\n&#125;</code></pre>\n\n<p>定义实体，并继承该接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Oppo implements Phone &#123;\n\n    @Override\n    public String use() &#123;\n        return &quot;我是oppo  &quot;;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Xiaomi implements Phone &#123;\n\n    @Override\n    public String use() &#123;\n        return &quot;我是小米&quot;;\n    &#125;\n&#125;</code></pre>\n\n<p>定义工厂类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class PhoneFactory &#123;\n\n    public static class Type&#123;\n        public static final String TYPE_XIAOMI &#x3D; &quot;xiaomi&quot;;\n        public static final String TYPE_OPPO &#x3D; &quot;oppo&quot;;\n    &#125;\n\n    public Phone getPhoneByType(String type) &#123;\n        if(type.equalsIgnoreCase(Type.TYPE_XIAOMI))&#123;\n            return new Xiaomi();\n        &#125;else if(type.equalsIgnoreCase(Type.TYPE_OPPO))&#123;\n            return new Oppo();\n        &#125;\n        return null;\n    &#125;\n&#125;</code></pre>\n\n<p>使用：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    public static void main(String[] args) &#123;\n        PhoneFactory phoneFactory &#x3D; new PhoneFactory();\n        Phone xiaomi &#x3D; phoneFactory.getPhoneByType(PhoneFactory.Type.TYPE_XIAOMI);\n        System.out.println(xiaomi.use());\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214080627939.png\" alt=\"image-20221214080627939\"></p>\n<h2 id=\"2-抽象工厂模式\"><a href=\"#2-抽象工厂模式\" class=\"headerlink\" title=\"2.抽象工厂模式\"></a>2.抽象工厂模式</h2><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。</p>\n<p>定义一个抽象工厂类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class AbstractFactory &#123;\n\n    public abstract Phone getPhoneByType(String phoneType);\n\n    public abstract Color getColorByType(String phoneType);\n&#125;</code></pre>\n\n<p>具体的工厂类继承该抽象工厂类：</p>\n<p>手机工厂：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class PhoneFactory extends AbstractFactory &#123;\n\n    public static class Type&#123;\n        public static final String TYPE_XIAOMI &#x3D; &quot;xiaomi&quot;;\n        public static final String TYPE_OPPO &#x3D; &quot;oppo&quot;;\n    &#125;\n\n    public Phone getPhoneByType(String type) &#123;\n        if(type.equalsIgnoreCase(Type.TYPE_XIAOMI))&#123;\n            return new Xiaomi();\n        &#125;else if(type.equalsIgnoreCase(Type.TYPE_OPPO))&#123;\n            return new Oppo();\n        &#125;\n        return null;\n    &#125;\n\n    @Override\n    public Color getColorByType(String phoneType) &#123;\n        return null;\n    &#125;\n&#125;</code></pre>\n\n<p>颜色工厂：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ColorFactory extends AbstractFactory &#123;\n\n    public static class TYPE&#123;\n        public static final String TYPE_RED &#x3D; &quot;red&quot;;\n\n        public static final String TYPE_YELLOW &#x3D; &quot;yellow&quot;;\n    &#125;\n\n    @Override\n    public Phone getPhoneByType(String phoneType) &#123;\n\n        return null;\n    &#125;\n\n    @Override\n    public Color getColorByType(String phoneType) &#123;\n        if (TYPE.TYPE_RED.equalsIgnoreCase(phoneType)) &#123;\n            return new Red();\n        &#125;else if (TYPE.TYPE_YELLOW.equalsIgnoreCase(phoneType))&#123;\n            return new Yellow();\n        &#125;\n        return null;\n    &#125;\n&#125;</code></pre>\n\n<p>定义一个超级工厂类，用于获得具体的工厂：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RootFactory &#123;\n\n    public static class TYPE&#123;\n        public static final String TYPE_PHONE &#x3D; &quot;phone&quot;;\n        public static final String TYPE_COLOR &#x3D; &quot;color&quot;;\n    &#125;\n\n    public static AbstractFactory getFactoryByType(String factoryType) &#123;\n        if (TYPE.TYPE_PHONE.equalsIgnoreCase(factoryType))&#123;\n            return new PhoneFactory();\n        &#125;else if(TYPE.TYPE_COLOR.equals(factoryType))&#123;\n            return new ColorFactory();\n        &#125;\n        return null;\n    &#125;\n&#125;</code></pre>\n\n<p>使用：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    &#x2F;&#x2F;获得工厂\n    AbstractFactory factoryByType &#x3D; RootFactory.getFactoryByType(RootFactory.TYPE.TYPE_COLOR);\n    &#x2F;&#x2F;从工厂获得对象\n    Color colorByType &#x3D; factoryByType.getColorByType(ColorFactory.TYPE.TYPE_RED);\n    System.out.println(colorByType.show());\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214080715116.png\" alt=\"image-20221214080715116\"></p>\n<h2 id=\"3-构造器模式\"><a href=\"#3-构造器模式\" class=\"headerlink\" title=\"3.构造器模式\"></a>3.构造器模式</h2><p>参考：<a href=\"https://www.dandelioncloud.cn/article/details/1523275053169147905\">https://www.dandelioncloud.cn/article/details/1523275053169147905</a></p>\n<p>传统的构造对象方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Person person &#x3D; new Person();\nperson.setId(1);\nperson.setName(&quot;张小毛&quot;);\nperson.setAge(22);\nperson.setSex(&quot;男&quot;);\nperson.setPhone(&quot;19999999999&quot;);\nperson.setAddress(&quot;beijing&quot;);\nperson.setDesc(&quot;JavaBeans模式&quot;);</code></pre>\n\n<ul>\n<li>优点：易于阅读，并且可以只对有用的成员变量赋值</li>\n<li>缺点：成员变量不可以是 final 类型，失去了不可变对象的很多好处，对象状态不连续，你必须调用7次setter方法才能得到一个具备7个属性值得变量，在这期间用户可能拿到不完整状态的对象。如果有N个属性，岂不是要<code>person.setXXX</code>调用N次？此种方式不优雅</li>\n</ul>\n<p>构造器模式演示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">PrivateKeyDecryptParam param &#x3D; new PrivateKeyDecryptParam.Builder()\n                                              .uAppId(uAppId)\n                                              .containerId(containerId)\n                                              .cipher(cipher)\n                                              .signFlag(signFlag)\n                                              .build();</code></pre>\n\n<p>示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@ToString\npublic class User &#123;\n\n    private String name;\n\n    private Integer age;\n\n    private Integer sex;\n\n    private User(Builder builder)&#123;\n        this.name &#x3D; builder.name;\n        this.age &#x3D; builder.age;\n        this.sex &#x3D; builder.sex;\n    &#125;\n\n    public static class Builder &#123;\n\n        &#x2F;&#x2F;必要参数\n        private final String name;\n\n        &#x2F;&#x2F;可选参数\n        private Integer age;\n        private Integer sex;\n\n        public Builder(String name)&#123;\n            this.name &#x3D; name;\n        &#125;\n\n        public Builder age(Integer age) &#123;\n            this.age &#x3D; age;\n            return this;\n        &#125;\n\n        public Builder sex(Integer sex) &#123;\n            this.sex &#x3D; sex;\n            return this;\n        &#125;\n\n        public User build() &#123;\n            return new User(this);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>使用：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">User cleWm &#x3D; new User.Builder(&quot;CleWm&quot;)\n        .age(21)\n        .sex(0)\n        .build();</code></pre>\n\n<p>要点：</p>\n<ul>\n<li>外部类的构造函数私有，且参数为静态内部类；</li>\n<li>静态内部类拥有外部类相同的属；</li>\n<li>为每一个属性，写一个方法，返回的是Builer；</li>\n<li>最后一个方法是build方法，用于构建一个外部类；</li>\n</ul>\n<p>优点：降低复杂性，优雅</p>\n<p>缺点：代码量提高了</p>\n<h2 id=\"4-单例模式\"><a href=\"#4-单例模式\" class=\"headerlink\" title=\"4.单例模式\"></a>4.单例模式</h2><p>一个类确保只有单个对象被创建</p>\n<p><strong>饿汉式：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HungrySingleton &#123;\n\n    private static HungrySingleton instance &#x3D; new HungrySingleton();\n\n    private HungrySingleton()&#123;&#125;\n\n    public static HungrySingleton getInstance()&#123;\n        return instance;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>懒汉式：</strong></p>\n<p>双重检查锁：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LazySingleton &#123;\n\n    private static LazySingleton instance;\n\n    private LazySingleton() &#123;&#125;\n\n    public static LazySingleton getInstance() &#123;\n        if(instance &#x3D;&#x3D; null)&#123;\n            synchronized (LazySingleton.class)&#123;\n                if (instance &#x3D;&#x3D; null)&#123;\n                    instance &#x3D; new LazySingleton();\n                &#125;\n            &#125;\n        &#125;\n        return instance;\n    &#125;\n&#125;</code></pre>\n\n<p>静态内部类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LazySingleton2 &#123;\n\n    private LazySingleton2()&#123;&#125;\n\n    &#x2F;**\n     * 静态内部类和非静态内部类都是在被调用的时候才会进行加载，和外部类没有关系，从而实现了延迟加载\n     *&#x2F;\n    private static class SingletonHolder&#123;\n        private static final LazySingleton2 instance &#x3D; new LazySingleton2();\n    &#125;\n\n    public static LazySingleton2 getInstance() &#123;\n        return SingletonHolder.instance;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        LazySingleton instance1 &#x3D; LazySingleton.getInstance();\n        LazySingleton instance2 &#x3D; LazySingleton.getInstance();\n        System.out.println(instance1 &#x3D;&#x3D; instance2);\n\n        LazySingleton2 instance3 &#x3D; LazySingleton2.getInstance();\n        LazySingleton2 instance4 &#x3D; LazySingleton2.getInstance();\n        System.out.println(instance3 &#x3D;&#x3D; instance4);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214081317951.png\" alt=\"image-20221214081317951\"></p>\n<h2 id=\"5-原型模式\"><a href=\"#5-原型模式\" class=\"headerlink\" title=\"5.原型模式\"></a>5.原型模式</h2><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。一般会配合工厂模式一起使用。</p>\n<p>与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p>\n<p>定义一个抽象父类，并实现Cloneable接口：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Cloneable是一个标识接口，clone方法是Object提供的方法，\n * 只有实现了Cloneable接口，同时重写clone方法才不会报错\n *&#x2F;\n@Getter\n@ToString\npublic abstract class Book implements Cloneable&#123;\n\n    protected String name;\n\n    protected Integer type;\n\n    @Override\n    protected Book clone()&#123;\n        Object clone &#x3D; null;\n        try&#123;\n            clone &#x3D; super.clone();\n        &#125;catch (CloneNotSupportedException e)&#123;\n            e.printStackTrace();\n        &#125;\n        return (Book)clone;\n    &#125;\n&#125;</code></pre>\n\n<p>定义具体实现类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BookOne extends Book&#123;\n\n    BookOne() &#123;\n        name &#x3D; &quot;《第一本书》&quot;;\n        type &#x3D; 1;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BookTwo extends Book&#123;\n\n    BookTwo() &#123;\n        name &#x3D; &quot;《第二本书》&quot;;\n        type &#x3D; 2;\n    &#125;\n&#125;</code></pre>\n\n<p>定义一个Factory来获得克隆对象：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BookFactory &#123;\n\n    &#x2F;**\n     * 用于存储我们的原始对象，克隆对象以此为基础进行复制\n     *&#x2F;\n    private static final Map&lt;Integer,Book&gt; cache;\n\n    static &#123;\n        cache &#x3D; new HashMap&lt;&gt;();\n        cache.put(Type.TYPE_ONE,new BookOne());\n        cache.put(Type.TYPE_TWO,new BookTwo());\n    &#125;\n\n    public static class Type&#123;\n        public static final Integer TYPE_ONE &#x3D; 1;\n        public static final Integer TYPE_TWO &#x3D; 2;\n    &#125;\n\n    &#x2F;**\n     * 返回的是克隆对象\n     * @param type\n     * @return\n     *&#x2F;\n    public static Book getBookByType(Integer type) &#123;\n        return cache.get(type).clone();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n    @org.junit.Test\n    public void test1() &#123;\n        Book book1 &#x3D; BookFactory.getBookByType(BookFactory.Type.TYPE_ONE);\n        Book book2 &#x3D; BookFactory.getBookByType(BookFactory.Type.TYPE_ONE);\n        System.out.println(book1 &#x3D;&#x3D; book2);\n        System.out.println(book1);\n        System.out.println(book2);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214081502987.png\" alt=\"image-20221214081502987\"></p>\n<h1 id=\"二、结构型模式\"><a href=\"#二、结构型模式\" class=\"headerlink\" title=\"二、结构型模式\"></a>二、结构型模式</h1><h2 id=\"6-适配器模式\"><a href=\"#6-适配器模式\" class=\"headerlink\" title=\"6.适配器模式\"></a>6.适配器模式</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁</p>\n<p>比如220V的电源，使用电源适配器给手机提供12V的电压充电。</p>\n<p><strong>定义一个目标接口，该接口属于一般情况</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Target &#123;\n\n    public void get();\n&#125;</code></pre>\n\n<p><strong>定义一个不兼容的，需要被适配的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SpecialStatus &#123;\n\n    public void specialGet() &#123;\n        System.out.println(&quot;这是特殊情况的get实现&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义适配器，实现Target接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Adapter implements Target &#123;\n\n    private SpecialStatus specialStatus;\n\n    public Adapter(SpecialStatus specialStatus)&#123;\n        this.specialStatus &#x3D; specialStatus;\n    &#125;\n\n    @Override\n    public void get() &#123;\n        specialStatus.specialGet();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        SpecialStatus specialStatus &#x3D; new SpecialStatus();\n        Adapter adapter &#x3D; new Adapter(specialStatus);\n        adapter.get();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217093732742.png\" alt=\"image-20221217093732742\"></p>\n<h2 id=\"7-桥接模式\"><a href=\"#7-桥接模式\" class=\"headerlink\" title=\"7.桥接模式\"></a>7.桥接模式</h2><p>Bridge，它的作用是将抽象部分和它的实现部分分离，从而可以让它们独立地变化。</p>\n<p>就好比有一个武器槽，放不同的武器进去就是不同的功能。s</p>\n<p><strong>先定义抽象部分，比如武器槽</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class WeaponSlot &#123;\n\n    protected Weapon weapon;\n\n    abstract void shoot();\n\n    public void setWeapon(Weapon weapon)&#123;\n        this.weapon &#x3D; weapon;\n    &#125;\n\n    public abstract void opreation();\n&#125;</code></pre>\n\n<p><strong>定义实现的接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Weapon &#123;\n\n    void shoot();\n&#125;</code></pre>\n\n<p><strong>定义抽象部分的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LeftSlot extends WeaponSlot&#123;\n\n    @Override\n    void shoot() &#123;\n        weapon.shoot();\n    &#125;\n\n    @Override\n    public void opreation() &#123;\n        weapon.shoot();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义实现接口的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AK47 implements Weapon &#123;\n    @Override\n    public void shoot() &#123;\n        System.out.println(&quot;AK开枪了！&quot;);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class M4 implements Weapon &#123;\n    @Override\n    public void shoot() &#123;\n        System.out.println(&quot;m4开枪！&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n\n        M4 m4 &#x3D; new M4();\n        AK47 ak47 &#x3D; new AK47();\n\n        LeftSlot leftSlot &#x3D; new LeftSlot();\n        leftSlot.setWeapon(m4);\n        leftSlot.opreation();\n\n        leftSlot.setWeapon(ak47);\n        leftSlot.opreation();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103542571.png\" alt=\"image-20221217103542571\"></p>\n<h2 id=\"8-过滤器模式\"><a href=\"#8-过滤器模式\" class=\"headerlink\" title=\"8.过滤器模式\"></a>8.过滤器模式</h2><p>Filter ，它的作用是过滤序列中的特定元素。</p>\n<p><strong>定义一个过滤器的接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Filter &lt;T&gt;&#123;\n\n    List&lt;T&gt; doFilter(List&lt;T&gt; lists);\n&#125;</code></pre>\n\n<p><strong>定义要过滤的实体类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class User &#123;\n\n    private String name;\n\n    private Integer age;\n\n    private Integer sex;\n&#125;</code></pre>\n\n<p><strong>定义过滤器的具体实现</strong></p>\n<p>年龄过滤器：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AgeFilter implements Filter&lt;User&gt; &#123;\n\n    @Override\n    public List&lt;User&gt; doFilter(List&lt;User&gt; lists) &#123;\n        ArrayList&lt;User&gt; res &#x3D; new ArrayList&lt;&gt;();\n        for (User user : lists) &#123;\n            if(user.getAge() &gt;&#x3D; 18)&#123;\n                res.add(user);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;</code></pre>\n\n<p>性别过滤器：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SexFilter implements Filter&lt;User&gt; &#123;\n    @Override\n    public List&lt;User&gt; doFilter(List&lt;User&gt; lists) &#123;\n        ArrayList&lt;User&gt; res &#x3D; new ArrayList&lt;&gt;();\n        for (User user : lists) &#123;\n            if (user.getSex() &#x3D;&#x3D; 1)&#123;\n                res.add(user);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        AgeFilter ageFilter &#x3D; new AgeFilter();\n        SexFilter sexFilter &#x3D; new SexFilter();\n        ArrayList&lt;User&gt; userArrayList &#x3D; new ArrayList&lt;&gt;();\n        for (int i &#x3D; 1; i &lt; 10; i++) &#123;\n            User user &#x3D; new User();\n            user.setAge(RandomUtil.randomInt(10,35));\n            user.setName(&quot;张&quot; + i);\n            user.setSex(RandomUtil.randomEle(new Integer[]&#123;0,1&#125;));\n            userArrayList.add(user);\n        &#125;\n        List&lt;User&gt; users1 &#x3D; ageFilter.doFilter(userArrayList);\n        System.out.println(&quot;第一次过滤后的结果：&quot; + users1);\n\n        List&lt;User&gt; users2 &#x3D; sexFilter.doFilter(users1);\n        System.out.println(&quot;第二次过滤后的结果：&quot; + users2);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103713100.png\" alt=\"image-20221217103713100\"></p>\n<h2 id=\"9-组合模式\"><a href=\"#9-组合模式\" class=\"headerlink\" title=\"9.组合模式\"></a>9.组合模式</h2><p>Composite，是用于把一组相似的对象当作一个单一的对象。组合模式依据<strong>树形结构</strong>来组合对象，用来表示部分以及整体层次。</p>\n<p>例如：在可视化开发中，容器和按钮等组件之间的关系。又或者是公司、学校的组织架构等。</p>\n<p>以学校为例：</p>\n<p><strong>定义一个员工类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@ToString(exclude &#x3D; &quot;subordinates&quot;)\npublic class Employee &#123;\n\n    private String name;\n\n    private String dept;\n\n    private Integer salary;\n\n    private List&lt;Employee&gt; subordinates;\n\n    public Employee(String name, String dept, Integer salary) &#123;\n        this.name &#x3D; name;\n        this.dept &#x3D; dept;\n        this.salary &#x3D; salary;\n        this.subordinates &#x3D; new ArrayList&lt;&gt;();\n    &#125;\n\n    public void addSubordinate(Employee subordinate) &#123;\n        subordinates.add(subordinate);\n    &#125;\n\n    public void removeSubordinate(Employee subordinate) &#123;\n        subordinates.remove(subordinate);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Employee 张昌平 &#x3D; new Employee(&quot;张昌平&quot;, &quot;校长&quot;, 30000);\n\n        Employee 张雪迎 &#x3D; new Employee(&quot;张雪迎&quot;, &quot;7班班主任&quot;, 10000);\n        Employee 刘静 &#x3D; new Employee(&quot;刘静&quot;, &quot;8班班主任&quot;, 9000);\n\n        Employee 胡伟明 &#x3D; new Employee(&quot;胡伟明&quot;, &quot;7班学生&quot;, 0);\n        Employee 李冠杰 &#x3D; new Employee(&quot;李冠杰&quot;, &quot;7班学生&quot;, 0);\n        Employee 田继睿 &#x3D; new Employee(&quot;田继睿&quot;, &quot;7班学生&quot;, 0);\n        Employee 冯毅力 &#x3D; new Employee(&quot;冯毅力&quot;, &quot;7班学生&quot;, 0);\n\n        Employee 冯跟源 &#x3D; new Employee(&quot;冯跟源&quot;, &quot;8班学生&quot;, 0);\n        Employee 施冰清 &#x3D; new Employee(&quot;施冰清&quot;, &quot;8班学生&quot;, 0);\n\n\n\n        张昌平.addSubordinate(张雪迎);\n        张昌平.addSubordinate(刘静);\n\n\n        张雪迎.addSubordinate(胡伟明);\n        张雪迎.addSubordinate(李冠杰);\n        张雪迎.addSubordinate(田继睿);\n        张雪迎.addSubordinate(冯毅力);\n\n        刘静.addSubordinate(冯跟源);\n        刘静.addSubordinate(施冰清);\n\n        &#x2F;**\n         * 二叉树如下:\n         *                      张昌平\n         *                    &#x2F;      \\\n         *                   &#x2F;        \\\n         *                张雪迎        刘静\n         *                &#x2F; | | \\      &#x2F; \\\n         *               &#x2F;  | |  \\    &#x2F;   \\\n         *             胡   李 冯 田   冯   施\n         *&#x2F;\n        System.out.println(张昌平);\n        for (Employee sub1 : 张昌平.getSubordinates())&#123;\n            System.out.println(sub1);\n            for (Employee sub2 : sub1.getSubordinates())&#123;\n                System.out.println(sub2);\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103845510.png\" alt=\"image-20221217103845510\"></p>\n<h2 id=\"10-装饰器模式\"><a href=\"#10-装饰器模式\" class=\"headerlink\" title=\"10.装饰器模式\"></a>10.装饰器模式</h2><p>Decorator，允许向一个现有的对象添加新的功能，同时又不改变其结构。</p>\n<p><strong>定义一个接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Person &#123;\n\n    void eat();\n&#125;</code></pre>\n\n<p><strong>定义一个接口的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CleWm implements Person &#123;\n    @Override\n    public void eat() &#123;\n        System.out.println(&quot;吃了一碗饭...&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义一个装饰器，实现接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Decorator implements Person &#123;\n\n    private Person person;\n\n    @Override\n    public void eat() &#123;\n        person.eat();\n        System.out.println(&quot;person又吃了一碗...&quot;);\n    &#125;\n\n    public void setPerson(Person person) &#123;\n        this.person &#x3D; person;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        CleWm cleWm &#x3D; new CleWm();\n        Decorator decorator &#x3D; new Decorator();\n        decorator.setPerson(cleWm);\n        decorator.eat();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217103941837.png\" alt=\"image-20221217103941837\"></p>\n<h2 id=\"11-外观模式\"><a href=\"#11-外观模式\" class=\"headerlink\" title=\"11.外观模式\"></a>11.外观模式</h2><p>Facade，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 外观类\npublic class Facade &#123;\n   private Subsystem1 subsystem1;\n   private Subsystem2 subsystem2;\n\n   public Facade() &#123;\n      subsystem1 &#x3D; new Subsystem1();\n      subsystem2 &#x3D; new Subsystem2();\n   &#125;\n\n   &#x2F;&#x2F; 提供一个简化的接口，用于客户端访问子系统\n   public void operation() &#123;\n      subsystem1.operation1();\n      subsystem2.operation1();\n   &#125;\n&#125;\n\n&#x2F;&#x2F; 子系统1\npublic class Subsystem1 &#123;\n   public void operation1() &#123;\n      &#x2F;&#x2F; 实现子系统1的相关操作\n   &#125;\n&#125;\n\n&#x2F;&#x2F; 子系统2\npublic class Subsystem2 &#123;\n   public void operation1() &#123;\n      &#x2F;&#x2F; 实现子系统2的相关操作\n   &#125;\n&#125;</code></pre>\n\n<h2 id=\"12-享元模式\"><a href=\"#12-享元模式\" class=\"headerlink\" title=\"12.享元模式\"></a>12.享元模式</h2><p>Flyweight，主要用于减少创建对象的数量，以减少内存占用和提高性能。</p>\n<p>说白了就是在工厂模式的工厂类中，缓存一个Map，每次创建对象的时候就进行一个判断，若指定对象存在，则直接从map中取出并返回，若没有，则新建，然后缓存进入Map当中。</p>\n<p><strong>创建一个颜色</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Color &#123;\n\n    public String colorName;\n\n    public Color(String colorName)&#123;\n        this.colorName &#x3D; colorName;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>创建一个颜色工厂</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ColorFactory &#123;\n\n    private Map&lt;String, Color&gt; map &#x3D; new HashMap&lt;&gt;();\n\n    public Color getColor(String colorName) &#123;\n        return Optional.ofNullable(map.get(colorName)).orElseGet(()-&gt;&#123;\n            Color color &#x3D; new Color(colorName);\n            map.put(colorName,color);\n            return color;\n        &#125;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        ColorFactory colorFactory &#x3D; new ColorFactory();\n        Color red1 &#x3D; colorFactory.getColor(&quot;red&quot;);\n        Color red2 &#x3D; colorFactory.getColor(&quot;red&quot;);\n        Color red3 &#x3D; colorFactory.getColor(&quot;blue&quot;);\n        System.out.println(red1 &#x3D;&#x3D; red2);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104139185.png\" alt=\"image-20221217104139185\"></p>\n<h2 id=\"13-代理模式\"><a href=\"#13-代理模式\" class=\"headerlink\" title=\"13.代理模式\"></a>13.代理模式</h2><p>Proxy，它通过引入一个新的类来控制对另一个对象的访问。这有助于控制对原始对象的访问，并且可以在访问原始对象时执行其他附加操作。</p>\n<p><strong>定义一个接口，包含被代理的方法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Image &#123;\n\n    public void show();\n&#125;</code></pre>\n\n<p><strong>定义原始类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Realimage implements Image &#123;\n\n    private String path;\n\n    public Realimage(String path) &#123;\n        this.path &#x3D; path;\n        loadFromDisk();\n    &#125;\n\n    @Override\n    public void show() &#123;\n        System.out.println(&quot;展示&quot; + path + &quot;的图片&quot;);\n    &#125;\n\n    void loadFromDisk() &#123;\n        System.out.println(&quot;正在从磁盘中加载图片:&quot; + path);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义代理对象</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ProxyImage implements Image &#123;\n\n    private String path;\n\n    private Realimage realimage;\n\n    public ProxyImage(String path) &#123;\n        this.path &#x3D; path;\n    &#125;\n\n    @Override\n    public void show() &#123;\n        if(realimage &#x3D;&#x3D; null)&#123;\n            realimage &#x3D; new Realimage(path);\n        &#125;\n        realimage.show();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        ProxyImage proxyImage &#x3D; new ProxyImage(&quot;C:\\\\test.jpg&quot;);\n        proxyImage.show();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104158303.png\" alt=\"image-20221217104158303\"></p>\n<h1 id=\"三、行为型模式\"><a href=\"#三、行为型模式\" class=\"headerlink\" title=\"三、行为型模式\"></a>三、行为型模式</h1><h2 id=\"14-责任链模式\"><a href=\"#14-责任链模式\" class=\"headerlink\" title=\"14.责任链模式\"></a>14.责任链模式</h2><p>Chain of Responsibility，为请求创建了一个接收者对象的链。</p>\n<p>通常每个接收者都包含对另一个接收者的引用。<strong>如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者</strong>，依此类推。</p>\n<p><strong>定义一个实体</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@AllArgsConstructor\npublic class Package &#123;\n\n    private String loc;\n&#125;</code></pre>\n\n<p><strong>定义一个处理器的抽象父类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class PackageHandler &#123;\n\n    private PackageHandler next;\n\n    public void next(PackageHandler next)&#123;\n        this.next &#x3D; next;\n    &#125;\n\n    public void handler(Package p)&#123;\n        if(next !&#x3D; null)&#123;\n            next.handler(p);\n        &#125;else &#123;\n            System.out.println(&quot;接收到一个未知地点的包裹....&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义处理器的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class KunmingPackageHandler extends PackageHandler&#123;\n    @Override\n    public void handler(Package p) &#123;\n        if(&quot;昆明&quot;.equals(p.getLoc()))&#123;\n            System.out.println(&quot;处理了一个昆明的包裹...[&quot; + this + &quot;]&quot;);\n            return;\n        &#125;else &#123;\n            super.handler(p);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TianJinPackageHandler extends PackageHandler&#123;\n\n    @Override\n    public void handler(Package p) &#123;\n        if(&quot;天津&quot;.equals(p.getLoc()))&#123;\n            System.out.println(&quot;处理了一个天津的包裹...[&quot; + this + &quot;]&quot;);\n            return;\n        &#125;else &#123;\n            super.handler(p);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        KunmingPackageHandler kunmingPackageHandler &#x3D; new KunmingPackageHandler();\n        TianJinPackageHandler tianJinPackageHandler &#x3D; new TianJinPackageHandler();\n\n        &#x2F;&#x2F; |kunmingPackageHandler| ------ |tianJinPackageHandler| ------ null\n        kunmingPackageHandler.next(tianJinPackageHandler);\n\n\n        Package package1 &#x3D; new Package(&quot;天津&quot;);\n        Package package2 &#x3D; new Package(&quot;昆明&quot;);\n        Package package3 &#x3D; new Package(&quot;四川&quot;);\n\n        List&lt;Package&gt; packageList &#x3D; ListUtil.of(package1, package2, package3);\n        for (Package aPackage : packageList) &#123;\n            kunmingPackageHandler.handler(aPackage);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104231704.png\" alt=\"image-20221217104231704\"></p>\n<h2 id=\"15-命令模式\"><a href=\"#15-命令模式\" class=\"headerlink\" title=\"15.命令模式\"></a>15.命令模式</h2><p>Command，<strong>命令模式允许请求的一方和接收的一方独立开来</strong>，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221211094616223.png\" alt=\"image-20221211094616223\"></p>\n<p>简单理解就是，封装一条命令，为该命令设置一个接收者，然后将该命令set进一个调用者对象（Invoker）中，最后调用Invoker的runCommand方法来执行命令。</p>\n<p><strong>创建命令接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Command &#123;\n\n    void run();\n&#125;</code></pre>\n\n<p><strong>创建接收者(可以理解为被隐藏的具体功能实现的部分)</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Receiver &#123;\n\n    private Integer stock &#x3D; 100;\n\n    &#x2F;**\n     * 接收者的增加库存接口，命令调用者无须关心这些接口。\n     *&#x2F;\n    public void increase() &#123;\n        stock++;\n        System.out.println(&quot;[库存剩余]:&quot; + stock);\n    &#125;\n\n    &#x2F;**\n     * 接收者的减少库存接口，命令调用者无须关心这些接口。\n     *&#x2F;\n    public void decrease() &#123;\n        stock--;\n        System.out.println(&quot;[库存剩余]:&quot; + stock);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>创建命令实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AddStockCommand implements Command &#123;\n\n    private Receiver receiver;\n\n    public AddStockCommand(Receiver receiver) &#123;\n        this.receiver &#x3D; receiver;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        receiver.increase();\n        System.out.println(&quot;添加了1个库存...&quot;);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SubStockCommand implements Command &#123;\n\n    private Receiver receiver;\n\n    public SubStockCommand(Receiver receiver)&#123;\n        this.receiver &#x3D; receiver;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        receiver.decrease();\n        System.out.println(&quot;减少了1个库存...&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>创建调用者</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Invoker&#123;\n\n    &#x2F;&#x2F; 这里也可用一个List来存储命令，在调用时使用for循环命令依次执行。\n    private Command command;\n\n    public Invoker(Command command)&#123;\n        this.command &#x3D; command;\n    &#125;\n\n    public void invokeCommand() &#123;\n        if(command !&#x3D; null)&#123;\n            command.run();\n            System.out.println(&quot;命令执行完毕...&quot;);\n        &#125;else &#123;\n            System.out.println(&quot;未设置命令！&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        &#x2F;&#x2F; 创建一个接收者\n        Receiver receiver &#x3D; new Receiver();\n\n        &#x2F;&#x2F; 库存增加命令\n        AddStockCommand addStockCommand &#x3D; new AddStockCommand(receiver);\n        &#x2F;&#x2F; 库存减少命令\n        SubStockCommand subStockCommand &#x3D; new SubStockCommand(receiver);\n\n        &#x2F;&#x2F; 创建一个调用者\n        Invoker invoker1 &#x3D; new Invoker(addStockCommand);\n        &#x2F;&#x2F; 让调用者执行命令。\n        invoker1.invokeCommand();\n\n        &#x2F;&#x2F; 创建一个调用者\n        Invoker invoker2 &#x3D; new Invoker(subStockCommand);\n        &#x2F;&#x2F; 让调用者执行命令。\n        invoker2.invokeCommand();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104253518.png\" alt=\"image-20221217104253518\"></p>\n<h2 id=\"16-解释器模式\"><a href=\"#16-解释器模式\" class=\"headerlink\" title=\"16.解释器模式\"></a>16.解释器模式</h2><p>Interpreter，它允许你定义一个语言的文法，并且基于该文法解释语言中的句子。</p>\n<p><strong>定义表达式接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Expression &#123;\n\n    boolean interpret(String content);\n&#125;</code></pre>\n\n<p><strong>定义表达式</strong></p>\n<p><strong>关键词表达式，若内容中包含指定data内容，则为true</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class KeyWordExpression implements Expression &#123;\n\n    private String data;\n\n    public KeyWordExpression(String data)&#123;\n        this.data &#x3D; data;\n    &#125;\n\n\n    @Override\n    public boolean interpret(String content) &#123;\n        if (data !&#x3D; null)&#123;\n            return content.contains(data);\n        &#125;\n        else &#123;\n            throw new RuntimeException(&quot;未设置表达式data内容&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>或表达式</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class OrExpression implements Expression &#123;\n\n    private Expression exp1;\n    private Expression exp2;\n\n    public OrExpression(Expression exp1,Expression exp2) &#123;\n        this.exp1 &#x3D; exp1;\n        this.exp2 &#x3D; exp2;\n    &#125;\n\n    @Override\n    public boolean interpret(String content) &#123;\n        return exp1.interpret(content) || exp2.interpret(content);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>与表达式</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AndExpression implements Expression &#123;\n\n    private Expression exp1;\n    private Expression exp2;\n\n    public AndExpression(Expression exp1, Expression exp2) &#123;\n        this.exp1 &#x3D; exp1;\n        this.exp2 &#x3D; exp2;\n    &#125;\n\n    @Override\n    public boolean interpret(String content) &#123;\n        return exp1.interpret(content) &amp;&amp; exp2.interpret(content);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        KeyWordExpression exp1 &#x3D; new KeyWordExpression(&quot;CleWm&quot;);\n        boolean res1 &#x3D; exp1.interpret(&quot;I am CleWm&quot;);\n\n        KeyWordExpression exp2 &#x3D; new KeyWordExpression(&quot;CleWm&quot;);\n        KeyWordExpression exp3 &#x3D; new KeyWordExpression(&quot;clewm&quot;);\n\n        OrExpression exp4 &#x3D; new OrExpression(exp2, exp3);\n        boolean res2 &#x3D; exp4.interpret(&quot;CleWm&quot;);\n        AndExpression exp5 &#x3D; new AndExpression(exp2, exp3);\n        boolean res3 &#x3D; exp5.interpret(&quot;CleWm&quot;);\n        System.out.println(res1);\n        System.out.println(res2);\n        System.out.println(res3);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104357944.png\" alt=\"image-20221217104357944\"></p>\n<h2 id=\"17-迭代器模式\"><a href=\"#17-迭代器模式\" class=\"headerlink\" title=\"17.迭代器模式\"></a>17.迭代器模式</h2><p>Iterator，这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p>\n<p><strong>创建迭代器接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Container &#123;\n\n    MyIterator getIterator();\n&#125;</code></pre>\n\n<p><strong>创建容器接口，该接口用于使得容器能够返回一个迭代器</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Container &#123;\n\n    MyIterator getIterator();\n&#125;</code></pre>\n\n<p><strong>创建容器的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class PersonRepository implements Container &#123;\n\n    private static final List&lt;String&gt; personList;\n    private int index;\n\n    static &#123;\n        personList &#x3D; ListUtil.of(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;赵六&quot;);\n    &#125;\n\n    @Override\n    public MyIterator getIterator() &#123;\n        index &#x3D; 0;\n        return new PersonIterator();\n    &#125;\n\n    private class PersonIterator implements MyIterator&lt;String&gt;&#123;\n\n        @Override\n        public boolean hasNext() &#123;\n            return personList.size() &gt; 0 &amp;&amp; index &lt; personList.size();\n        &#125;\n\n        @Override\n        public String next() &#123;\n            return personList.get(index++);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1()&#123;\n        PersonRepository personRepository &#x3D; new PersonRepository();\n        MyIterator iterator &#x3D; personRepository.getIterator();\n        while (iterator.hasNext())&#123;\n            System.out.println(iterator.next());\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104416848.png\" alt=\"image-20221217104416848\"></p>\n<h2 id=\"18-中介者模式\"><a href=\"#18-中介者模式\" class=\"headerlink\" title=\"18.中介者模式\"></a>18.中介者模式</h2><p>Mediator，这种模式提供了一个中介类，该类通常处理不同类之间的通信。</p>\n<p>聊天室为例</p>\n<p><strong>定义用户</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class User &#123;\n\n    private String name;\n    private ChatRoom chatRoom;\n\n    public User(String name)&#123;\n        this.name &#x3D; name;\n    &#125;\n\n    public void sendMessage(String content) &#123;\n        System.out.println(name + &quot; 发送一条消息:&quot; + content);\n        Message message &#x3D; new Message(name, content);\n        if(chatRoom &#x3D;&#x3D; null)&#123;\n            throw new RuntimeException(&quot;未加入任何聊天室&quot;);\n        &#125;\n        chatRoom.send(message);\n    &#125;\n\n    public void receiveMessage(Message message) &#123;\n        System.out.println(name + &quot; 收到一条消息: &quot; + message);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义消息</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@AllArgsConstructor\npublic class Message &#123;\n\n    private String from;\n    private String content;\n&#125;</code></pre>\n\n<p><strong>定义聊天室</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ChatRoom &#123;\n\n    private List&lt;User&gt; userList &#x3D; new ArrayList&lt;&gt;();\n\n    public void send(Message message)&#123;\n        for (User user : userList)&#123;\n            if(message.getFrom().equals(user.getName())) continue;\n            user.receiveMessage(message);\n        &#125;\n    &#125;\n\n    public void register(User user) &#123;\n        user.setChatRoom(this);\n        userList.add(user);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        ChatRoom chatRoom &#x3D; new ChatRoom();\n\n        User 张三 &#x3D; new User(&quot;张三&quot;);\n        User 李四 &#x3D; new User(&quot;李四&quot;);\n        User 王五 &#x3D; new User(&quot;王五&quot;);\n        chatRoom.register(张三);\n        chatRoom.register(李四);\n        chatRoom.register(王五);\n\n        张三.sendMessage(&quot;你好，我是张三&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104510201.png\" alt=\"image-20221217104510201\"></p>\n<h2 id=\"19-备忘录模式\"><a href=\"#19-备忘录模式\" class=\"headerlink\" title=\"19.备忘录模式\"></a>19.备忘录模式</h2><p>Memento，保存（备份）一个对象的某个状态，以便在适当的时候恢复对象。</p>\n<p><strong>Memento ： 备忘录对象,负责 保存好记录，即Originator内部 状态</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class Memento &#123;\n\n    private String state;\n\n    public Memento(String state)&#123;\n        this.state &#x3D; state;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>originator : 对象(需要保存 状态的对象)</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class Originator &#123;\n\n    private String state;\n\n    public Memento saveStateToMemento() &#123;\n        return new Memento(state);\n    &#125;\n\n    public void restoreStateFromMemento(Memento memento) &#123;\n        this.state &#x3D; memento.getState();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>Caretaker: 备忘录管理者,负责保存多个备忘录对象， 使用集合管理，提高效率</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MementoManager &#123;\n\n    private static List&lt;Memento&gt; mementoList;\n\n    static &#123;\n        mementoList &#x3D; new ArrayList&lt;&gt;();\n    &#125;\n\n    public static boolean add(Memento memento)&#123;\n        return mementoList.add(memento);\n    &#125;\n\n    public static Memento remove(int index) &#123;\n        return mementoList.remove(index);\n    &#125;\n\n    public static Memento get(int index)&#123;\n        return mementoList.get(index);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Originator originator &#x3D; new Originator();\n        originator.setState(&quot;初始状态&quot;);\n        boolean add &#x3D; MementoManager.add(originator.saveStateToMemento());\n        if(!add) throw new RuntimeException(&quot;保存状态失败！&quot;);\n        originator.setState(&quot;第一状态&quot;);\n        System.out.println(&quot;origin的状态为:&quot; + originator.getState());\n        originator.restoreStateFromMemento(MementoManager.get(0));\n        System.out.println(&quot;origin的状态为:&quot; + originator.getState());\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><strong><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104545873.png\" alt=\"image-20221217104545873\"></strong></p>\n<h2 id=\"20-观察者模式\"><a href=\"#20-观察者模式\" class=\"headerlink\" title=\"20.观察者模式\"></a>20.观察者模式</h2><p>Observer，当一个对象被修改时，则会自动通知依赖它的对象。</p>\n<p><strong>创建一个被订阅的（Up主）</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Up &#123;\n\n    private String latestVideo;\n\n    private List&lt;Follower&gt; followers &#x3D; new ArrayList&lt;&gt;();\n\n    public void submitVideo(String video) &#123;\n        this.latestVideo &#x3D; video;\n        notifyAllFollowers();\n    &#125;\n\n    public void addFollower(Follower follower) &#123;\n        followers.add(follower);\n    &#125;\n\n    public void notifyAllFollowers() &#123;\n        for (Follower follower : followers) &#123;\n            follower.update(latestVideo);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>创建一个订阅者（粉丝）</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Follower&#123;\n\n    private String name;\n    private String video;\n    private Up up;\n\n    public Follower(String name,Up up) &#123;\n        this.name &#x3D; name;\n        this.up &#x3D; up;\n        this.up.addFollower(this);\n    &#125;\n\n    public void update(String video) &#123;\n        this.video &#x3D; video;\n        System.out.println(name + &quot; 收到up主 &quot; + up + &quot; 的最新视频 &quot; + video);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Up up &#x3D; new Up();\n        Follower 张三 &#x3D; new Follower(&quot;张三&quot;, up);\n        Follower 李四 &#x3D; new Follower(&quot;李四&quot;, up);\n\n        up.submitVideo(&quot;第1个视频&quot;);\n        System.out.println(&quot;-------------&quot;);\n        up.submitVideo(&quot;第2个视频&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104623464.png\" alt=\"image-20221217104623464\"></p>\n<h2 id=\"21-状态模式\"><a href=\"#21-状态模式\" class=\"headerlink\" title=\"21.状态模式\"></a>21.状态模式</h2><p>State，类的行为是基于它的状态改变的。</p>\n<p><strong>定义状态接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface State &#123;\n\n    void doAction(Context context);\n&#125;</code></pre>\n\n<p><strong>定义一个随着状态改变而做出不同行为的Context上下文</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class Context &#123;\n\n    private State state;\n\n&#125;</code></pre>\n\n<p><strong>定义状态的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class StartState implements State &#123;\n\n    @Override\n    public void doAction(Context context) &#123;\n        System.out.println(&quot;当前是开始状态...&quot;);\n        context.setState(this);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class EndState implements State &#123;\n    @Override\n    public void doAction(Context context) &#123;\n        System.out.println(&quot;当前是结束状态...&quot;);\n        context.setState(this);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Context context &#x3D; new Context();\n\n        StartState startState &#x3D; new StartState();\n        startState.doAction(context);\n\n        EndState endState &#x3D; new EndState();\n        endState.doAction(context);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221217104706915.png\" alt=\"image-20221217104706915\"></p>\n<h2 id=\"22-空对象模式\"><a href=\"#22-空对象模式\" class=\"headerlink\" title=\"22.空对象模式\"></a>22.空对象模式</h2><p>Null Object，一个空对象取代 NULL 对象。</p>\n<p><strong>定义实体类抽象父类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic abstract class AbstractUser &#123;\n\n    protected String name;\n\n    public abstract boolean isNull();\n&#125;</code></pre>\n\n<p><strong>定义正常的存在的用户对象</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class User extends AbstractUser&#123;\n    public User(String name)&#123;\n        this.name &#x3D; name;\n    &#125;\n\n    @Override\n    public boolean isNull() &#123;\n        return false;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>空对象</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class EmptyUser extends AbstractUser&#123;\n\n    public EmptyUser() &#123;\n        this.name &#x3D; &quot;空用户对象...&quot;;\n    &#125;\n\n    @Override\n    public boolean isNull() &#123;\n        return true;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>创建一个测试用的工厂</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserFactory &#123;\n\n    private static List&lt;String&gt; nameList;\n\n    static &#123;\n        nameList &#x3D; ListUtil.of(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;);\n    &#125;\n\n    public static AbstractUser getUser(String name) &#123;\n        for (String n : nameList) &#123;\n            if(n.equalsIgnoreCase(name))&#123;\n                return new User(name);\n            &#125;\n        &#125;\n        return new EmptyUser();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        AbstractUser 张三 &#x3D; UserFactory.getUser(&quot;张三&quot;);\n        AbstractUser 赵六 &#x3D; UserFactory.getUser(&quot;赵六&quot;);\n\n        System.out.println(张三);\n        System.out.println(赵六);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221214080526276.png\" alt=\"image-20221214080526276\"></p>\n<h2 id=\"23-策略模式\"><a href=\"#23-策略模式\" class=\"headerlink\" title=\"23.策略模式\"></a>23.策略模式</h2><p>Strategy，一个类的行为或其算法可以在运行时更改。</p>\n<p><strong>定义策略的接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Strategy &#123;\n\n    public int doStrategy(int a,int b);\n&#125;</code></pre>\n\n<p><strong>定义策略实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AddStrategy implements Strategy &#123;\n\n    @Override\n    public int doStrategy(int a, int b) &#123;\n        return a + b;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SubStrategy implements Strategy &#123;\n    @Override\n    public int doStrategy(int a, int b) &#123;\n        return a - b;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义一个可更改策略的上下文</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class Context &#123;\n\n    private Strategy strategy;\n\n    public int executeStrategy(int a,int b)&#123;\n        if(strategy !&#x3D; null)&#123;\n            return strategy.doStrategy(a,b);\n        &#125;else &#123;\n            throw new RuntimeException(&quot;尚未设置策略！&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Context context &#x3D; new Context();\n        AddStrategy addStrategy &#x3D; new AddStrategy();\n        SubStrategy subStrategy &#x3D; new SubStrategy();\n\n        context.setStrategy(addStrategy);\n        int i1 &#x3D; context.executeStrategy(1, 2);\n        System.out.println(i1);\n\n        context.setStrategy(subStrategy);\n        int i2 &#x3D; context.executeStrategy(5, 2);\n        System.out.println(i2);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p>两个3</p>\n<h2 id=\"24-模板模式\"><a href=\"#24-模板模式\" class=\"headerlink\" title=\"24.模板模式\"></a>24.模板模式</h2><p>Template，在抽象类中提前定义了某个操作的一系列流程的模板，用户只需要实现具体细节即可。</p>\n<p><strong>定义抽象模板父类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class MyGame &#123;\n\n    protected String name;\n\n    abstract void downloadGame();\n    abstract void installGame();\n    abstract void openGame();\n\n    public void playGame() &#123;\n        downloadGame();\n        installGame();\n        openGame();\n        System.out.println(&quot;开始游戏:[&quot; + name + &quot;]&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>创建抽象父类的实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LOL extends MyGame&#123;\n\n    public LOL()&#123;\n        this.name &#x3D; &quot;LOL&quot;;\n    &#125;\n\n    @Override\n    void downloadGame() &#123;\n        System.out.println(&quot;正在下载游戏:&quot; + name);\n    &#125;\n\n    @Override\n    void installGame() &#123;\n        System.out.println(&quot;正在安装游戏:&quot; + name);\n    &#125;\n\n    @Override\n    void openGame() &#123;\n        System.out.println(&quot;正在打开游戏:&quot; + name);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CSGO extends MyGame&#123;\n\n    public CSGO() &#123;\n        this.name &#x3D; &quot;CSGO&quot;;\n    &#125;\n\n    @Override\n    void downloadGame() &#123;\n        System.out.println(&quot;正在下载游戏:&quot; + name);\n    &#125;\n\n    @Override\n    void installGame() &#123;\n        System.out.println(&quot;正在安装游戏:&quot; + name);\n    &#125;\n\n    @Override\n    void openGame() &#123;\n        System.out.println(&quot;正在打开游戏:&quot; + name);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        LOL lol &#x3D; new LOL();\n        CSGO csgo &#x3D; new CSGO();\n\n        lol.playGame();\n        csgo.playGame();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221215170923686.png\" alt=\"image-20221215170923686\"></p>\n<h2 id=\"25-访问者模式\"><a href=\"#25-访问者模式\" class=\"headerlink\" title=\"25.访问者模式\"></a>25.访问者模式</h2><p>Visitor，封装一些作用于某些数据结构中的各元素的操作，它可以在不改变数据结构的前提下赋予这些元素新的操作。</p>\n<p><strong>定义被访问者的统一接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Person&#123;\n\n    public void accept(Visitor visitor);\n&#125;</code></pre>\n\n<p><strong>定义被访问者实例</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@AllArgsConstructor\npublic class Student implements Person &#123;\n\n    private String name;\n    private Integer rank;\n\n    @Override\n    public void accept(Visitor visitor) &#123;\n        visitor.visit(this);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@AllArgsConstructor\npublic class Teacher implements Person &#123;\n\n    private String name;\n    private Integer salary;\n\n    @Override\n    public void accept(Visitor visitor) &#123;\n        visitor.visit(this);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>定义访问者接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Visitor &#123;\n\n    public void visit(Student student);\n\n    public void visit(Teacher teacher);\n&#125;</code></pre>\n\n<p><strong>定义访问者实例</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Headmaster implements Visitor &#123;\n    @Override\n    public void visit(Student student) &#123;\n        System.out.println(&quot;访问学生:&quot; + student.getName() + &quot;,排名为:&quot; + student.getRank());\n    &#125;\n\n    @Override\n    public void visit(Teacher teacher) &#123;\n        System.out.println(&quot;访问老师:&quot; + teacher.getName() + &quot;,月薪为:&quot; + teacher.getSalary());\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n\n    @org.junit.Test\n    public void test1() &#123;\n        Student student &#x3D; new Student(&quot;张三&quot;,21);\n        Teacher teacher &#x3D; new Teacher(&quot;张雪迎&quot;,8000);\n        Headmaster headmaster &#x3D; new Headmaster();\n\n        student.accept(headmaster);\n        teacher.accept(headmaster);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>结果</strong></p>\n<p><img src=\"https://md-1259549904.cos.ap-shanghai.myqcloud.com/img/image-20221216100457969.png\" alt=\"image-20221216100457969\"></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clbrcchl80006qkiq1hdvcosa","category_id":"clbrcchl50003qkiq66td1f7m","_id":"clbrcchlf000mqkiqboti4h2h"},{"post_id":"clbrcchl80006qkiq1hdvcosa","category_id":"clbrcchld000eqkiq4b6031ag","_id":"clbrcchlg000oqkiq2iyb1yo2"},{"post_id":"clbrcchl90007qkiqgd2sefyt","category_id":"clbrcchl50003qkiq66td1f7m","_id":"clbrcchlh000tqkiqgowmaw0h"},{"post_id":"clbrcchl90007qkiqgd2sefyt","category_id":"clbrcchlf000lqkiq808pfh53","_id":"clbrcchlh000wqkiq7z730dg6"},{"post_id":"clbrcchl70005qkiqb05v6x1x","category_id":"clbrcchl50003qkiq66td1f7m","_id":"clbrcchlj0015qkiqhl6lgibj"},{"post_id":"clbrcchl70005qkiqb05v6x1x","category_id":"clbrcchld000eqkiq4b6031ag","_id":"clbrcchlj0018qkiq29p28k3z"},{"post_id":"clbrcchlb000aqkiq8khte6c3","category_id":"clbrcchl50003qkiq66td1f7m","_id":"clbrcchlk001bqkiqhjvta09j"},{"post_id":"clbrcchlb000aqkiq8khte6c3","category_id":"clbrcchlg000qqkiq36vsacjh","_id":"clbrcchlk001cqkiq00km7gxe"},{"post_id":"clbrcchlb000aqkiq8khte6c3","category_id":"clbrcchlj0017qkiq74bf8i6j","_id":"clbrcchlk001dqkiq26wg2puu"},{"post_id":"clbrcchkv0001qkiq7i6i3td4","category_id":"clbrcchl50003qkiq66td1f7m","_id":"clbrcchlk001fqkiqhyhxc2eb"},{"post_id":"clbrcchkv0001qkiq7i6i3td4","category_id":"clbrcchld000eqkiq4b6031ag","_id":"clbrcchlk001gqkiq9d9i7msj"},{"post_id":"clbrcchkv0001qkiq7i6i3td4","category_id":"clbrcchli0013qkiq3h0f5phe","_id":"clbrcchll001hqkiqajz1ci0a"},{"post_id":"clbrcchkv0001qkiq7i6i3td4","category_id":"clbrcchlk001aqkiq2pzoeuis","_id":"clbrcchll001iqkiq8ov8a6ih"},{"post_id":"clbrcchl30002qkiq0m2rfvx4","category_id":"clbrcchl50003qkiq66td1f7m","_id":"clbrcchll001jqkiq25sy5qi5"},{"post_id":"clbrcchl30002qkiq0m2rfvx4","category_id":"clbrcchld000eqkiq4b6031ag","_id":"clbrcchll001kqkiqdyst31gt"},{"post_id":"clbrcchl30002qkiq0m2rfvx4","category_id":"clbrcchli0013qkiq3h0f5phe","_id":"clbrcchll001lqkiq3jeka4y6"},{"post_id":"clbrcchl30002qkiq0m2rfvx4","category_id":"clbrcchlk001eqkiq4y1d0hnn","_id":"clbrcchll001mqkiq7kdmhb9z"}],"PostTag":[{"post_id":"clbrcchl90007qkiqgd2sefyt","tag_id":"clbrcchl60004qkiq0czw0e7e","_id":"clbrcchlc000bqkiq7w5361zp"},{"post_id":"clbrcchkv0001qkiq7i6i3td4","tag_id":"clbrcchl60004qkiq0czw0e7e","_id":"clbrcchle000gqkiqa2tv4uak"},{"post_id":"clbrcchkv0001qkiq7i6i3td4","tag_id":"clbrcchl90009qkiq023g0r5i","_id":"clbrcchle000iqkiq1lhnbd9s"},{"post_id":"clbrcchkv0001qkiq7i6i3td4","tag_id":"clbrcchlc000dqkiqak3fcy5a","_id":"clbrcchlf000kqkiqbcru2yjb"},{"post_id":"clbrcchl30002qkiq0m2rfvx4","tag_id":"clbrcchl60004qkiq0czw0e7e","_id":"clbrcchlg000pqkiq194r3j8d"},{"post_id":"clbrcchl30002qkiq0m2rfvx4","tag_id":"clbrcchle000jqkiq6iqpcpoy","_id":"clbrcchlg000rqkiqeqrk8ypw"},{"post_id":"clbrcchl70005qkiqb05v6x1x","tag_id":"clbrcchl60004qkiq0czw0e7e","_id":"clbrcchlh000xqkiq0kqj0gdv"},{"post_id":"clbrcchl70005qkiqb05v6x1x","tag_id":"clbrcchle000jqkiq6iqpcpoy","_id":"clbrcchlh000yqkiqez91f671"},{"post_id":"clbrcchl80006qkiq1hdvcosa","tag_id":"clbrcchl60004qkiq0czw0e7e","_id":"clbrcchli0011qkiqgjm807a1"},{"post_id":"clbrcchl80006qkiq1hdvcosa","tag_id":"clbrcchle000jqkiq6iqpcpoy","_id":"clbrcchli0012qkiq8eac176t"},{"post_id":"clbrcchlb000aqkiq8khte6c3","tag_id":"clbrcchl60004qkiq0czw0e7e","_id":"clbrcchlj0014qkiq67n51wbr"},{"post_id":"clbrcchlb000aqkiq8khte6c3","tag_id":"clbrcchli0010qkiqdfbp3fs8","_id":"clbrcchlj0016qkiqemop6aml"}],"Tag":[{"name":"Java","_id":"clbrcchl60004qkiq0czw0e7e"},{"name":"分布式存储引擎","_id":"clbrcchl90009qkiq023g0r5i"},{"name":"高并发","_id":"clbrcchlc000dqkiqak3fcy5a"},{"name":"分布式","_id":"clbrcchle000jqkiq6iqpcpoy"},{"name":"设计模式","_id":"clbrcchli0010qkiqdfbp3fs8"}]}}